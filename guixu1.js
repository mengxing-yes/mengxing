    // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
    // --- SillyTavern Global API ---
    // These are provided by the SillyTavern environment at runtime.
      // We will check for their existence before using them.
      /* global TavernHelper, eventOn, tavern_events, getChatMessages, getCurrentMessageId, _ */

      // --- Main Application Logic ---
      (function () {

    // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
    const AppStorage = (() => {
    const STORAGE_NAMESPACE = 'GUIXU_GACHA_';
    const getNamespacedKey = (key) => `${STORAGE_NAMESPACE}${key}`;
    const getCircularReplacer = () => {
        const seen = new WeakSet();
        return (key, value) => {
            if (typeof value === 'undefined') return null;
            if (typeof value === 'object' && value !== null) {
                if (seen.has(value)) return;
                seen.add(value);
            }
            return value;
        };
    };
    const saveData = (key, value) => {
        if (typeof key !== 'string') return;
        try {
            const namespacedKey = getNamespacedKey(key);
            const stringifiedValue = JSON.stringify(value, getCircularReplacer());
            localStorage.setItem(namespacedKey, stringifiedValue);
        } catch (error) {
            console.error(`AppStorage Error: Failed to save data for key \"${key}\".`, error);
        }
    };
    const loadData = (key, defaultValue = null) => {
        if (typeof key !== 'string') return defaultValue;
        try {
            const namespacedKey = getNamespacedKey(key);
            const stringifiedValue = localStorage.getItem(namespacedKey);
            if (stringifiedValue === null) return defaultValue;
            return JSON.parse(stringifiedValue);
        } catch (error) {
            console.error(`AppStorage Error: Failed to load data for key \"${key}\".`, error);
            return defaultValue;
        }
    };
    return { saveData, loadData };
})();
        'use strict';

        // --- API Availability Check ---
        if (
          typeof TavernHelper === 'undefined' ||
          typeof eventOn === 'undefined' ||
          typeof tavern_events === 'undefined' ||
          typeof getChatMessages === 'undefined' ||
          typeof getCurrentMessageId === 'undefined'
        ) {
          console.error('TavernHelper API, event system, or lodash not found.');
          document.addEventListener('DOMContentLoaded', () => {
            document.body.innerHTML =
              '<h1 style="color: red; text-align: center;">é”™è¯¯ï¼šSillyTavern ç¯å¢ƒ API æœªæ‰¾åˆ°æˆ–ç‰ˆæœ¬ä¸å…¼å®¹</h1><p style="color:grey; text-align:center;">è¯·ç¡®ä¿å·²å®‰è£…å¹¶å¯ç”¨ TavernHelper æ‰©å±•ã€‚</p>';
          });
          return;
        }

        // --- Core Application Object for UI Interactions ---
        // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
        const GuixuManager = {
          isInitialized: false, // åˆå§‹åŒ–çŠ¶æ€æ ‡å¿—

          destroy() {
            // æ¸…ç†é€»è¾‘å°†åœ¨è¿™é‡Œé€æ­¥æ·»åŠ 
            console.log('[å½’å¢Ÿ] GuixuManager.destroy() è¢«è°ƒç”¨');

            // 1. ç§»é™¤é”®ç›˜å¿«æ·é”®ç›‘å¬å™¨
            if (this.boundHandleKeydown) {
              document.removeEventListener('keydown', this.boundHandleKeydown);
              this.boundHandleKeydown = null;
            }

            // 2. æ¸…é™¤è‡ªåŠ¨ä¿å­˜å®šæ—¶å™¨
            if (this.autoSaveInterval) {
              clearInterval(this.autoSaveInterval);
              this.autoSaveInterval = null;
            }

            // 3. ç§»é™¤åŠ¨æ€æ·»åŠ çš„DOMå…ƒç´ 
            const rootContainer = document.querySelector('.guixu-root-container');
            if (rootContainer) {
              rootContainer.remove();
            }
            const modals = document.querySelectorAll('.modal-overlay');
            modals.forEach(modal => modal.remove());

            // 4. é‡ç½®æ‰€æœ‰çŠ¶æ€
            this.isInitialized = false;
            this.currentMvuState = null;
            this.db = null;
            this.dbPromise = null;
            this.equippedItems = {};
            this.pendingActions = [];
            this.guixuStoreItems = [];
            this.baseAttributes = {};
            this.calculatedMaxAttributes = {};
            this.lastExtractedJourney = null;
            this.lastExtractedPastLives = null;
            this.gachaState = {};
            this.gachaCollection = {};
            this.gachaHistory = [];
            this.gachaPools = { character: { ssr: [], sr: [], r: [] }, item: { ssr: [], sr: [], r: [] }, talent: { ssr: [], sr: [], r: [] } };
            // ... and so on for all other properties
          },
 
          // --- æ–°å¢ï¼šè¡æ¢¦å°˜ Gachaç³»ç»ŸçŠ¶æ€å˜é‡ ---
          isFromGuixuSystem: false,
    currentGachaPoolType: 'character', // æ–°å¢ï¼šè·Ÿè¸ªå½“å‰æ˜¾ç¤ºçš„å¡æ± ç±»å‹
      gachaState: {
              mengChen: 1600, // åˆå§‹èµ é€
              pitySSR_char: 0,
              pitySR_char: 0,
              pitySSR_item: 0,
              pitySR_item: 0,
              pitySSR_talent: 0,
              pitySR_talent: 0,
              redeemedCodes: [],
                  activeCompanions: [],
          },
          gachaCollection: {},
          gachaHistory: [],
          gachaPools: { // ä¿®æ”¹ä¸ºä¸‰å¡æ± ç»“æ„
              character: { ssr: [], sr: [], r: [] },
              item:      { ssr: [], sr: [], r: [] },
              talent:    { ssr: [], sr: [], r: [] }
          },
   
          isGachaCheatMode: false, // æ–°å¢ï¼šä½œå¼Šæ¨¡å¼å¼€å…³   
          pendingCompanionJoin: null, // æ–°å¢ï¼šç­‰å¾…åŠ å…¥ä¸–ç•Œçš„ä¼™ä¼´ä¿¡æ¯
          pendingCharacterCardGeneration: null, // æ–°å¢ï¼šç­‰å¾…AIç”Ÿæˆè§’è‰²å¡çš„ä»»åŠ¡
   listenersBound: false, // æ–°å¢ï¼šé˜²æ­¢äº‹ä»¶ç›‘å¬å™¨é‡å¤ç»‘å®šçš„æ ‡å¿—
          isSegmentedMemoryAutoOn: false, // æ–°å¢ï¼šåˆ†æ®µè®°å¿†è‡ªåŠ¨ç”Ÿæˆå¼€å…³
          segmentedMemoryPollTimer: null, // æ–°å¢ï¼šåˆ†æ®µè®°å¿†è½®è¯¢å®šæ—¶å™¨ID
          isSmallSummaryAutoOn: false, // æ–°å¢ï¼šå°æ€»ç»“è‡ªåŠ¨ç”Ÿæˆå¼€å…³
          smallSummaryPollTimer: null, // æ–°å¢ï¼šå°æ€»ç»“è½®è¯¢å®šæ—¶å™¨ID
          isLargeSummaryAutoOn: false, // æ–°å¢ï¼šå¤§æ€»ç»“è‡ªåŠ¨ç”Ÿæˆå¼€å…³
          largeSummaryPollTimer: null, // æ–°å¢ï¼šå¤§æ€»ç»“è½®è¯¢å®šæ—¶å™¨ID
          // æ–°å¢ï¼šè·Ÿè¸ªæ˜¯å¦ä»è®¾ç½®ç•Œé¢è¿›å…¥å­çª—å£
          isFromSettingsModal: false,
          worldEventsViewMode: 'timeline', // æ–°å¢ï¼šä¸–ç•Œå¤§äº‹è§†å›¾æ¨¡å¼,

          // æ–°å¢ï¼šä¸»ç•Œé¢é€æ˜åº¦è®¾ç½®
          mainOpacity: 100, // é»˜è®¤100%ä¸é€æ˜
          intimateCharacters: new Set(), // æ–°å¢ï¼šç”¨äºå­˜å‚¨äº²å¯†è§’è‰²çš„Set
          
          // æ–°å¢ï¼šé¢æ¿æŠ˜å çŠ¶æ€
          leftPanelCollapsed: false,

          // --- IndexedDB æ•°æ®åº“å®ä¾‹ç¼“å­˜ ---
          db: null,
          dbPromise: null,
          rightPanelCollapsed: false,
          
          // è¿½è¸ªå·²è£…å¤‡ç‰©å“çš„çŠ¶æ€
          // **é€»è¾‘ä¿®æ­£**: equippedItems ç°åœ¨å­˜å‚¨å®Œæ•´çš„ç‰©å“å¯¹è±¡ï¼Œè€Œä¸ä»…ä»…æ˜¯ID
          equippedItems: {
            wuqi: null,
            fangju: null,
            shipin: null,
            fabao1: null,
            zhuxiuGongfa: null,
            fuxiuXinfa: null,
          },
          currentMvuState: null, // æ–°å¢ï¼šç”¨äºç¼“å­˜å½“å‰æœ€æ–°çš„mvuçŠ¶æ€
          pendingActions: [], // è´­ç‰©è½¦/æŒ‡ä»¤é˜Ÿåˆ—
          guixuStoreItems: [], // å½’å¢Ÿç©ºé—´å•†å“ç¼“å­˜
          baseAttributes: {}, // å­˜å‚¨ä»mvuåŠ è½½çš„åŸå§‹å±æ€§
          calculatedMaxAttributes: {}, // æ–°å¢ï¼šç”¨äºç¼“å­˜è®¡ç®—åçš„å±æ€§ä¸Šé™
          lastExtractedJourney: null,
          lastExtractedPastLives: null,
          lastExtractedNovelText: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„åŸå§‹æ­£æ–‡
          lastExtractedCharacterCard: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„è§’è‰²å¡
          lastExtractedMapCommands: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„åœ°å›¾æŒ‡ä»¤
          lastExtractedThinking: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨æå–çš„æ€ç»´è¿‡ç¨‹
          lastExtractedVariables: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨å˜é‡æ”¹å˜
          lastSentPrompt: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨å‘é€ç»™AIçš„å®Œæ•´æç¤º
          isNovelModeEnabled: false, // æ–°å¢ï¼šå°è¯´æ¨¡å¼å¼€å…³çŠ¶æ€
          isAutoWriteEnabled: true, // é»˜è®¤å¼€å¯è‡ªåŠ¨å†™å…¥
          autoWriteIntervalId: null, // ç”¨äºå­˜å‚¨è½®è¯¢è®¡æ—¶å™¨ID
          
          // æ–°å¢ï¼šä¸–ç•Œä¹¦é¢„è®¾ç®¡ç†çŠ¶æ€
          worldbookPresets: {}, // å­˜å‚¨æ‰€æœ‰é¢„è®¾
          currentEditingPreset: null, // å½“å‰æ­£åœ¨ç¼–è¾‘çš„é¢„è®¾
          presetManagerState: {
            selectedPresetId: null,
            isEditing: false
          },
          isFromWorldbookManager: false, // æ–°å¢ï¼šè·Ÿè¸ªæ˜¯å¦ä»ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢è¿›å…¥é¢„è®¾ç®¡ç†
          novelModeAutoWriteIntervalId: null, // æ–°å¢ï¼šå°è¯´æ¨¡å¼çš„è‡ªåŠ¨å†™å…¥è½®è¯¢ID
          isMobileView: false, // æ–°å¢ï¼šè¿½è¸ªç§»åŠ¨è§†å›¾çŠ¶æ€
          isCharacterPanelVisible: false, // æ–°å¢ï¼šè¿½è¸ªè§’è‰²é¢æ¿çš„æ˜¾ç¤ºçŠ¶æ€
          relationshipSortType: 'default', // æ–°å¢: äººç‰©å…³ç³»æ’åºç±»å‹
          isInteractionPanelVisible: false, // æ–°å¢ï¼šè¿½è¸ªäº¤äº’é¢æ¿çš„æ˜¾ç¤ºçŠ¶æ€
          unifiedIndex: 1, // æ–°å¢ï¼šç»Ÿä¸€çš„è¯»å†™åºå·
          novelModeIndex: 1, // ä¿ç•™ï¼šç”¨äºå‘åå…¼å®¹ï¼Œä½†å°è¯´æ¨¡å¼ç°åœ¨ä½¿ç”¨unifiedIndex
          isAutoToggleLorebookEnabled: false, // æ–°å¢ï¼šè‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦çŠ¶æ€
          autoToggleIntervalId: null, // æ–°å¢ï¼šè½®è¯¢è®¡æ—¶å™¨ID
          isAutoSaveEnabled: false, // æ–°å¢ï¼šè‡ªåŠ¨å­˜æ¡£å¼€å…³çŠ¶æ€
          isActionOptionsEnabled: true, // æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹å¼€å…³çŠ¶æ€
          isActionAutoSend: true, // æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€å¼€å…³çŠ¶æ€
          mapUpdateIntervalId: null, // æ–°å¢: åœ°å›¾è‡ªåŠ¨æ›´æ–°è½®è¯¢ID
          isAutoTrimEnabled: false, // æ–°å¢ï¼šè‡ªåŠ¨ä¿®å‰ªå¼€å…³çŠ¶æ€
          isStreamingGametxt: false, // æ–°å¢ï¼šè·Ÿè¸ª<gametxt>æµå¼çŠ¶æ€
          isStreamingEnabled: true, // æ–°å¢ï¼šæµå¼å¼€å…³çŠ¶æ€
          isFormatValidationEnabled: true, // æ–°å¢ï¼šæ ¼å¼å®¡æŸ¥å¼€å…³çŠ¶æ€
          isEnterSendEnabled: false, // æ–°å¢ï¼šå›è½¦å‘é€å¼€å…³çŠ¶æ€
          isKeyboardShortcutsEnabled: true, // æ–°å¢ï¼šé”®ç›˜å¿«æ·é”®å¼€å…³çŠ¶æ€
          isMobileInputAdaptEnabled: false, // æ–°å¢ï¼šæ‰‹æœºè¾“å…¥æ¡†é€‚é…å¼€å…³çŠ¶æ€
          lastValidGametxtHTML: '', // æ–°å¢ï¼šç”¨äºå¤‡ä»½ä¸Šä¸€æ¬¡æœ‰æ•ˆçš„æ­£æ–‡HTML
          intimateCharacters: [], // æ–°å¢ï¼šäº²å¯†å…³ç³»è§’è‰²IDåˆ—è¡¨
          floatingInputContainer: null, // æ–°å¢ï¼šæµ®åŠ¨è¾“å…¥æ¡†å®¹å™¨
          
          // --- æ–°å¢ï¼šæ–‡å­—è®¾ç½®çŠ¶æ€ ---
          textSettings: {
            colors: {
              normal: '#e8dcc6',        // æ­£æ–‡é¢œè‰²
              dialogue: '#ff1493',      // å¯¹è¯é¢œè‰²
              psychology: '#808080',    // å¿ƒç†æ´»åŠ¨é¢œè‰²ï¼šç°è‰²
              scenery: '#98fb98'       // æ™¯ç‰©æå†™é¢œè‰²
            },
            fontSize: 14,              // å…¨å±€å­—ä½“å¤§å°
            fontSizes: {               // å•ç‹¬å­—ä½“å¤§å°è®¾ç½®
              normal: 14,             // æ­£æ–‡å­—ä½“å¤§å°
              dialogue: 14,           // å¯¹è¯å­—ä½“å¤§å°
              psychology: 13,         // å¿ƒç†æ´»åŠ¨å­—ä½“å¤§å°
              scenery: 15             // æ™¯ç‰©æå†™å­—ä½“å¤§å°
            },
            fontFamily: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif", // å­—ä½“æ—
            customFonts: []            // ç”¨æˆ·ä¸Šä¼ çš„è‡ªå®šä¹‰å­—ä½“
          },
          
          // --- æ–°å¢ï¼šèƒŒæ™¯å›¾ç®¡ç†çŠ¶æ€ ---
          backgroundImages: [], // å­˜å‚¨ç”¨æˆ·ä¸Šä¼ çš„èƒŒæ™¯å›¾
          backgroundMode: 'random', // 'random' æˆ– 'fixed'
          selectedBackgroundId: null, // å›ºå®šæ¨¡å¼ä¸‹é€‰ä¸­çš„èƒŒæ™¯å›¾ID
          // --- æ–°å¢ï¼šåœ°å›¾ç¼©æ”¾/å¹³ç§»çŠ¶æ€ ---
          mapState: {
               scale: 1,
               panX: 0,
               panY: 0,
               isPanning: false,
               startX: 0,
               startY: 0,
               animationFrameId: null, // ç”¨äºä¼˜åŒ–æ‹–åŠ¨æ€§èƒ½
               playerMapPos: null, // æ–°å¢ï¼šç”¨äºå­˜å‚¨ç©å®¶åœ¨åœ°å›¾ä¸Šçš„åƒç´ åæ ‡
           },
          // --- æ–°å¢ï¼šå¤„ç†æ‰€æœ‰åŠ¨ä½œçš„æ ¸å¿ƒå‡½æ•° ---
          waitingMessages: [
            'å‘œå‘œå‘œå‘œä¼Ÿå¤§çš„æ¢¦æ˜Ÿå¤§äººå•Šï¼Œè¯·ç»™ä½ è™”è¯šçš„ä¿¡å¾’{{user}}å›å¤å§......',
            'æ¢¦æ˜Ÿå¤§äººï¼Œæˆ‘ä»¬æ•¬çˆ±ä½ å£ç‰™ï¼ï¼è¯·ç»™æˆ‘å›å¤å§ï¼ï¼',
            'æ¢¦æ˜Ÿå¤§äººæ­£åœ¨å›åº”ä½ çš„è¯·æ±‚ï¼Œä¸ƒä¸ªå·¥ä½œæ—¥ç»™ä½ å›å¤',
            'æ­£åœ¨å‘ä¼Ÿå¤§æ¢¦æ˜Ÿç¥ˆç¥·......å‘œå‘œå‘œä½ å¿«ä¸€ç‚¹å¥½ä¸å¥½'
          ],

          showWaitingMessage() {
            this.hideWaitingMessage(); // Ensure only one is visible
            const message = this.waitingMessages[Math.floor(Math.random() * this.waitingMessages.length)];
            const msgElement = document.createElement('div');
            msgElement.id = 'waiting-popup';
            msgElement.className = 'waiting-popup';
            // æ›´æ–°HTMLç»“æ„ä»¥åŒ…å«spinner
            msgElement.innerHTML = `
              <div class="waiting-spinner"></div>
              <span>${message}</span>
            `;
            const container = document.querySelector('.guixu-root-container');
            if (container) {
                container.appendChild(msgElement);
            }
          },

          hideWaitingMessage() {
              const existingMsg = document.getElementById('waiting-popup');
              if (existingMsg) {
                  existingMsg.remove();
              }
          },

          updateWaitingMessage(text) {
             const popup = document.getElementById('waiting-popup');
             if (popup) {
                 const span = popup.querySelector('span');
                 if (span) {
                     span.textContent = text;
                 }
             }
          },

          // --- æ–°å¢ï¼šè§†å›¾åˆ‡æ¢æ ¸å¿ƒåŠŸèƒ½ ---
          toggleViewMode() {
            this.isMobileView = !this.isMobileView;
            const container = document.querySelector('.guixu-root-container');
            const btn = document.getElementById('view-toggle-btn');
            if (container && btn) {
              if (this.isMobileView) {
                container.classList.add('mobile-view');
                btn.textContent = 'ğŸ’»'; // åˆ‡æ¢åˆ°æ¡Œé¢å›¾æ ‡
                btn.title = 'åˆ‡æ¢åˆ°æ¡Œé¢è§†å›¾';
              } else {
                container.classList.remove('mobile-view');
                btn.textContent = 'ğŸ“±'; // åˆ‡æ¢åˆ°æ‰‹æœºå›¾æ ‡
                btn.title = 'åˆ‡æ¢åˆ°ç§»åŠ¨è§†å›¾';
              }
            }
            this.saveViewMode();
          },

          saveViewMode() {
            try {
              localStorage.setItem('guixu_view_mode', this.isMobileView ? 'mobile' : 'desktop');
            } catch (e) {
              console.error('ä¿å­˜è§†å›¾æ¨¡å¼å¤±è´¥:', e);
            }
          },

          loadViewMode() {
            try {
              const savedMode = localStorage.getItem('guixu_view_mode');
              // ä»…å½“ä¿å­˜çš„æ¨¡å¼ä¸º 'mobile' æ—¶ï¼Œæ‰åœ¨åŠ è½½æ—¶åˆ‡æ¢åˆ°ç§»åŠ¨è§†å›¾
              if (savedMode === 'mobile') {
                this.isMobileView = true; // è®¾ç½®åˆå§‹çŠ¶æ€
                const container = document.querySelector('.guixu-root-container');
                const btn = document.getElementById('view-toggle-btn');
                if (container && btn) {
                  container.classList.add('mobile-view');
                  btn.textContent = 'ğŸ’»';
                  btn.title = 'åˆ‡æ¢åˆ°æ¡Œé¢è§†å›¾';
                }
              } else {
                this.isMobileView = false; // ç¡®ä¿é»˜è®¤æ˜¯æ¡Œé¢è§†å›¾
              }
            } catch (e) {
              console.error('åŠ è½½è§†å›¾æ¨¡å¼å¤±è´¥:', e);
            }
          },

          formatMessageContent(text) {
            if (!text) return '';

            // é¢„å¤„ç†ï¼šä»…å¤„ç†ç« èŠ‚æ ‡é¢˜å’Œæ¢è¡Œ
            let processedText = text.replace(/\\n/g, '<br />');
            processedText = processedText.replace(/(^\s*ç¬¬.*?ç« .*$)/gm, (match) => `<h3 class="novel-chapter-title">${match}</h3>`);

            // --- æœ€ç»ˆæ–¹æ¡ˆï¼šåŸºäºASTçš„è§£æå™¨ ---
            const parseAndStyle = (str) => {
                // 1. åˆ†è¯ (Tokenization)
                // å°†å­—ç¬¦ä¸²åˆ†è§£ä¸ºæ ‡è®°ç¬¦å·å’Œçº¯æ–‡æœ¬å—
                const tokens = str.match(/(\*\*|\*|ã€ã€|ã€‘ã€‘|ã€|ã€‘|ã€Š|ã€‹|ã€Œ|ã€|ã€|ã€|â€œ|â€|"[^"]*"|'[^']*')|([^ã€ã€‘\*ã€Šã€‹ã€Œã€ã€ã€â€œâ€'"]+)/g) || [];

                // 2. å®šä¹‰è§„åˆ™
                const tokenRules = {
                    '**': { type: 'psychology', symmetric: true },
                    '*': { type: 'psychology', symmetric: true },
                    'ã€ã€': { type: 'scenery', open: 'ã€ã€', close: 'ã€‘ã€‘' },
                    'ã€‘ã€‘': { type: 'scenery', open: 'ã€ã€', close: 'ã€‘ã€‘' },
                    'ã€': { type: 'scenery', open: 'ã€', close: 'ã€‘' },
                    'ã€‘': { type: 'scenery', open: 'ã€', close: 'ã€‘' },
                    'ã€Š': { type: 'language', open: 'ã€Š', close: 'ã€‹' },
                    'ã€‹': { type: 'language', open: 'ã€Š', close: 'ã€‹' },
                    'ã€Œ': { type: 'language', open: 'ã€Œ', close: 'ã€' },
                    'ã€': { type: 'language', open: 'ã€Œ', close: 'ã€' },
                    'ã€': { type: 'language', open: 'ã€', close: 'ã€' },
                    'ã€': { type: 'language', open: 'ã€', close: 'ã€' },
                    'â€œ': { type: 'language', open: 'â€œ', close: 'â€' },
                    'â€': { type: 'language', open: 'â€œ', close: 'â€' },
                    '"': { type: 'language', symmetric: true },
                    "'": { type: 'language', symmetric: true }
                };
                const classMap = { psychology: 'text-psychology', scenery: 'text-scenery', language: 'text-language' };

                // 3. è§£æ (Parsing) -> æ„å»ºæŠ½è±¡è¯­æ³•æ ‘ (AST)
                let root = { type: 'root', children: [] };
                let stack = [root]; // èŠ‚ç‚¹æ ˆ

                for (const token of tokens) {
                    const rule = tokenRules[token];
                    let currentNode = stack[stack.length - 1];

                    if (rule) {
                        if (rule.symmetric) {
                            if (currentNode.type === rule.type && currentNode.token === token) {
                                stack.pop(); // é—­åˆå¯¹ç§°æ ‡ç­¾
                            } else {
                                const newNode = { type: rule.type, token: token, children: [] };
                                currentNode.children.push(newNode);
                                stack.push(newNode); // å¼€å¯å¯¹ç§°æ ‡ç­¾
                            }
                        } else if (token === rule.open) { // å¼€å¯éå¯¹ç§°æ ‡ç­¾
                            const newNode = { type: rule.type, children: [] };
                            currentNode.children.push(newNode);
                            stack.push(newNode);
                        } else if (token === rule.close) { // é—­åˆéå¯¹ç§°æ ‡ç­¾
                            if (currentNode.type === rule.type) {
                                stack.pop();
                            } else { // å®¹é”™ï¼šå¦‚æœæ ‡ç­¾ä¸åŒ¹é…ï¼Œåˆ™ä½œä¸ºçº¯æ–‡æœ¬å¤„ç†
                                currentNode.children.push(token);
                            }
                        }
                    } else { // çº¯æ–‡æœ¬
                        currentNode.children.push(token);
                    }
                }

                // 4. ä»£ç ç”Ÿæˆ (Code Generation)
                const generateHTML = (node) => {
                    if (typeof node === 'string') {
                        // åœ¨æœ€ç»ˆç”Ÿæˆæ—¶æ‰è¿›è¡ŒHTMLå®ä½“è½¬ä¹‰
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(generateHTML).join('');
                    if (node.type === 'root') {
                        return childrenHTML;
                    }
                    // åœ¨è¿™é‡Œï¼Œæˆ‘ä»¬å°†æ ‡è®°ç¬¦å·æœ¬èº«ä¹ŸåŒ…å«åœ¨spanå†…éƒ¨ï¼Œä»¥å®ç°å¯¹ç¬¦å·çš„æŸ“è‰²
                    const openToken = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].open === k) || '';
                    const closeToken = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].close === k) || '';
                    
                    return `<span class="${classMap[node.type]}">${openToken}${childrenHTML}${closeToken}</span>`;
                };
                
                // ä¿®æ­£ï¼šåœ¨ç”ŸæˆHTMLæ—¶ï¼Œæˆ‘ä»¬åº”è¯¥åªåŒ…è£¹å†…å®¹ï¼Œè€Œä¸æ˜¯å†æ¬¡æ·»åŠ æ ‡è®°
                const generateCorrectHTML = (node) => {
                     if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(generateCorrectHTML).join('');
                    if (node.type === 'root') {
                        return childrenHTML;
                    }
                    // åªåŒ…è£¹å†…å®¹
                    return `<span class="${classMap[node.type]}">${childrenHTML}</span>`;
                }

                // æˆ‘ä»¬éœ€è¦ä¿®æ”¹è§£æé€»è¾‘ï¼Œå°†æ ‡è®°ç¬¦å·ä½œä¸ºASTçš„ä¸€éƒ¨åˆ†
                // ... è®©æˆ‘ä»¬ç®€åŒ–ä¸€ä¸‹ï¼Œç›´æ¥åœ¨ç”Ÿæˆæ—¶æ·»åŠ å®ƒä»¬

                const generateFinalHTML = (node, parent) => {
                    if (typeof node === 'string') {
                         return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHTML = node.children.map(child => generateFinalHTML(child, node)).join('');
                    if (node.type === 'root') return childrenHTML;

                    const open = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].open) || '';
                    const close = node.token || Object.keys(tokenRules).find(k => tokenRules[k].type === node.type && tokenRules[k].close) || '';

                    return `<span class="${classMap[node.type]}">${open}${childrenHTML}${close}</span>`;
                };
                
                // æœ€ç»ˆç‰ˆç”Ÿæˆå™¨
                const finalGenerator = (node) => {
                    if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    
                    const childrenHtml = node.children.map(finalGenerator).join('');
                    
                    if (node.type === 'root') {
                        return childrenHtml;
                    }
                    
                    return `<span class="${classMap[node.type]}">${childrenHtml}</span>`;
                };

                // é‡æ–°æ€è€ƒè§£æé€»è¾‘ï¼Œå°†æ ‡è®°ä¹Ÿä½œä¸ºèŠ‚ç‚¹
                let new_root = { type: 'root', children: [] };
                let new_stack = [new_root];

                for (const token of tokens) {
                    const rule = tokenRules[token];
                    let currentNode = new_stack[new_stack.length - 1];

                    if (rule) {
                        if (rule.symmetric) {
                            if (currentNode.type === rule.type && currentNode.token === token) {
                                new_stack.pop();
                            } else {
                                const newNode = { type: rule.type, token: token, children: [] };
                                currentNode.children.push(newNode);
                                new_stack.push(newNode);
                            }
                        } else if (rule.open === token) {
                            const newNode = { type: rule.type, open: token, close: rule.close, children: [] };
                            currentNode.children.push(newNode);
                            new_stack.push(newNode);
                        } else if (rule.close === token) {
                            if (currentNode.type === rule.type && currentNode.close === token) {
                                new_stack.pop();
                            } else {
                                currentNode.children.push(token); // Mismatch, treat as text
                            }
                        }
                    } else {
                        currentNode.children.push(token);
                    }
                }
                
                const finalHtmlGenerator = (node) => {
                    if (typeof node === 'string') {
                        return node.replace(/&/g, '&').replace(/</g, '<').replace(/>/g, '>');
                    }
                    const childrenHtml = node.children.map(finalHtmlGenerator).join('');
                    if (node.type === 'root') {
                        return childrenHtml;
                    }

                    // æ ¹æ®ç±»å‹å†³å®šæ˜¯å¦ä¿ç•™æ ‡è®°ç¬¦å·
                    if (node.type === 'language') {
                        // å¯¹è¯ç±»å‹ï¼Œä¿ç•™ç¬¦å·
                        return `<span class="${classMap[node.type]}">${node.open || node.token || ''}${childrenHtml}${node.close || node.token || ''}</span>`;
                    } else {
                        // æ™¯ç‰©å’Œå¿ƒç†ç±»å‹ï¼Œç§»é™¤ç¬¦å·
                        return `<span class="${classMap[node.type]}">${childrenHtml}</span>`;
                    }
                };

                return finalHtmlGenerator(new_root);
            };

            return parseAndStyle(processedText);
          },

          // --- æ–°å¢ï¼šå®æ—¶æ›´æ–°æ­£æ–‡å­—æ•° ---
          updateLiveWordCount() {
            const gameTextDisplay = document.getElementById('game-text-display');
            const wordCountEl = document.getElementById('game-text-word-count');
            if (gameTextDisplay && wordCountEl) {
              // ä½¿ç”¨ textContent æ¥è·å–çº¯æ–‡æœ¬ï¼Œè‡ªåŠ¨å¿½ç•¥HTMLæ ‡ç­¾
              const wordCount = gameTextDisplay.textContent ? gameTextDisplay.textContent.trim().length : 0;
              wordCountEl.textContent = `æ­£æ–‡ï¼š${wordCount}å­—`;
            }
          },

          async init() {
            if (this.isInitialized) {
              console.log('[å½’å¢Ÿ] GuixuManager å·²åˆå§‹åŒ–ï¼Œè·³è¿‡é‡å¤æ“ä½œã€‚');
              return;
            }
            console.log('[å½’å¢Ÿ] æ­£åœ¨åˆå§‹åŒ– GuixuManager...');
            this.isInitialized = true;

            // --- æ–°å¢ï¼šåŠ¨æ€æ³¨å…¥å½’å¢Ÿç©ºé—´å®šåˆ¶åŒ–CSS ---
            const customStyles = `
                /* å½’å¢Ÿç©ºé—´ç¡®è®¤æ¡†å®šåˆ¶æ ·å¼ */
                #custom-confirm-modal.guixu-confirm-modal .modal-content {
                    background: var(--bg-secondary, rgba(15, 15, 35, 0.85));
                    border: 1px solid var(--border-color, #444);
                    border-radius: 8px;
                    box-shadow: var(--shadow-glow, 0 0 12px rgba(201, 170, 113, 0.3)), var(--shadow-elevation-medium, 0 4px 6px rgba(0, 0, 0, 0.2));
                    width: 400px !important; /* è°ƒæ•´å®½åº¦å¹¶å¼ºåˆ¶è¦†ç›– */
                    max-width: 80vw;
                    height: auto;
                    min-height: 180px; /* è°ƒæ•´æœ€å°é«˜åº¦ */
                    padding: 24px;
                    display: flex;
                    flex-direction: column;
                    justify-content: center; /* å‚ç›´å±…ä¸­ */
                    align-items: center; /* æ°´å¹³å±…ä¸­ */
                    gap: 20px; /* å…ƒç´ é—´è· */
                }
                #custom-confirm-modal.guixu-confirm-modal .modal-header {
                    padding: 0;
                    border-bottom: none;
                    position: absolute; /* å°†å…³é—­æŒ‰é’®å®šä½åˆ°å³ä¸Šè§’ */
                    top: 10px;
                    right: 10px;
                }
                #custom-confirm-modal.guixu-confirm-modal .modal-title {
                    display: none; /* éšè—é»˜è®¤æ ‡é¢˜ */
                }
                #custom-confirm-modal.guixu-confirm-modal .confirm-modal-message {
                    color: var(--text-primary, #e0e0e0);
                    font-size: 16px;
                    text-align: center;
                    line-height: 1.6;
                }
                #custom-confirm-modal.guixu-confirm-modal .confirm-modal-buttons {
                    display: flex;
                    gap: 15px;
                    padding: 0;
                }
                #custom-confirm-modal.guixu-confirm-modal .interaction-btn {
                    min-width: 100px;
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-ok {
                    background-color: var(--primary-gold, #c9aa71);
                    color: var(--text-on-primary, #1a1a1a);
                    border: none;
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-ok:hover {
                    background-color: var(--secondary-gold, #daa520);
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-cancel {
                    background-color: transparent;
                    border: 1px solid var(--border-color-light, #666);
                    color: var(--text-secondary, #b0b0b0);
                }
                #custom-confirm-modal.guixu-confirm-modal #custom-confirm-btn-cancel:hover {
                    background-color: var(--bg-hover, rgba(255, 255, 255, 0.1));
                    border-color: var(--border-color-hover, #888);
                }
            `;
            const styleElement = document.createElement('style');
            styleElement.textContent = customStyles;
            document.head.appendChild(styleElement);

            console.log('å½’å¢ŸUIäº¤äº’ç®¡ç†å™¨åˆå§‹åŒ–...');
            this.bindStaticListeners();
            this.loadWindowSizeState(); // åŠ è½½çª—å£å¤§å°çŠ¶æ€
            this.loadModalSizeState(); // åŠ è½½æ¨¡æ€æ¡†å¤§å°çŠ¶æ€
            this.initBackgroundSystem(); // åˆå§‹åŒ–èƒŒæ™¯å›¾ç³»ç»Ÿ
            this.loadWorldbookPresets(); // åŠ è½½ä¸–ç•Œä¹¦é¢„è®¾
            await this.updateDynamicData(); // Initial data load
            this.loadAutoWriteState(); // åŠ è½½è‡ªåŠ¨å†™å…¥çŠ¶æ€
            this.loadNovelModeState(); // åŠ è½½å°è¯´æ¨¡å¼çŠ¶æ€
            this.loadEquipmentState(); // åŠ è½½å·²è£…å¤‡ç‰©å“çŠ¶æ€
            this.loadPendingActions(); // åŠ è½½å¾…å¤„ç†æŒ‡ä»¤
            this.loadViewMode(); // æ–°å¢ï¼šåŠ è½½ç”¨æˆ·ä¿å­˜çš„è§†å›¾æ¨¡å¼
            this.loadUnifiedIndex(); // æ–°å¢ï¼šåŠ è½½ç»Ÿä¸€çš„è¯»å†™åºå·
            // ç§»é™¤ï¼šthis.loadNovelModeIndex(); // å°è¯´æ¨¡å¼ç°åœ¨ä½¿ç”¨ç»Ÿä¸€åºå·
            this.loadAutoToggleState(); // æ–°å¢ï¼šåŠ è½½è‡ªåŠ¨å¼€å…³çŠ¶æ€
            this.loadWorldbookSettings(); // æ–°å¢ï¼šåŠ è½½ä¸–ç•Œä¹¦é«˜çº§è®¾ç½®
            this.loadAutoSaveState(); // æ–°å¢ï¼šåŠ è½½è‡ªåŠ¨å­˜æ¡£çŠ¶æ€
            this.loadSegmentedMemoryState(); // åŠ è½½ç»Ÿä¸€çš„å¼€å…³çŠ¶æ€
            this.loadSegmentedMemoryCounts(); // æ–°å¢ï¼šåŠ è½½åˆ†æ®µè®°å¿†ä¿ç•™æ•°
            // å°æ€»ç»“å’Œå¤§æ€»ç»“çš„çŠ¶æ€å°†ç”±ä¸»å¼€å…³æ§åˆ¶ï¼Œä½†ä»éœ€åŠ è½½ä»¥ç¡®ä¿æ—§è®¾ç½®çš„å…¼å®¹æ€§
            this.loadSmallSummaryState();
            this.loadLargeSummaryState();
            this.loadActionOptionsState(); // æ–°å¢ï¼šåŠ è½½è¡ŒåŠ¨é€‰é¡¹å¼€å…³çŠ¶æ€
            this.loadActionAutoSendState(); // æ–°å¢ï¼šåŠ è½½è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€
            this.startMapUpdatePolling(); // æ–°å¢: å¯åŠ¨åœ°å›¾è½®è¯¢
            this.loadAutoTrimState(); // æ–°å¢ï¼šåŠ è½½è‡ªåŠ¨ä¿®å‰ªçŠ¶æ€
            this.loadPanelStates(); // æ–°å¢ï¼šåŠ è½½é¢æ¿æŠ˜å çŠ¶æ€
            this.loadStreamingState(); // æ–°å¢ï¼šåŠ è½½æµå¼å¼€å…³çŠ¶æ€
            this.loadFormatValidationState(); // æ–°å¢ï¼šåŠ è½½æ ¼å¼å®¡æŸ¥çŠ¶æ€
            this.loadEnterSendState(); // æ–°å¢ï¼šåŠ è½½å›è½¦å‘é€çŠ¶æ€
            this.loadKeyboardShortcutsState(); // æ–°å¢ï¼šåŠ è½½é”®ç›˜å¿«æ·é”®çŠ¶æ€
            this.loadMobileInputAdaptState(); // æ–°å¢ï¼šåŠ è½½æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€
            this.loadIntimateList(); // æ–°å¢ï¼šåŠ è½½äº²å¯†å…³ç³»åˆ—è¡¨
            this.loadRelationshipSettings(); // æ–°å¢ï¼šåŠ è½½äººç‰©å…³ç³»è®¾ç½®
            this.loadLastThinking(); // æ–°å¢ï¼šåŠ è½½ä¸Šæ¬¡çš„æ€ç»´è¿‡ç¨‹
            this.loadTrimFieldsState(); // æ–°å¢ï¼šåŠ è½½ä¿®å‰ªå­—æ®µçŠ¶æ€
            this.loadTextSettings(); // æ–°å¢ï¼šåŠ è½½æ–‡å­—è®¾ç½®
   
            this.loadGachaState(); // æ–°å¢ï¼šåŠ è½½Gachaæ•°æ®
  
            this.loadGachaCheatState(); // æ–°å¢ï¼šåŠ è½½Gachaä½œå¼Šæ¨¡å¼çŠ¶æ€
          await this.loadCharacterPoolFromLorebook(); // æ–°å¢ï¼šåŠ è½½å¡æ± 
         this.updateThinkingButtonVisibility(); // æ–°å¢ï¼šæ ¹æ®åŠ è½½çš„æ•°æ®æ›´æ–°æŒ‰é’®
            
            // åœ¨æ‰€æœ‰çŠ¶æ€åŠ è½½å®Œæˆåï¼Œåˆå§‹åŒ–é”®ç›˜å¤„ç†
            setTimeout(() => {
                this.setupInputKeyboardHandling();
                console.log('[å½’å¢Ÿè¾“å…¥æ³•] å»¶è¿Ÿåˆå§‹åŒ–å®Œæˆï¼Œå½“å‰é€‚é…å¼€å…³çŠ¶æ€:', this.isMobileInputAdaptEnabled);
            }, 100);

               // å·²ç§»é™¤ MESSAGE_SWIPED äº‹ä»¶ç›‘å¬å™¨ï¼Œä»¥é¿å…ä¸æ ¸å¿ƒmvuè„šæœ¬å†²çªã€‚
            // UIåˆ·æ–°ç°åœ¨é€šè¿‡ handleAction å†…éƒ¨çš„ä¸»åŠ¨è°ƒç”¨æ¥å®Œæˆã€‚
           eventOn(iframe_events.STREAM_TOKEN_RECEIVED_FULLY, (text) => this.handleStreamUpdate(text));
           eventOn(iframe_events.GENERATION_ENDED, (text) => this.handleStreamEnd(text));
          },

          // --- æ–°å¢ï¼šæµå¼å¤„ç†å‡½æ•° ---
          handleStreamUpdate(text) {
            if (!this.isStreamingGametxt && text.includes('<gametxt>')) {
                this.isStreamingGametxt = true;
                this.updateWaitingMessage('æ¢¦æ˜Ÿå¤§äººæ­£åœ¨ç»™ä½ æµå¼ç”Ÿæˆæ­£æ–‡ï¼Œèµç¾æ¢¦æ˜Ÿå¤§äººï¼ï¼ï¼');
                // éšè—å˜é‡æ”¹å˜æé†’ï¼ˆå¤ç”¨è¡ŒåŠ¨é€‰é¡¹çš„é€»è¾‘ï¼‰
                this.hideVariableChangesReminder();
            }
            const gameTextDisplay = document.getElementById('game-text-display');
            if (gameTextDisplay) {
              const displayText = this._getDisplayText(text);
              gameTextDisplay.innerHTML = this.formatMessageContent(displayText);
              this.updateLiveWordCount(); // ä¿®å¤ï¼šè°ƒç”¨ç»Ÿä¸€çš„å­—æ•°ç»Ÿè®¡å‡½æ•°
            }
          },

          // --- æ–°å¢ï¼šå®Œå–„çš„æ ¼å¼éªŒè¯å‡½æ•° ---
          validateResponseFormat(text) {
            // å®šä¹‰æ ‡ç­¾æ£€æŸ¥é…ç½®
            const tagConfig = {
              // å¿…éœ€æ ‡ç­¾ï¼šå¿…é¡»å­˜åœ¨ä¸”æ­£ç¡®é—­åˆ
              required: ['gametxt', 'æœ¬ä¸–å†ç¨‹'],
              // å¯é€‰æ ‡ç­¾ï¼šå¦‚æœå­˜åœ¨åˆ™å¿…é¡»æ­£ç¡®é—­åˆ
              optional: ['UpdateVariable', 'thinking', 'action']
            };
            
            const errors = [];

            // æ™ºèƒ½è¿‡æ»¤æ‰<thinking>...</thinking>æ ‡ç­¾å†…å®¹ï¼Œé¿å…å…¶ä¸­çš„å†…å®¹å¹²æ‰°æ ¼å¼éªŒè¯
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            let cleanedText = text.replace(thinkingRegex, '');
            
            
            // æ£€æŸ¥æ‰€æœ‰æ ‡ç­¾ï¼ˆå¿…éœ€ + å¯é€‰ï¼‰
            const allTags = [...tagConfig.required, ...tagConfig.optional];
            
            for (const tag of allTags) {
              const openTagCount = (cleanedText.match(new RegExp(`<${tag}>`, 'gi')) || []).length;
              const closeTagCount = (cleanedText.match(new RegExp(`</${tag}>`, 'gi')) || []).length;
              const isRequired = tagConfig.required.includes(tag);
              
              console.log(`[æ ¼å¼éªŒè¯] æ ‡ç­¾ ${tag} (${isRequired ? 'å¿…éœ€' : 'å¯é€‰'}): å¼€å§‹=${openTagCount}, ç»“æŸ=${closeTagCount}`);
              
              // 1. æ£€æŸ¥å¿…éœ€æ ‡ç­¾æ˜¯å¦å®Œå…¨ç¼ºå¤±
              if (isRequired && openTagCount === 0 && closeTagCount === 0) {
                const errorMsg = `&lt;${tag}&gt;æ²¡æœ‰`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'missing',
                  message: errorMsg
                });
              }
              // 2. æ£€æŸ¥æ ‡ç­¾é—­åˆæƒ…å†µï¼ˆå¯¹æ‰€æœ‰å­˜åœ¨çš„æ ‡ç­¾ï¼‰
              else if (openTagCount > 0 && closeTagCount === 0) {
                const errorMsg = `&lt;${tag}&gt;æ ‡ç­¾æ²¡é—­åˆ`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'unclosed',
                  message: errorMsg
                });
              }
              // 3. æ£€æŸ¥åªæœ‰ç»“æŸæ ‡ç­¾çš„æƒ…å†µ
              else if (openTagCount === 0 && closeTagCount > 0) {
                const errorMsg = `&lt;${tag}&gt;æ ‡ç­¾ç¼ºå¤±å¼€å§‹æ ‡ç­¾`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'incomplete',
                  message: errorMsg
                });
              }
              // 4. æ£€æŸ¥æ ‡ç­¾æ•°é‡ä¸åŒ¹é…çš„æƒ…å†µ
              else if (openTagCount > 0 && closeTagCount > 0 && openTagCount !== closeTagCount) {
                const errorMsg = `&lt;${tag}&gt;æ ‡ç­¾æ²¡é—­åˆ`;
                console.log(`[æ ¼å¼éªŒè¯] æ·»åŠ é”™è¯¯: ${errorMsg}`);
                errors.push({
                  tag: tag,
                  type: 'mismatch',
                  message: errorMsg
                });
              }
            }
            
            return {
              isValid: errors.length === 0,
              errors: errors,
              summary: {
                total: errors.length,
                missing: errors.filter(e => e.type === 'missing').length,
                unclosed: errors.filter(e => e.type === 'unclosed').length,
                incomplete: errors.filter(e => e.type === 'incomplete').length,
                mismatch: errors.filter(e => e.type === 'mismatch').length
              }
            };
          },


          // --- æ–°å¢ï¼šæ˜¾ç¤ºæ ¼å¼å®¡æŸ¥è¯¦æƒ…ç•Œé¢ ---
          showFormatValidationDetails(errors, finalText) {
            const modal = document.getElementById('format-validation-modal');
            const errorsList = document.getElementById('format-errors-list');
            const rollbackBtn = document.getElementById('format-validation-rollback');
            const continueBtn = document.getElementById('format-validation-continue');
            
            if (!modal || !errorsList || !rollbackBtn || !continueBtn) return;
            
            // æ¸…ç©ºå¹¶å¡«å……é”™è¯¯åˆ—è¡¨
            errorsList.innerHTML = '';
            
            // æŒ‰é”™è¯¯ç±»å‹åˆ†ç»„æ˜¾ç¤º
            const errorsByType = {
              missing: errors.filter(e => e.type === 'missing'),
              unclosed: errors.filter(e => e.type === 'unclosed'),
              incomplete: errors.filter(e => e.type === 'incomplete'),
              mismatch: errors.filter(e => e.type === 'mismatch')
            };
            
            // å®šä¹‰é”™è¯¯ç±»å‹çš„æ˜¾ç¤ºä¿¡æ¯
            const typeInfo = {
              missing: { icon: 'âŒ', title: 'ç¼ºå¤±å¿…éœ€æ ‡ç­¾', priority: 1 },
              unclosed: { icon: 'âš ï¸', title: 'æ ‡ç­¾æœªé—­åˆ', priority: 2 },
              incomplete: { icon: 'ğŸ”§', title: 'æ ‡ç­¾ä¸å®Œæ•´', priority: 3 },
              mismatch: { icon: 'ğŸ”„', title: 'æ ‡ç­¾æ•°é‡ä¸åŒ¹é…', priority: 4 }
            };
            
            // æŒ‰ä¼˜å…ˆçº§æ˜¾ç¤ºé”™è¯¯
            Object.keys(typeInfo)
              .sort((a, b) => typeInfo[a].priority - typeInfo[b].priority)
              .forEach(type => {
                const typeErrors = errorsByType[type];
                if (typeErrors.length > 0) {
                  // åˆ›å»ºé”™è¯¯ç±»å‹æ ‡é¢˜
                  const typeHeader = document.createElement('div');
                  typeHeader.className = 'format-error-type-header';
                  typeHeader.innerHTML = `
                    <span class="error-type-icon">${typeInfo[type].icon}</span>
                    <span class="error-type-title">${typeInfo[type].title} (${typeErrors.length})</span>
                  `;
                  errorsList.appendChild(typeHeader);
                  
                  // æ˜¾ç¤ºè¯¥ç±»å‹çš„æ‰€æœ‰é”™è¯¯
                  typeErrors.forEach(error => {
                    console.log(`[æ ¼å¼éªŒè¯æ˜¾ç¤º] é”™è¯¯å¯¹è±¡:`, error);
                    console.log(`[æ ¼å¼éªŒè¯æ˜¾ç¤º] é”™è¯¯ä¿¡æ¯: "${error.message}"`);
                    const errorItem = document.createElement('div');
                    errorItem.className = 'format-error-item';
                    
                    const messageDiv = document.createElement('div');
                    messageDiv.className = 'format-error-message';
                    // ä½¿ç”¨textContentè€Œä¸æ˜¯innerHTMLï¼Œé¿å…HTMLè§£æ
                    messageDiv.textContent = error.message.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
                    
                    errorItem.appendChild(messageDiv);
                    console.log(`[æ ¼å¼éªŒè¯æ˜¾ç¤º] ç”Ÿæˆçš„HTML: ${errorItem.innerHTML}`);
                    errorsList.appendChild(errorItem);
                  });
                }
              });
            
            // å¦‚æœæ²¡æœ‰é”™è¯¯ï¼Œæ˜¾ç¤ºå ä½ä¿¡æ¯
            if (errors.length === 0) {
              errorsList.innerHTML = '<div class="format-no-errors">âœ… æ‰€æœ‰æ ‡ç­¾æ ¼å¼æ­£ç¡®</div>';
            }
            
            // æ›´æ–°æ¨¡æ€æ¡†æ ‡é¢˜ä»¥æ˜¾ç¤ºé”™è¯¯ç»Ÿè®¡
            const modalTitle = modal.querySelector('.modal-title');
            if (modalTitle) {
              const summary = [];
              if (errorsByType.missing.length > 0) summary.push(`${errorsByType.missing.length}ä¸ªç¼ºå¤±`);
              if (errorsByType.unclosed.length > 0) summary.push(`${errorsByType.unclosed.length}ä¸ªæœªé—­åˆ`);
              if (errorsByType.incomplete.length > 0) summary.push(`${errorsByType.incomplete.length}ä¸ªä¸å®Œæ•´`);
              if (errorsByType.mismatch.length > 0) summary.push(`${errorsByType.mismatch.length}ä¸ªä¸åŒ¹é…`);
              
              const summaryText = summary.length > 0 ? ` (${summary.join(', ')})` : '';
              modalTitle.textContent = `ğŸ” æ ¼å¼å®¡æŸ¥è¯¦æƒ… - å‘ç° ${errors.length} ä¸ªé—®é¢˜${summaryText}`;
            }
            
            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            rollbackBtn.onclick = () => {
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay && this.lastValidGametxtHTML) {
                // æ¢å¤åˆ°ä¸Šä¸€æ¬¡æœ‰æ•ˆçš„å†…å®¹
                gameTextDisplay.innerHTML = this.lastValidGametxtHTML;
                this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
                this.showTemporaryMessage('å†…å®¹å·²å›é€€ã€‚');

                // æ–°å¢ï¼šæ¢å¤UIå…ƒç´ å¯è§æ€§
                // æ¢å¤æ€ç»´é“¾
                this.lastExtractedThinking = this._extractLastTagContent('thinking', this.lastValidGametxtHTML, true);
                this.saveLastThinking(); // æŒä¹…åŒ–æ¢å¤çš„æ€ç»´å†…å®¹
                
                const thinkingProcessContainer = document.getElementById('thinking-process-container');
                const thinkingProcessContent = document.getElementById('thinking-process-content');

                if (this.lastExtractedThinking && this.lastExtractedThinking.trim() !== '') {
                    if (thinkingProcessContainer) {
                        thinkingProcessContainer.style.display = 'block'; // å¼ºåˆ¶æ˜¾ç¤ºå®¹å™¨
                    }
                    if (thinkingProcessContent) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                const cleanedContent = this.lastExtractedThinking
                                    .replace(/<thinking>/g, '')
                                    .replace(/<\/thinking>/g, '');
                                thinkingProcessContent.innerHTML = formatAsDisplayedMessage(cleanedContent);
                            } else {
                                thinkingProcessContent.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                            }
                        } catch (error) {
                            console.error('Error formatting thinking content on rollback:', error);
                            thinkingProcessContent.textContent = this.lastExtractedThinking;
                        }
                        thinkingProcessContent.classList.add('expanded'); // é»˜è®¤å±•å¼€
                        const thinkingProcessIcon = document.getElementById('thinking-process-icon');
                        if (thinkingProcessIcon) {
                            thinkingProcessIcon.classList.remove('collapsed');
                            thinkingProcessIcon.textContent = 'â–¼';
                        }
                    }
                } else {
                    if (thinkingProcessContainer) {
                        thinkingProcessContainer.style.display = 'none'; // å¦‚æœæ²¡æœ‰å†…å®¹åˆ™éšè—
                    }
                }

                // æ¢å¤å˜é‡æ”¹å˜æé†’
                this.updateVariableChangesReminder();

                // æ¢å¤è¡ŒåŠ¨é€‰é¡¹
                this.isActionOptionsEnabled = true; // å¼ºåˆ¶å¼€å¯è¡ŒåŠ¨é€‰é¡¹æ˜¾ç¤º
                const actionOptionsContainer = document.getElementById('action-options-container');
                if (actionOptionsContainer) {
                    actionOptionsContainer.style.display = 'flex'; // ç¡®ä¿å®¹å™¨å¯è§
                }
                const lastActionOptions = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', this.lastValidGametxtHTML) || this._extractLastTagContent('action', this.lastValidGametxtHTML);
                this.renderActionOptions(lastActionOptions);
              }
              this.closeModal('format-validation-modal');
              // å…³é—­ç­‰å¾…æ¶ˆæ¯
              this.hideWaitingMessage();
            };
            
            continueBtn.onclick = () => {
              this.closeModal('format-validation-modal');
              // æ¥å—å½“å‰æœ‰é—®é¢˜çš„å†…å®¹ï¼Œå¡«å……åˆ°0å±‚
              // è‡ªåŠ¨è¡¥å…¨</UpdateVariable>æ ‡ç­¾ï¼ˆå¦‚æœéœ€è¦ï¼‰
              // ç»§ç»­æ­£å¸¸çš„æ•°æ®å¤„ç†æµç¨‹
              // æ›´æ–°å†…å®¹ç¼“å­˜ä¸ºå½“å‰ç‰ˆæœ¬
              // å…³é—­ç­‰å¾…æ¶ˆæ¯å¹¶æ˜¾ç¤ºç¡®è®¤
              
              // æ›´æ–°ç¼“å­˜ï¼Œä»¥ä¾¿ä¸‹æ¬¡å‡ºé”™æ—¶å›é€€åˆ°è¿™ä¸ªç‰ˆæœ¬
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay) {
                this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
              }
              // ç¡®ä¿ç­‰å¾…æ¶ˆæ¯è¢«å…³é—­
              this.hideWaitingMessage();
              this.showTemporaryMessage('å·²ä¿ç•™å†…å®¹ï¼Œå°†ç»§ç»­è¿›è¡Œæ•°æ®å¤„ç†ã€‚');
              // ç»§ç»­å¤„ç†ï¼ŒåŒ…æ‹¬UpdateVariableè‡ªåŠ¨è¡¥å…¨
              this.continueProcessingWithAutoFix(finalText);
            };
            
            this.openModal('format-validation-modal');
          },

          // --- æ–°å¢ï¼šå¸¦è‡ªåŠ¨ä¿®å¤çš„ç»§ç»­å¤„ç†å‡½æ•° ---
          async continueProcessingWithAutoFix(textToProcess) {
            console.log('[å½’å¢Ÿ] continueProcessingWithAutoFix æ¥æ”¶åˆ°çš„æ–‡æœ¬:', textToProcess);
            
            // æ£€æŸ¥æ–‡æœ¬æ˜¯å¦ä¸ºç©ºæˆ–æ— æ•ˆ
            if (!textToProcess || textToProcess.trim() === '') {
              console.error('[å½’å¢Ÿ] continueProcessingWithAutoFix æ¥æ”¶åˆ°ç©ºæ–‡æœ¬ï¼Œåœæ­¢å¤„ç†');
              this.hideWaitingMessage();
              this.showTemporaryMessage('é”™è¯¯ï¼šæ¥æ”¶åˆ°ç©ºå†…å®¹ï¼Œæ— æ³•ç»§ç»­å¤„ç†ã€‚');
              return;
            }
            
            // æ£€æŸ¥å¹¶è‡ªåŠ¨è¡¥å…¨UpdateVariableæ ‡ç­¾
            let fixedText = this.autoFixUpdateVariable(textToProcess);
            
            // è°ƒç”¨åŸæœ‰çš„å¤„ç†é€»è¾‘
            await this.continueProcessing(fixedText);
          },

          // --- æ–°å¢ï¼šUpdateVariableæ ‡ç­¾è‡ªåŠ¨è¡¥å…¨ ---
          autoFixUpdateVariable(text) {
            // åªæ£€æŸ¥æ˜¯å¦å­˜åœ¨</UpdateVariable>ï¼Œå¦‚æœä¸å­˜åœ¨ï¼Œåˆ™åœ¨æœ«å°¾æ·»åŠ ä¸€ä¸ª
            if (text.includes('<UpdateVariable>') && text.indexOf('</UpdateVariable>') === -1) {
              console.log('[å½’å¢Ÿ] æœªæ‰¾åˆ° </UpdateVariable> æ ‡ç­¾ï¼Œè‡ªåŠ¨åœ¨æœ«å°¾æ·»åŠ ã€‚');
              this.showTemporaryMessage('å·²è‡ªåŠ¨è¡¥å…¨UpdateVariableç»“æŸæ ‡ç­¾', 3000);
              return text + '</UpdateVariable>';
            }
            return text;
          },

          // --- æ–°å¢ï¼šä¸“é—¨ç”¨äºæ ¼å¼éªŒè¯åç»§ç»­å¤„ç†çš„å‡½æ•° ---
          async continueProcessing(textToProcess) {
            console.log('[å½’å¢Ÿ] continueProcessing è¢«è°ƒç”¨ï¼Œæ–‡æœ¬é•¿åº¦:', textToProcess ? textToProcess.length : 0);
            
            this.updateWaitingMessage('æ¢¦æ˜Ÿå¤§äººæ­£åœ¨å¤„ç†æ•°æ®é€»è¾‘ï¼Œè¯·æ€€æ£å´‡é«˜æ•¬æ„ç­‰å¾…ing');

            // åœ¨å¤„ç†ä¸»è¦é€»è¾‘å‰ï¼Œå…ˆå‡†å¤‡å¥½æ¸…ç†è¿‡çš„æ–‡æœ¬ï¼Œç”¨äºåç»­è®¡ç®—
            const thinkingRegex = /<thinking>[\s\S]*?<\/thinking>/gi;
            const cleanedText = textToProcess.replace(thinkingRegex, '');

            // 1. æå–æ‰€æœ‰æ•°æ®
            this.lastExtractedNovelText = this._extractLastTagContent('gametxt', textToProcess);
            this.lastExtractedJourney = this._extractLastTagContent('æœ¬ä¸–å†ç¨‹', textToProcess);
            this.lastExtractedPastLives = this._extractLastTagContent('å¾€ä¸–æ¶Ÿæ¼ª', textToProcess);
            this.lastExtractedThinking = this._extractLastTagContent('thinking', textToProcess, true);
            this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', textToProcess, true);
            this.lastExtractedCharacterCard = this._extractLastTagContent('è§’è‰²æå–', textToProcess);
            this.lastExtractedMapCommands = this._extractLastTagContent('åœ°å›¾', textToProcess);

            this.saveLastThinking();
            this.updateThinkingButtonVisibility();
            this.updateVariableChangesReminder();

            // 2. æ›´æ–°å˜é‡
            const updateScript = textToProcess;
            if (updateScript && this.currentMvuState) {
                const inputData = { old_variables: this.currentMvuState };
                let mvuSucceeded = false;
                try {
                    const mvuPromise = eventEmit('mag_invoke_mvu', updateScript, inputData);
                    const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error('MVU event timeout')), 3000));
                    await Promise.race([mvuPromise, timeoutPromise]);

                    if (inputData.new_variables) {
                      this.currentMvuState = this._safeLoadMvuData(inputData.new_variables);
                      this.renderUI(this.currentMvuState.stat_data);
                        mvuSucceeded = true;
                    } else {
                        console.log('[å½’å¢Ÿ] mvu æœªè¿”å›æ–°çŠ¶æ€ï¼Œå°è¯•å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆã€‚');
                    }
                } catch (eventError) {
                    console.error('[å½’å¢Ÿ] è°ƒç”¨ mag_invoke_mvu äº‹ä»¶æ—¶å‘ç”Ÿé”™è¯¯æˆ–è¶…æ—¶ï¼Œå°è¯•å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆ:', eventError);
                }

                if (!mvuSucceeded) {
                    const modifiedState = this._applyUpdateFallback(updateScript, this.currentMvuState);
                    if (modifiedState) {
                        this.currentMvuState = modifiedState;
                        this.renderUI(this.currentMvuState.stat_data);
                    }
                }
            }

            // 3. å¤„ç†åœ°å›¾æŒ‡ä»¤
            if (this.lastExtractedMapCommands) {
                await this.handleMapUpdateCommand(this.lastExtractedMapCommands);
            }

            // 4. æ›´æ–°è¡ŒåŠ¨é€‰é¡¹
            let actionOptionsContent = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', textToProcess);
            if (!actionOptionsContent) {
               actionOptionsContent = this._extractLastTagContent('action', textToProcess);
            }
            this.renderActionOptions(actionOptionsContent);

            // 5. é™é»˜ä¿å­˜åˆ°ç¬¬0å±‚
            const messages = await getChatMessages('0');
            if (messages && messages.length > 0) {
                const messageZero = messages[0];
                messageZero.message = textToProcess;
                messageZero.data = this.currentMvuState;
                await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });
            }

            // 6. æ¸…ç†å·¥ä½œ
            const input = document.getElementById('quick-send-input');
            if (input) input.value = '';
            this.pendingActions = [];
            this.savePendingActions();
            this.showTemporaryMessage('ä¼Ÿå¤§æ¢¦æ˜Ÿå·²å›åº”ã€‚');

            // 7. è‡ªåŠ¨å­˜æ¡£
            if (this.isAutoSaveEnabled) {
                await this.performAutoSave();
     
                        this.lastUserMessage = '';
       }

            // æ–°å¢æ­¥éª¤ï¼šæ¸²æŸ“ä¸»ç•Œé¢çš„æ­£æ–‡å†…å®¹
            const gameTextDisplay = document.getElementById('game-text-display');
            if (gameTextDisplay && this.lastExtractedNovelText) {
                gameTextDisplay.innerHTML = this.formatMessageContent(this.lastExtractedNovelText);
                this.updateLiveWordCount();
            }

            // 8. æœ€ç»ˆåˆ·æ–°UI
            await this.updateDynamicData();
            this.loadEquipmentState();
            
            // 9. å¦‚æœæ˜¯éšæœºæ¨¡å¼ï¼Œåˆ‡æ¢èƒŒæ™¯å›¾
            if (this.backgroundMode === 'random') {
              this.applyRandomBackground();
            }
            
            this.hideWaitingMessage();
          },

          async handleStreamEnd(finalText) {
            console.log('[å½’å¢Ÿ] æµå¼ä¼ è¾“ç»“æŸï¼Œæœ€ç»ˆæ–‡æœ¬:', finalText);
            // ä¿®å¤ï¼šåœ¨å¤„ç†ä»»ä½•é€»è¾‘ä¹‹å‰ï¼Œç«‹å³åœæ­¢ç”Ÿæˆ
            if (typeof TavernHelper.stopGeneration === 'function') {
              TavernHelper.stopGeneration();
              console.log('[å½’å¢Ÿ] å·²è°ƒç”¨ TavernHelper.stopGeneration()');
            }

            this.isStreamingGametxt = false; // é‡ç½®æµå¼çŠ¶æ€

            // --- æ–°å¢ï¼šå¤„ç†AIç”Ÿæˆçš„è§’è‰²å¡ --- 
            if (this.pendingCharacterCardGeneration) {
                const charName = this.pendingCharacterCardGeneration;
                const tagName = 'CharacterCard';
                const cardContent = this._extractLastTagContent(tagName, finalText);

                if (cardContent) {
                    try {
                        const bookName = '1å½’å¢Ÿ';
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const targetEntry = allEntries.find(entry => entry.comment === charName);
                        if (targetEntry) {
                            await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: cardContent }]);
                            this.showTemporaryMessage(`å·²æˆåŠŸä¸ºâ€œ${charName}â€ç”Ÿæˆå¹¶å†™å…¥è§’è‰²å¡ï¼`, 3000);
                        } else {
                            throw new Error(`æœªæ‰¾åˆ°åä¸ºâ€œ${charName}â€çš„ä¸–ç•Œä¹¦æ¡ç›®ã€‚`);
                        }
                    } catch (error) {
                        console.error('å†™å…¥ç”Ÿæˆçš„è§’è‰²å¡å¤±è´¥:', error);
                        this.showTemporaryMessage(`é”™è¯¯ï¼šå†™å…¥â€œ${charName}â€çš„è§’è‰²å¡å¤±è´¥ï¼`, 4000);
                    }
                } else {
                    this.showTemporaryMessage(`è­¦å‘Šï¼šAIå›å¤ä¸­æœªæ‰¾åˆ°â€œ${charName}â€çš„è§’è‰²å¡æ ‡ç­¾ï¼Œè¯·æ‰‹åŠ¨æ£€æŸ¥å¹¶å¡«å…¥ä¸–ç•Œä¹¦ã€‚`, 5000);
                }
                this.pendingCharacterCardGeneration = null; // å¤„ç†å®Œæ¯•ï¼Œé‡ç½®è¿½è¸ªå˜é‡
            }


            // æ ¼å¼éªŒè¯é€»è¾‘
            if (this.isFormatValidationEnabled) {
                const validationResult = this.validateResponseFormat(finalText);
                if (!validationResult.isValid) {
                    // æ˜¾ç¤ºè¯¦ç»†çš„æ ¼å¼å®¡æŸ¥ç•Œé¢ï¼Œè®©ç”¨æˆ·å†³å®šå¦‚ä½•æ“ä½œ
                    this.showFormatValidationDetails(validationResult.errors, finalText);
                } else {
                    // æ ¼å¼æ­£ç¡®ï¼Œç¼“å­˜æœ‰æ•ˆHTMLï¼Œç„¶åç»§ç»­å¤„ç†
                    const gameTextDisplay = document.getElementById('game-text-display');
                    if (gameTextDisplay) {
                        this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                    }
                    // ç›´æ¥è°ƒç”¨å¸¦æœ‰è‡ªåŠ¨ä¿®å¤åŠŸèƒ½çš„å¤„ç†å‡½æ•°
                    await this.continueProcessingWithAutoFix(finalText);
                }
            } else {
                // ç¦ç”¨å®¡æŸ¥ï¼Œç›´æ¥å¤„ç†
                const gameTextDisplay = document.getElementById('game-text-display');
                if (gameTextDisplay) {
                    this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                }
                // ç›´æ¥è°ƒç”¨å¸¦æœ‰è‡ªåŠ¨ä¿®å¤åŠŸèƒ½çš„å¤„ç†å‡½æ•°
                await this.continueProcessingWithAutoFix(finalText);
            }

            // æ–°å¢ï¼šAIç”Ÿæˆç»“æŸåï¼Œå¦‚æœå¼€å¯äº†è‡ªåŠ¨ç”Ÿæˆï¼Œåˆ™è§¦å‘ä¸€æ¬¡åˆ†æ®µè®°å¿†æ›´æ–°
            if (this.isSegmentedMemoryAutoGenerateEnabled) {
                console.log('[å½’å¢Ÿ] AIç”Ÿæˆç»“æŸï¼Œè§¦å‘åˆ†æ®µè®°å¿†æ›´æ–°...');
                // ä½¿ç”¨ isPolling = false æ¥ç¡®ä¿UIåé¦ˆï¼Œè®©ç”¨æˆ·çŸ¥é“æ­£åœ¨å‘ç”Ÿä»€ä¹ˆ
                await this.generateSegmentedMemory(false);
            }
            if (this.isSmallSummaryAutoOn) {
                console.log('[å½’å¢Ÿ] AIç”Ÿæˆç»“æŸï¼Œè§¦å‘å°æ€»ç»“æ›´æ–°...');
                await this.generateSmallSummary(false);
            }
            if (this.isLargeSummaryAutoOn) {
                console.log('[å½’å¢Ÿ] AIç”Ÿæˆç»“æŸï¼Œè§¦å‘å¤§æ€»ç»“æ›´æ–°...');
                await this.generateLargeSummary(false);
            }
          },

          // --- æ–°å¢ï¼šå…¨å±åŠŸèƒ½ ---
          toggleFullScreen() {
            const elem = document.querySelector('.guixu-root-container');
            if (!document.fullscreenElement) {
              elem.requestFullscreen().catch(err => {
                alert(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
              });
            } else {
              document.exitFullscreen();
            }
          },

          exitFullScreen() {
              if (document.fullscreenElement) {
                  document.exitFullscreen();
              }
          },

          // --- æ–°å¢ï¼šé¢æ¿æŠ˜å åŠŸèƒ½ ---
          toggleLeftPanel() {
            this.leftPanelCollapsed = !this.leftPanelCollapsed;
            this.updatePanelStates();
            this.savePanelStates();
          },

          toggleRightPanel() {
            this.rightPanelCollapsed = !this.rightPanelCollapsed;
            this.updatePanelStates();
            this.savePanelStates();
          },

          updatePanelStates() {
            const gameContainer = document.querySelector('.game-container');
            const leftPanel = document.querySelector('.character-panel');
            const rightPanel = document.querySelector('.interaction-panel');
            
            if (!gameContainer || !leftPanel || !rightPanel) return;

            // æ›´æ–°game-containerçš„CSSç±»
            gameContainer.classList.toggle('left-panel-collapsed', this.leftPanelCollapsed);
            gameContainer.classList.toggle('right-panel-collapsed', this.rightPanelCollapsed);
            gameContainer.classList.toggle('both-panels-collapsed', this.leftPanelCollapsed && this.rightPanelCollapsed);

            // æ›´æ–°é¢æ¿çš„æŠ˜å çŠ¶æ€
            leftPanel.classList.toggle('collapsed', this.leftPanelCollapsed);
            rightPanel.classList.toggle('collapsed', this.rightPanelCollapsed);

            // æ›´æ–°ç®­å¤´æ–¹å‘ - éšè—/æ˜¾ç¤ºæ¨¡å¼
            const leftArrow = document.querySelector('.left-panel-toggle .toggle-arrow');
            const rightArrow = document.querySelector('.right-panel-toggle .toggle-arrow');
            
            if (leftArrow) {
              leftArrow.textContent = this.leftPanelCollapsed ? 'â–¶' : 'â—€';
            }
            if (rightArrow) {
              rightArrow.textContent = this.rightPanelCollapsed ? 'â—€' : 'â–¶';
            }
          },

          loadPanelStates() {
            try {
              const savedStates = localStorage.getItem('guixu_panel_states');
              if (savedStates) {
                const states = JSON.parse(savedStates);
                this.leftPanelCollapsed = states.leftPanelCollapsed || false;
                this.rightPanelCollapsed = states.rightPanelCollapsed || false;
                this.updatePanelStates();
              }
            } catch (e) {
              console.error('åŠ è½½é¢æ¿çŠ¶æ€å¤±è´¥:', e);
            }
          },

          savePanelStates() {
            try {
              const states = {
                leftPanelCollapsed: this.leftPanelCollapsed,
                rightPanelCollapsed: this.rightPanelCollapsed
              };
              localStorage.setItem('guixu_panel_states', JSON.stringify(states));
            } catch (e) {
              console.error('ä¿å­˜é¢æ¿çŠ¶æ€å¤±è´¥:', e);
            }
          },

          toggleCharacterPanel() {
              this.isCharacterPanelVisible = !this.isCharacterPanelVisible;
              const container = document.querySelector('.guixu-root-container');
              const floatingBtn = document.getElementById('floating-character-btn');

              if (container) {
                  container.classList.toggle('character-panel-visible', this.isCharacterPanelVisible);
              }

              if (floatingBtn) {
                  floatingBtn.classList.toggle('active', this.isCharacterPanelVisible);
                  floatingBtn.textContent = this.isCharacterPanelVisible ? 'æ”¶èµ·' : 'è§’è‰²';
              }
          },

          toggleInteractionPanel() {
              this.isInteractionPanelVisible = !this.isInteractionPanelVisible;
              const container = document.querySelector('.guixu-root-container');
              const floatingBtn = document.getElementById('floating-interaction-btn');

              if (container) {
                  container.classList.toggle('interaction-panel-visible', this.isInteractionPanelVisible);
              }

              if (floatingBtn) {
                  floatingBtn.classList.toggle('active', this.isInteractionPanelVisible);
                  floatingBtn.textContent = this.isInteractionPanelVisible ? 'æ”¶èµ·' : 'åŠŸèƒ½';
              }
          },

          // --- æ–°å¢ï¼šé‡æ–°å¤„ç†å˜é‡ ---
          async reprocessVariables() {
            this.showWaitingMessage('æ­£åœ¨é‡æ–°å¤„ç†å˜é‡...');
            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0) {
                const lastMessageContent = messages[0].message;
                await this.continueProcessingWithAutoFix(lastMessageContent);
                this.showTemporaryMessage('å˜é‡å·²é‡æ–°å¤„ç†ã€‚');
              } else {
                this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°å½“å‰æ¶ˆæ¯ä»¥é‡æ–°å¤„ç†ã€‚', 5000, true);
              }
            } catch (error) {
              console.error('é‡æ–°å¤„ç†å˜é‡æ—¶å‡ºé”™:', error);
              this.showTemporaryMessage('é‡æ–°å¤„ç†å˜é‡æ—¶å‘ç”Ÿé”™è¯¯ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°ã€‚', 5000, true);
            } finally {
              this.hideWaitingMessage();
            }
          },

          // --- æ–°å¢ï¼šåˆå§‹åŒ–å¯æ‹–åŠ¨æŒ‰é’®åŠŸèƒ½ ---
          initDraggableButtons() {
              const characterBtn = document.getElementById('floating-character-btn');
              const interactionBtn = document.getElementById('floating-interaction-btn');

              if (characterBtn) {
                  this.makeDraggable(characterBtn, () => this.toggleCharacterPanel());
              }
              if (interactionBtn) {
                  this.makeDraggable(interactionBtn, () => this.toggleInteractionPanel());
              }
          },

          // --- æ–°å¢ï¼šä½¿å…ƒç´ å¯æ‹–åŠ¨ ---
          makeDraggable(element, clickCallback) {
              let isDragging = false;
              let startX, startY, startLeft, startTop;
              let hasMoved = false;

              // é¼ æ ‡äº‹ä»¶
              element.addEventListener('mousedown', (e) => {
                  isDragging = true;
                  hasMoved = false;
                  startX = e.clientX;
                  startY = e.clientY;
                  startLeft = parseInt(window.getComputedStyle(element).left, 10);
                  startTop = parseInt(window.getComputedStyle(element).top, 10);
                  element.classList.add('dragging');
                  e.preventDefault();
              });

              document.addEventListener('mousemove', (e) => {
                  if (!isDragging) return;
                  
                  const deltaX = e.clientX - startX;
                  const deltaY = e.clientY - startY;
                  
                  // å¦‚æœæœ‰ä»»ä½•ç§»åŠ¨ï¼Œç«‹å³è®¤ä¸ºæ˜¯æ‹–åŠ¨ï¼ˆå»¶è¿Ÿä¸º0ï¼‰
                  if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                      hasMoved = true;
                  }

                  const newLeft = startLeft + deltaX;
                  const newTop = startTop + deltaY;

                  // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                  const maxLeft = window.innerWidth - element.offsetWidth;
                  const maxTop = window.innerHeight - element.offsetHeight;

                  element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                  element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
              });

              document.addEventListener('mouseup', () => {
                  if (isDragging) {
                      isDragging = false;
                      element.classList.remove('dragging');
                      
                      // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œæ‰§è¡Œç‚¹å‡»å›è°ƒ
                      if (!hasMoved) {
                          clickCallback();
                      }
                  }
              });

              // è§¦æ‘¸äº‹ä»¶ï¼ˆç§»åŠ¨ç«¯ï¼‰
              element.addEventListener('touchstart', (e) => {
                  isDragging = true;
                  hasMoved = false;
                  const touch = e.touches[0];
                  startX = touch.clientX;
                  startY = touch.clientY;
                  startLeft = parseInt(window.getComputedStyle(element).left, 10);
                  startTop = parseInt(window.getComputedStyle(element).top, 10);
                  element.classList.add('dragging');
                  e.preventDefault();
              });

              element.addEventListener('touchmove', (e) => {
                  if (!isDragging) return;
                  
                  const touch = e.touches[0];
                  const deltaX = touch.clientX - startX;
                  const deltaY = touch.clientY - startY;
                  
                  // å¦‚æœæœ‰ä»»ä½•ç§»åŠ¨ï¼Œç«‹å³è®¤ä¸ºæ˜¯æ‹–åŠ¨ï¼ˆå»¶è¿Ÿä¸º0ï¼‰
                  if (Math.abs(deltaX) > 0 || Math.abs(deltaY) > 0) {
                      hasMoved = true;
                  }

                  const newLeft = startLeft + deltaX;
                  const newTop = startTop + deltaY;

                  // é™åˆ¶åœ¨å±å¹•èŒƒå›´å†…
                  const maxLeft = window.innerWidth - element.offsetWidth;
                  const maxTop = window.innerHeight - element.offsetHeight;

                  element.style.left = Math.max(0, Math.min(newLeft, maxLeft)) + 'px';
                  element.style.top = Math.max(0, Math.min(newTop, maxTop)) + 'px';
                  e.preventDefault();
              });

              element.addEventListener('touchend', () => {
                  if (isDragging) {
                      isDragging = false;
                      element.classList.remove('dragging');
                      
                      // å¦‚æœæ²¡æœ‰ç§»åŠ¨ï¼Œæ‰§è¡Œç‚¹å‡»å›è°ƒ
                      if (!hasMoved) {
                          clickCallback();
                      }
                  }
              });
          },

          // --- æ–°å¢ï¼šçª—å£å¤§å°è°ƒæ•´åŠŸèƒ½ (å®æ—¶è°ƒæ•´) ---
          toggleWindowSizePanel() {
              const panel = document.getElementById('window-size-panel');
              if (panel) {
                  const isVisible = panel.style.display === 'block';
                  panel.style.display = isVisible ? 'none' : 'block';
                  if (!isVisible) {
                      this.loadCurrentWindowSize();
                  }
              }
          },

          hideWindowSizePanel() {
              const panel = document.getElementById('window-size-panel');
              if (panel) {
                  panel.style.display = 'none';
              }
          },
          
          loadCurrentWindowSize() {
              const container = document.querySelector('.guixu-root-container');
              const gameContainer = document.querySelector('.game-container');
              if (container && gameContainer) {
                  const currentWidth = parseInt(container.style.maxWidth) || 900;
                  const currentHeight = parseInt(gameContainer.style.height) || 600;
                  
                  const widthSlider = document.getElementById('width-slider');
                  const heightSlider = document.getElementById('height-slider');
                  const widthDisplay = document.getElementById('width-display');
                  const heightDisplay = document.getElementById('height-display');
                  
                  if (widthSlider) widthSlider.value = currentWidth;
                  if (heightSlider) heightSlider.value = currentHeight;
                  if (widthDisplay) widthDisplay.textContent = `${currentWidth}px`;
                  if (heightDisplay) heightDisplay.textContent = `${currentHeight}px`;
              }
              
              // åŒæ—¶åŠ è½½æ¨¡æ€æ¡†å½“å‰å¤§å°
              this.loadCurrentModalSize();
          },

          loadCurrentModalSize() {
              // ä»localStorageåŠ è½½æˆ–ä½¿ç”¨é»˜è®¤å€¼
              const savedState = localStorage.getItem('guixu_modal_size');
              let modalWidth = 800;
              let modalHeight = 600;
              
              if (savedState) {
                  try {
                      const { width, height } = JSON.parse(savedState);
                      modalWidth = width || 800;
                      modalHeight = height || 600;
                  } catch (e) {
                      console.error('è§£ææ¨¡æ€æ¡†å¤§å°çŠ¶æ€å¤±è´¥:', e);
                  }
              }
              
              const modalWidthSlider = document.getElementById('modal-width-slider');
              const modalHeightSlider = document.getElementById('modal-height-slider');
              const modalWidthDisplay = document.getElementById('modal-width-display');
              const modalHeightDisplay = document.getElementById('modal-height-display');
              
              if (modalWidthSlider) modalWidthSlider.value = modalWidth;
              if (modalHeightSlider) modalHeightSlider.value = modalHeight;
              if (modalWidthDisplay) modalWidthDisplay.textContent = `${modalWidth}px`;
              if (modalHeightDisplay) modalHeightDisplay.textContent = `${modalHeight}px`;
          },

          updateWidthDisplay(value) {
              const widthDisplay = document.getElementById('width-display');
              if (widthDisplay) {
                  widthDisplay.textContent = `${value}px`;
              }
              this.applyWindowSize(value, null);
          },

          updateHeightDisplay(value) {
              const heightDisplay = document.getElementById('height-display');
              if (heightDisplay) {
                  heightDisplay.textContent = `${value}px`;
              }
              this.applyWindowSize(null, value);
          },
          
          applyWindowSize(newWidth, newHeight) {
               const container = document.querySelector('.guixu-root-container');
               const gameContainer = document.querySelector('.game-container');

               if (container && gameContainer) {
                   if (newWidth !== null) {
                       container.style.maxWidth = `${newWidth}px`;
                   }
                   if (newHeight !== null) {
                       gameContainer.style.height = `${newHeight}px`;
                   }
               }
               // å®æ—¶ä¿å­˜ï¼Œå¯èƒ½ä¼šæœ‰æ€§èƒ½é—®é¢˜ï¼Œä½†æŒ‰æŒ‡ç¤ºå¿½ç•¥lodash
               this.saveWindowSizeState();
          },
          
          resetWindowSize() {
              const defaultWidth = 900;
              const defaultHeight = 600;
              
              const widthSlider = document.getElementById('width-slider');
              const heightSlider = document.getElementById('height-slider');
              
              if (widthSlider) widthSlider.value = defaultWidth;
              if (heightSlider) heightSlider.value = defaultHeight;

              this.updateWidthDisplay(defaultWidth);
              this.updateHeightDisplay(defaultHeight);

              this.showTemporaryMessage('å·²é‡ç½®ä¸ºé»˜è®¤å¤§å°');
          },

          saveWindowSizeState() {
              try {
                  const container = document.querySelector('.guixu-root-container');
                  const gameContainer = document.querySelector('.game-container');
                  
                  if (container && gameContainer) {
                      // ä»å®é™…çš„DOMæ ·å¼ä¸­è·å–å½“å‰å°ºå¯¸
                      const currentWidth = parseInt(container.style.maxWidth) || 900;
                      const currentHeight = parseInt(gameContainer.style.height) || 600;
                      
                      const sizeState = {
                          width: currentWidth,
                          height: currentHeight
                      };
                      
                      localStorage.setItem('guixu_window_size', JSON.stringify(sizeState));
                      console.log(`çª—å£å¤§å°å·²ä¿å­˜: ${currentWidth}x${currentHeight}`);
                  }
              } catch (e) {
                  console.error('ä¿å­˜çª—å£å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },
          
          loadWindowSizeState() {
              try {
                  const savedState = localStorage.getItem('guixu_window_size');
                  if (savedState) {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          // ç›´æ¥åº”ç”¨åˆ°DOMï¼Œé¿å…å¾ªç¯è°ƒç”¨saveWindowSizeState
                          const container = document.querySelector('.guixu-root-container');
                          const gameContainer = document.querySelector('.game-container');
                          
                          if (container && gameContainer) {
                              container.style.maxWidth = `${width}px`;
                              gameContainer.style.height = `${height}px`;
                              
                              // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
                              const widthSlider = document.getElementById('width-slider');
                              const heightSlider = document.getElementById('height-slider');
                              const widthDisplay = document.getElementById('width-display');
                              const heightDisplay = document.getElementById('height-display');
                              
                              if (widthSlider) widthSlider.value = width;
                              if (heightSlider) heightSlider.value = height;
                              if (widthDisplay) widthDisplay.textContent = `${width}px`;
                              if (heightDisplay) heightDisplay.textContent = `${height}px`;
                              
                              console.log(`çª—å£å¤§å°å·²ä»ç¼“å­˜æ¢å¤: ${width}x${height}`);
                          }
                      }
                  }
              } catch (e) {
                  console.error('åŠ è½½çª—å£å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },

          // --- æ–°å¢ï¼šäºŒçº§çª—å£ï¼ˆæ¨¡æ€æ¡†ï¼‰å¤§å°è°ƒæ•´åŠŸèƒ½ ---
          updateModalWidthDisplay(value) {
              const modalWidthDisplay = document.getElementById('modal-width-display');
              if (modalWidthDisplay) {
                  modalWidthDisplay.textContent = `${value}px`;
              }
              this.applyModalSize(value, null);
          },

          updateModalHeightDisplay(value) {
              const modalHeightDisplay = document.getElementById('modal-height-display');
              if (modalHeightDisplay) {
                  modalHeightDisplay.textContent = `${value}px`;
              }
              this.applyModalSize(null, value);
          },

          applyModalSize(newWidth, newHeight) {
              // åº”ç”¨åˆ°æ‰€æœ‰æ¨¡æ€æ¡†çš„ .modal-content
              const modalContents = document.querySelectorAll('.modal-content');
              modalContents.forEach(modalContent => {
                  // è±å…äººç‰©å…³ç³»æ¨¡æ€æ¡†ï¼Œå®ƒçš„å°ºå¯¸ç”±å…¶å†…éƒ¨CSSæ§åˆ¶
                  if (modalContent.closest('#relationships-modal')) {
                      return;
                  }
                  if (newWidth !== null) {
                      modalContent.style.maxWidth = `${newWidth}px`;
                      modalContent.style.width = `${Math.min(newWidth, window.innerWidth * 0.9)}px`;
                  }
                  if (newHeight !== null) {
                      modalContent.style.height = `${Math.min(newHeight, window.innerHeight * 0.9)}px`;
                      modalContent.style.maxHeight = `${Math.min(newHeight, window.innerHeight * 0.9)}px`;
                      // ç¡®ä¿å†…å®¹åŒºåŸŸä¹Ÿèƒ½æ­£ç¡®æ˜¾ç¤º
                      modalContent.style.overflow = 'auto';
                  }
              });
              
              // å®æ—¶ä¿å­˜æ¨¡æ€æ¡†å¤§å°çŠ¶æ€
              this.saveModalSizeState();
          },

          resetModalSize() {
              const defaultWidth = 800;
              const defaultHeight = 600;
              
              const modalWidthSlider = document.getElementById('modal-width-slider');
              const modalHeightSlider = document.getElementById('modal-height-slider');
              
              if (modalWidthSlider) modalWidthSlider.value = defaultWidth;
              if (modalHeightSlider) modalHeightSlider.value = defaultHeight;

              this.updateModalWidthDisplay(defaultWidth);
              this.updateModalHeightDisplay(defaultHeight);

              this.showTemporaryMessage('æ¨¡æ€æ¡†å¤§å°å·²é‡ç½®ä¸ºé»˜è®¤');
          },

          saveModalSizeState() {
              try {
                  const modalWidthSlider = document.getElementById('modal-width-slider');
                  const modalHeightSlider = document.getElementById('modal-height-slider');
                  
                  if (modalWidthSlider && modalHeightSlider) {
                      const currentWidth = parseInt(modalWidthSlider.value) || 800;
                      const currentHeight = parseInt(modalHeightSlider.value) || 600;
                      
                      const modalSizeState = {
                          width: currentWidth,
                          height: currentHeight
                      };
                      
                      localStorage.setItem('guixu_modal_size', JSON.stringify(modalSizeState));
                      console.log(`æ¨¡æ€æ¡†å¤§å°å·²ä¿å­˜: ${currentWidth}x${currentHeight}`);
                  }
              } catch (e) {
                  console.error('ä¿å­˜æ¨¡æ€æ¡†å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadModalSizeState() {
              try {
                  const savedState = localStorage.getItem('guixu_modal_size');
                  if (savedState) {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          // æ›´æ–°æ»‘å—æ˜¾ç¤ºå€¼
                          const modalWidthSlider = document.getElementById('modal-width-slider');
                          const modalHeightSlider = document.getElementById('modal-height-slider');
                          const modalWidthDisplay = document.getElementById('modal-width-display');
                          const modalHeightDisplay = document.getElementById('modal-height-display');
                          
                          if (modalWidthSlider) modalWidthSlider.value = width;
                          if (modalHeightSlider) modalHeightSlider.value = height;
                          if (modalWidthDisplay) modalWidthDisplay.textContent = `${width}px`;
                          if (modalHeightDisplay) modalHeightDisplay.textContent = `${height}px`;
                          
                          // åº”ç”¨åˆ°ç°æœ‰çš„æ¨¡æ€æ¡†
                          this.applyModalSize(width, height);
                          
                          console.log(`æ¨¡æ€æ¡†å¤§å°å·²ä»ç¼“å­˜æ¢å¤: ${width}x${height}`);
                      }
                  }
              } catch (e) {
                  console.error('åŠ è½½æ¨¡æ€æ¡†å¤§å°çŠ¶æ€å¤±è´¥:', e);
              }
          },

         // --- æ–°å¢ï¼šçŠ¶æ€æ•ˆæœå¼¹å‡ºçª—å£ ---
         toggleStatusPopup() {
           const popup = document.getElementById('status-effects-popup');
           if (popup) {
             const isVisible = popup.style.display === 'flex';
             popup.style.display = isVisible ? 'none' : 'flex';
           }
         },

          SafeGetValue(obj, path, defaultValue = 'N/A') {
            let keys = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            for (let i = 0; i < keys.length; i++) {
              if (
                current === undefined ||
                current === null ||
                typeof current !== 'object' ||
                !current.hasOwnProperty(keys[i])
              ) {
                return defaultValue;
              }
              current = current[keys[i]];
            }
            if (current === undefined || current === null) {
              return defaultValue;
            }
            // å¦‚æœæ˜¯å¯¹è±¡ï¼ˆä½†ä¸æ˜¯æ•°ç»„ï¼‰ï¼Œç›´æ¥è¿”å›
            if (typeof current === 'object' && !Array.isArray(current)) {
               return current;
           }
            if (Array.isArray(current)) {
              if (current.length > 0) {
                const actualValue = current[0];
                if (typeof actualValue === 'boolean') return actualValue;
                // å¦‚æœæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯å¯¹è±¡ï¼Œç›´æ¥è¿”å›è¯¥å¯¹è±¡
                if (typeof actualValue === 'object' && actualValue !== null) {
                   return actualValue;
                }
                return String(actualValue);
              } else {
                return defaultValue;
              }
            }
            if (typeof current === 'boolean') return current;
            return String(current);
          },

          async updateDynamicData() {
            try {
              // åŠ è½½æ ¸å¿ƒmvuæ•°æ®
              const messages = await getChatMessages(getCurrentMessageId());
              if (messages && messages.length > 0 && messages[0].data) {
                // ç¼“å­˜å®Œæ•´çš„ mvu çŠ¶æ€ï¼Œåº”ç”¨å®‰å…¨ä¿®å¤
                const rawData = messages[0].data;
                this.currentMvuState = this._safeLoadMvuData(rawData);
                this.renderUI(this.currentMvuState.stat_data);
              } else {
                console.warn('æ— æ³•ä»å½“å‰æ¶ˆæ¯ä¸­åŠ è½½ mvu dataã€‚');
              }

              // æ–°å¢ï¼šåŠ è½½å¹¶æ˜¾ç¤ºå½“å‰åœºæ™¯æ­£æ–‡
              // æ­¤å‡½æ•°ç°åœ¨å¤„ç†è‡ªå·±çš„æ–‡æœ¬æ ¼å¼åŒ–ã€‚
              await this.loadAndDisplayCurrentScene();
            } catch (error) {
              console.error('æ›´æ–°å½’å¢ŸåŠ¨æ€æ•°æ®æ—¶å‡ºé”™:', error);
            }
          },

          // æ–°å¢ï¼šç»Ÿä¸€çš„UIæ¸²æŸ“å‡½æ•°
          renderUI(data) {
            if (!data) {
              console.warn('RenderUI è°ƒç”¨å¤±è´¥ï¼šæ²¡æœ‰æä¾›æ•°æ®ã€‚');
              return;
            }
            const updateText = (id, value, style = '') => {
              const el = document.getElementById(id);
              if (el) {
                el.innerText = value;
                if (style) {
                  el.setAttribute('style', style);
                }
              }
            };

            // å˜é‡ç»“æ„æ›´æ–°ï¼šç›´æ¥è¯»å–'å½“å‰å¢ƒç•Œ'
            const jingjieValue = this.SafeGetValue(data, 'å½“å‰å¢ƒç•Œ', '...');
            const match = jingjieValue.match(/^(\S{2})/);
            const jingjieTier = match ? match[1] : '';
            const jingjieStyle = this.getJingJieStyle(jingjieTier);
            updateText('val-jingjie', jingjieValue); // ç§»é™¤æ ·å¼ï¼Œåªæ›´æ–°æ–‡æœ¬
            updateText('val-jinian', this.SafeGetValue(data, 'å½“å‰æ—¶é—´çºªå¹´'));
            const currentWorld = this.SafeGetValue(data, 'å½“å‰ç¬¬xä¸–', '1');
            updateText('val-current-world', `ç¬¬${currentWorld}ä¸–`);
            const charge = this.SafeGetValue(data, 'å½’å¢Ÿå……èƒ½æ—¶é—´', '0');
            updateText('val-guixu-charge-text', `${charge}%`);
            const chargeBar = document.getElementById('bar-guixu-charge');
            if (chargeBar) chargeBar.style.setProperty('--guixu-charge', `${charge}%`);

            // æ­¤å¤„ä¸å†éœ€è¦å¡«å…… this.baseAttributesï¼Œå› ä¸º updateDisplayedAttributes ä¼šç›´æ¥ä» stat_data è¯»å–
            
            this.updateTalentAndLinggen(data);
            this.loadEquipmentFromMVU(data);
            this.updateDisplayedAttributes(); // æ ¸å¿ƒæ¸²æŸ“å‡½æ•°

            // --- å˜é‡é€‚é…ï¼šé‡æ„çŠ¶æ€æ•ˆæœæ¸²æŸ“é€»è¾‘ ---
            const summaryTextEl = document.getElementById('status-summary-text');
            const popupListEl = document.getElementById('status-effects-popup-list');
            if (summaryTextEl && popupListEl) {
              // æ–°ç»“æ„ï¼š'å½“å‰çŠ¶æ€' æ˜¯ä¸€ä¸ªå¯¹è±¡ï¼Œé”®æ˜¯çŠ¶æ€åï¼Œå€¼æ˜¯æè¿°
              const statuses = this.SafeGetValue(data, 'å½“å‰çŠ¶æ€', {});
              
              // è¿‡æ»¤æ‰å…ƒæ•°æ®
              const statusEntries = Object.entries(statuses).filter(([key]) => key !== '$meta');

              if (statusEntries.length > 0) {
                summaryTextEl.textContent = `å½“å‰æœ‰ ${statusEntries.length} ä¸ªçŠ¶æ€æ•ˆæœ`;
                
                popupListEl.innerHTML = statusEntries.map(([name, description]) => {
                  return `
                    <div class="status-effect-item">
                      <strong>${name}:</strong> ${description}
                    </div>
                  `;
                }).join('');
              } else {
                summaryTextEl.textContent = 'å½“å‰æ— çŠ¶æ€æ•ˆæœ';
                popupListEl.innerHTML = '<div class="status-effect-item">æš‚æ— </div>';
              }
            }
          },

          // --- Event Listeners for Buttons and Modals ---
          bindStaticListeners() {
            if (this.listenersBound) return; // å¦‚æœå·²ç»ç»‘å®šè¿‡ï¼Œåˆ™ç›´æ¥è¿”å›

            // æ–°å¢ï¼šä¸ºè§†å›¾åˆ‡æ¢æŒ‰é’®ç»‘å®šç›‘å¬å™¨
            document.getElementById('view-toggle-btn')?.addEventListener('click', () => this.toggleViewMode());
            document.getElementById('fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen());
            document.getElementById('exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen());

            // æ–°å¢ï¼šä¸ºé¡¶éƒ¨å…¨å±æŒ‰é’®ç»‘å®šç›‘å¬å™¨
            document.getElementById('top-fullscreen-btn')?.addEventListener('click', () => this.toggleFullScreen());
            document.getElementById('top-exit-fullscreen-btn')?.addEventListener('click', () => this.exitFullScreen());

            // æ–°å¢ï¼šä¸ºå˜é‡æ”¹å˜æé†’ç»‘å®šç›‘å¬å™¨
            document.getElementById('variable-changes-header')?.addEventListener('click', () => this.toggleVariableChanges());

            // æ–°å¢ï¼šä¸ºé¢æ¿æŠ˜å æŒ‰é’®ç»‘å®šç›‘å¬å™¨
            document.getElementById('left-panel-toggle')?.addEventListener('click', () => this.toggleLeftPanel());
            document.getElementById('right-panel-toggle')?.addEventListener('click', () => this.toggleRightPanel());

            document.addEventListener('fullscreenchange', () => {
                // å³ä¾§é¢æ¿çš„å…¨å±æŒ‰é’®
                const fullscreenBtn = document.getElementById('fullscreen-btn');
                const exitFullscreenBtn = document.getElementById('exit-fullscreen-btn');
                // é¡¶éƒ¨çŠ¶æ€æ çš„å…¨å±æŒ‰é’®
                const topFullscreenBtn = document.getElementById('top-fullscreen-btn');
                const topExitFullscreenBtn = document.getElementById('top-exit-fullscreen-btn');
                
                if (document.fullscreenElement) {
                    // è¿›å…¥å…¨å±æ¨¡å¼
                    if (fullscreenBtn) fullscreenBtn.style.display = 'none';
                    if (exitFullscreenBtn) exitFullscreenBtn.style.display = 'flex';
                    if (topFullscreenBtn) topFullscreenBtn.style.display = 'none';
                    if (topExitFullscreenBtn) topExitFullscreenBtn.style.display = 'flex';
                } else {
                    // é€€å‡ºå…¨å±æ¨¡å¼
                    if (fullscreenBtn) fullscreenBtn.style.display = 'flex';
                    if (exitFullscreenBtn) exitFullscreenBtn.style.display = 'none';
                    if (topFullscreenBtn) topFullscreenBtn.style.display = 'flex';
                    if (topExitFullscreenBtn) topExitFullscreenBtn.style.display = 'none';
                }
            });
            // æµ®åŠ¨æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨å’Œæ‹–åŠ¨åŠŸèƒ½
            this.initDraggableButtons();
            
            // æ–°å¢ï¼šä¸ºçª—å£å¤§å°è°ƒæ•´æŒ‰é’®å’Œæ§åˆ¶é¢æ¿ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            document.getElementById('window-size-btn')?.addEventListener('click', () => this.toggleWindowSizePanel());
            document.getElementById('window-size-close')?.addEventListener('click', () => this.hideWindowSizePanel());
            document.getElementById('width-slider')?.addEventListener('input', (e) => this.updateWidthDisplay(e.target.value));
            document.getElementById('height-slider')?.addEventListener('input', (e) => this.updateHeightDisplay(e.target.value));
            document.getElementById('reset-size-btn')?.addEventListener('click', () => this.resetWindowSize());
            
            // æ–°å¢ï¼šä¸ºäºŒçº§çª—å£ï¼ˆæ¨¡æ€æ¡†ï¼‰å¤§å°è°ƒæ•´ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            document.getElementById('modal-width-slider')?.addEventListener('input', (e) => this.updateModalWidthDisplay(e.target.value));
            document.getElementById('modal-height-slider')?.addEventListener('input', (e) => this.updateModalHeightDisplay(e.target.value));
            document.getElementById('reset-modal-size-btn')?.addEventListener('click', () => this.resetModalSize());
            
            // --- æ–°å¢ï¼šä¸ºçŠ¶æ€æ•ˆæœå¼¹å‡ºçª—å£ç»‘å®šäº‹ä»¶ ---
            document.getElementById('status-summary-button')?.addEventListener('click', () => this.toggleStatusPopup());
            document.getElementById('status-effects-popup-close')?.addEventListener('click', () => this.toggleStatusPopup());
            
            // æ–°å¢ï¼šä¸ºä¸–ç•Œä¹¦åºå·è¾“å…¥æ¡†ç»‘å®šç›‘å¬
            // æ–°å¢ï¼šä¸ºç»Ÿä¸€çš„åºå·è¾“å…¥æ¡†ç»‘å®šç›‘å¬
            document.getElementById('unified-index-input')?.addEventListener('change', (e) => {
                const newIndex = parseInt(e.target.value, 10);
                if (!isNaN(newIndex) && newIndex > 0) {
                    this.unifiedIndex = newIndex;
                    this.saveUnifiedIndex();
                    this.showTemporaryMessage(`ä¸–ç•Œä¹¦è¯»å†™åºå·å·²æ›´æ–°ä¸º ${newIndex}`);
                    // å¦‚æœè‡ªåŠ¨å¼€å…³æ˜¯å¼€å¯çš„ï¼Œç«‹å³æ›´æ–°å¯ç”¨çš„æ¡ç›®
                    if (this.isAutoToggleLorebookEnabled) {
                        this.startAutoTogglePolling();
                    }
                } else {
                    e.target.value = this.unifiedIndex; // å¦‚æœè¾“å…¥æ— æ•ˆï¼Œåˆ™æ¢å¤
                }
            });

           // ä¿®å¤ï¼šå°è¯´æ¨¡å¼åºå·è¾“å…¥æ¡†ä½¿ç”¨ç»Ÿä¸€åºå·
           document.getElementById('novel-mode-index-input')?.addEventListener('change', (e) => {
               const newIndex = parseInt(e.target.value, 10);
               if (!isNaN(newIndex) && newIndex > 0) {
                   this.unifiedIndex = newIndex; // ä¿®å¤ï¼šä½¿ç”¨ç»Ÿä¸€åºå·
                   this.saveUnifiedIndex(); // ä¿®å¤ï¼šä¿å­˜ç»Ÿä¸€åºå·
                   this.showTemporaryMessage(`ä¸–ç•Œä¹¦è¯»å†™åºå·å·²æ›´æ–°ä¸º ${newIndex}`);
                   // ç«‹å³åˆ·æ–°æ¨¡æ€æ¡†å†…å®¹
                   if (document.getElementById('novel-mode-modal').style.display === 'flex') {
                     this.showNovelMode();
                   }
                   // å¦‚æœè‡ªåŠ¨å¼€å…³æ˜¯å¼€å¯çš„ï¼Œç«‹å³æ›´æ–°å¯ç”¨çš„æ¡ç›®
                   if (this.isAutoToggleLorebookEnabled) {
                       this.startAutoTogglePolling();
                   }
               } else {
                   e.target.value = this.unifiedIndex; // ä¿®å¤ï¼šå¦‚æœè¾“å…¥æ— æ•ˆï¼Œåˆ™æ¢å¤ç»Ÿä¸€åºå·
               }
           });

            // æ–°å¢ï¼šä¸ºè‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦å¤é€‰æ¡†ç»‘å®šç›‘å¬
            document.getElementById('auto-toggle-lorebook-checkbox')?.addEventListener('change', (e) => {
                this.isAutoToggleLorebookEnabled = e.target.checked;
                this.saveAutoToggleState();
                this.showTemporaryMessage(`è‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦å·²${this.isAutoToggleLorebookEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                if (this.isAutoToggleLorebookEnabled) {
                  this.startAutoTogglePolling();
                } else {
                  this.stopAutoTogglePolling();
                }
            });

            // æ–°å¢ï¼šä¸–ç•Œä¹¦é«˜çº§è®¾ç½®ç›¸å…³äº‹ä»¶
            document.getElementById('toggle-worldbook-advanced')?.addEventListener('click', (e) => {
                e.preventDefault();
                const advancedSection = document.getElementById('worldbook-advanced-settings');
                const arrow = document.getElementById('worldbook-advanced-arrow');
                
                if (advancedSection.style.display === 'none') {
                    advancedSection.style.display = 'block';
                    arrow.textContent = 'â–¼';
                } else {
                    advancedSection.style.display = 'none';
                    arrow.textContent = 'â–¶';
                }
            });

            // ä½ç½®é€‰æ‹©æ”¹å˜æ—¶å¯ç”¨/ç¦ç”¨æ·±åº¦è¾“å…¥
            const positionSelects = ['journey-position', 'past-lives-position', 'novel-position'];
            positionSelects.forEach(id => {
                document.getElementById(id)?.addEventListener('change', (e) => {
                    const depthInput = document.getElementById(id.replace('-position', '-depth'));
                    if (depthInput) {
                        if (e.target.value.startsWith('at_depth')) {
                            depthInput.disabled = false;
                        } else {
                            depthInput.disabled = true;
                        }
                    }
                });
            });

            // ä¿å­˜ä¸–ç•Œä¹¦è®¾ç½®
            document.getElementById('save-worldbook-settings')?.addEventListener('click', () => {
                this.saveWorldbookSettings();
                this.showTemporaryMessage('ä¸–ç•Œä¹¦è®¾ç½®å·²ä¿å­˜');
            });

            // æ¢å¤é»˜è®¤è®¾ç½®
            document.getElementById('reset-worldbook-settings')?.addEventListener('click', () => {
                this.resetWorldbookSettings();
                this.loadWorldbookSettings(); // é‡æ–°åŠ è½½UI
                this.showTemporaryMessage('å·²æ¢å¤é»˜è®¤ä¸–ç•Œä¹¦è®¾ç½®');
            });

            document.getElementById('btn-inventory')?.addEventListener('click', () => this.showInventory());
            document.getElementById('btn-relationships')?.addEventListener('click', () => this.showRelationships());
            document.getElementById('btn-world-events')?.addEventListener('click', () => this.showWorldEvents());
            // document.getElementById('btn-variable-editor')?.addEventListener('click', () => this.showVariableEditor()); // å˜é‡ä¿®æ”¹å™¨å·²éšè—
            document.getElementById('btn-guixu-system')?.addEventListener('click', () => this.showGuixuSystem());
            document.getElementById('btn-guixu-space')?.addEventListener('click', () => this.showGuixuSpace());
            // æ€ç»´è¿‡ç¨‹å®¹å™¨çš„ç‚¹å‡»äº‹ä»¶æ”¹ä¸ºheader
            document.getElementById('thinking-process-header')?.addEventListener('click', () => this.toggleThinkingDisplay());
            document.getElementById('btn-settings')?.addEventListener('click', () => this.showSettings());
            document.getElementById('btn-reprocess-variables')?.addEventListener('click', () => this.reprocessVariables());
      
            document.getElementById('btn-gacha-system')?.addEventListener('click', () => this.showGachaSystem());
      
            // å°æ€»ç»“å’Œå¤§æ€»ç»“çš„äº‹ä»¶ç›‘å¬å™¨å·²è¢«ç§»é™¤

            // è®¾ç½®æ¨¡æ€æ¡†å†…çš„æŒ‰é’®äº‹ä»¶
            document.getElementById('btn-command-center-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showCommandCenter();
            });
            document.getElementById('btn-show-extracted-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showExtractedContent();
            });
            document.getElementById('btn-map-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showMap();
            });
            document.getElementById('background-settings-btn')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showBackgroundSettings();
            });
            
            // åŠŸèƒ½å…¥å£çš„ä¸–ç•Œä¹¦ç®¡ç†æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('btn-worldbook-manager-from-settings')?.addEventListener('click', () => {
              this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
              this.showWorldbookManager();
            });

            // æ–°å¢ï¼šåˆ†æ®µè®°å¿†æŒ‰é’®äº‹ä»¶
            document.getElementById('btn-segmented-memory-from-settings')?.addEventListener('click', () => {
                this.isFromSettingsModal = true; // è®¾ç½®æ ‡å¿—ä½
                this.showSegmentedMemoryModal();
            });

            // é¢„è®¾ç®¡ç†æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('btn-presets-manager')?.addEventListener('click', () => {
              this.showWorldbookPresets();
            });

            // æ–°å¢ï¼šä¸ºåˆ†æ®µè®°å¿†é¢„è§ˆçš„æ¡ç›®æ·»åŠ ç‚¹å‡»æŠ˜å /å±•å¼€äº‹ä»¶
            document.getElementById('segmented-memory-modal')?.addEventListener('click', (e) => {
                const header = e.target.closest('.summary-header');
                if (header) {
                    const details = header.nextElementSibling;
                    const arrow = header.querySelector('.summary-arrow');
                    if (details && details.classList.contains('summary-details')) {
                        if (details.style.display === 'none') {
                            details.style.display = 'block';
                            if(arrow) arrow.textContent = 'â–¼';
                        } else {
                            details.style.display = 'none';
                            if(arrow) arrow.textContent = 'â–¶';
                        }
                    }
                }
            });

            // ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢çš„é¢„è®¾æŒ‰é’®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('worldbook-presets-btn')?.addEventListener('click', () => {
              this.isFromWorldbookManager = true; // è®¾ç½®æ ‡å¿—ä½
              this.showWorldbookPresets();
            });

            // æ–‡å­—è®¾ç½®ç›¸å…³äº‹ä»¶ç›‘å¬å™¨
            // æ–‡å­—é¢œè‰²è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('text-color-normal')?.addEventListener('change', (e) => {
              this.textSettings.colors.normal = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-dialogue')?.addEventListener('change', (e) => {
              this.textSettings.colors.dialogue = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-psychology')?.addEventListener('change', (e) => {
              this.textSettings.colors.psychology = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('text-color-scenery')?.addEventListener('change', (e) => {
              this.textSettings.colors.scenery = e.target.value;
              this.applyTextSettings();
              this.saveTextSettings();
            });

            // å•ç‹¬å­—ä½“å¤§å°è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('font-size-normal')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.normal = parseInt(e.target.value);
              document.getElementById('font-size-normal-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-dialogue')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.dialogue = parseInt(e.target.value);
              document.getElementById('font-size-dialogue-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-psychology')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.psychology = parseInt(e.target.value);
              document.getElementById('font-size-psychology-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-size-scenery')?.addEventListener('input', (e) => {
              this.textSettings.fontSizes.scenery = parseInt(e.target.value);
              document.getElementById('font-size-scenery-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });

            // å…¨å±€å­—ä½“å¤§å°è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('font-size-slider')?.addEventListener('input', (e) => {
              this.textSettings.fontSize = parseInt(e.target.value);
              document.getElementById('font-size-value').textContent = e.target.value + 'px';
              this.applyTextSettings();
              this.saveTextSettings();
            });
            document.getElementById('font-family-select')?.addEventListener('change', (e) => {
              if (e.target.value === 'upload_new') {
                // è§¦å‘æ–‡ä»¶é€‰æ‹©
                document.getElementById('font-file-input').click();
                // é‡ç½®é€‰æ‹©æ¡†åˆ°ä¹‹å‰çš„å€¼
                setTimeout(() => {
                  e.target.value = this.textSettings.fontFamily;
                }, 100);
              } else {
                // åº”ç”¨é€‰æ‹©çš„å­—ä½“
                this.textSettings.fontFamily = e.target.value;
                // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“æ ·å¼å·²åŠ è½½
                this.ensureCustomFontLoaded(e.target.value).then(() => {
                  this.applyTextSettings();
                  this.saveTextSettings();
                });
                
                // æ£€æŸ¥æ˜¯å¦ä¸ºè‡ªå®šä¹‰å­—ä½“
                const isCustomFont = this.textSettings.customFonts.some(font => font.family === e.target.value);
                const fontName = isCustomFont ?
                  this.textSettings.customFonts.find(font => font.family === e.target.value).name :
                  e.target.options[e.target.selectedIndex].text;
                
                this.showTemporaryMessage(`å·²åº”ç”¨å­—ä½“: ${fontName}`);
              }
            });
            document.getElementById('font-file-input')?.addEventListener('change', (e) => {
              this.handleFontUpload(e);
            });
            document.getElementById('reset-text-settings-btn')?.addEventListener('click', () => {
              this.resetTextSettings();
            });
            document.getElementById('preview-text-settings-btn')?.addEventListener('click', () => {
              this.previewTextSettings();
            });
            document.getElementById('font-compress-help-btn')?.addEventListener('click', () => {
              this.showFontCompressHelp();
            });
            // ä¸»ç•Œé¢çš„ä¸–ç•Œçº¿å›é¡¾æŒ‰é’®
            document.getElementById('btn-view-journey-main')?.addEventListener('click', () => this.showJourney());
            document.getElementById('btn-view-past-lives-main')?.addEventListener('click', () => this.showPastLives());
            document.getElementById('btn-save-load-manager')?.addEventListener('click', () => this.showSaveLoadManager());
            document.getElementById('btn-novel-mode')?.addEventListener('click', () => this.showNovelMode());
            document.getElementById('btn-clear-all-saves')?.addEventListener('click', () => this.clearAllSaves());

            // æ–°å¢ï¼šå°è¯´æ¨¡å¼ç« èŠ‚å¯¼èˆªå’Œä¹¦ç­¾äº‹ä»¶ç›‘å¬å™¨
            document.getElementById('chapter-select')?.addEventListener('change', (e) => {
              const chapterIndex = parseInt(e.target.value);
              if (!isNaN(chapterIndex)) {
                if (this.novelDisplayMode === 'single') {
                  this.showNovelChapter(chapterIndex);
                } else {
                  // è¿è´¯æ¨¡å¼ä¸‹è·³è½¬åˆ°å¯¹åº”ç« èŠ‚ä½ç½®
                  const anchor = document.getElementById(`chapter-anchor-${chapterIndex}`);
                  if (anchor) {
                    anchor.scrollIntoView({ behavior: 'smooth', block: 'start' });
                  }
                }
              }
            });

            document.getElementById('prev-chapter-btn')?.addEventListener('click', () => this.prevChapter());
            document.getElementById('next-chapter-btn')?.addEventListener('click', () => this.nextChapter());
            document.getElementById('add-bookmark-btn')?.addEventListener('click', () => this.addNovelBookmark());
            document.getElementById('goto-bookmark-btn')?.addEventListener('click', () => this.gotoBookmark());
            document.getElementById('delete-bookmark-btn')?.addEventListener('click', () => this.deleteBookmark());
            document.getElementById('novel-background-btn')?.addEventListener('click', () => this.showNovelBackgroundSettings());

            // æ˜¾ç¤ºæ¨¡å¼åˆ‡æ¢äº‹ä»¶ç›‘å¬å™¨
            document.addEventListener('change', (e) => {
              if (e.target.name === 'novel-display-mode') {
                this.switchNovelDisplayMode(e.target.value);
              }
            });
            document.getElementById('btn-import-save')?.addEventListener('click', () => document.getElementById('import-file-input')?.click());
            document.getElementById('import-file-input')?.addEventListener('change', (e) => this.handleFileImport(e));
            // æ—¶é—´çº¿å¤‡ä»½/æ¢å¤äº‹ä»¶ç›‘å¬å™¨å·²ç§»é™¤ï¼ŒåŠŸèƒ½å·²é›†æˆåˆ°å­˜æ¡£ç³»ç»Ÿä¸­
 
              // ä¸ºå†™å…¥ä¸–ç•Œä¹¦æŒ‰é’®ç»‘å®šç›‘å¬å™¨
             document
              .getElementById('btn-write-journey')
              ?.addEventListener('click', () => this.writeJourneyToLorebook());
            document
              .getElementById('btn-write-past-lives')
              ?.addEventListener('click', () => this.writePastLivesToLorebook());
            document
              .getElementById('btn-write-novel-mode')
              ?.addEventListener('click', () => this.writeNovelModeToLorebook());

            document
              .getElementById('btn-write-character-card')
              ?.addEventListener('click', () => this.writeCharacterCardToLorebook());
            // ä¸ºè‡ªåŠ¨å†™å…¥å¤é€‰æ¡†ç»‘å®šç›‘å¬å™¨ï¼Œå¹¶å¢åŠ çŠ¶æ€ä¿å­˜
            document.getElementById('btn-execute-map-commands')?.addEventListener('click', () => {
               if (this.lastExtractedMapCommands) {
                   this.handleMapUpdateCommand(this.lastExtractedMapCommands);
               } else {
                   this.showTemporaryMessage('æ²¡æœ‰å¯è§£æçš„åœ°å›¾æŒ‡ä»¤ã€‚');
               }
            });
            const autoWriteCheckbox = document.getElementById('auto-write-checkbox');
            if (autoWriteCheckbox) {
              autoWriteCheckbox.addEventListener('change', e => {
                this.isAutoWriteEnabled = e.target.checked;
                this.saveAutoWriteState(this.isAutoWriteEnabled);
                this.showTemporaryMessage(`è‡ªåŠ¨å†™å…¥å†ç¨‹/æ¶Ÿæ¼ªå·²${this.isAutoWriteEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                if (this.isAutoWriteEnabled) {
                  this.startAutoWritePolling();
                } else {
                  this.stopAutoWritePolling();
                }
              });
            }

            // ä¸ºå°è¯´æ¨¡å¼å¤é€‰æ¡†ç»‘å®šç›‘å¬å™¨
            const novelModeCheckbox = document.getElementById('novel-mode-enabled-checkbox');
            if (novelModeCheckbox) {
              novelModeCheckbox.addEventListener('change', e => {
                this.isNovelModeEnabled = e.target.checked;
                this.saveNovelModeState(this.isNovelModeEnabled);
                this.showTemporaryMessage(`å°è¯´æ¨¡å¼è‡ªåŠ¨å†™å…¥å·²${this.isNovelModeEnabled ? 'å¼€å¯' : 'å…³é—­'}`);

                // æ–°é€»è¾‘ï¼šæ­¤å¼€å…³åªæ§åˆ¶è½®è¯¢ï¼Œä¸è§¦å‘UIåˆ·æ–°
                if (this.isNovelModeEnabled) {
                  this.startNovelModeAutoWritePolling();
                } else {
                  this.stopNovelModeAutoWritePolling();
                }

                // æ‰‹åŠ¨æ›´æ–°æ ‡ç­¾æ–‡æœ¬ä»¥æä¾›å³æ—¶åé¦ˆ
                const label = document.querySelector('label[for="novel-mode-enabled-checkbox"]');
                if (label) {
                  label.textContent = `å¼€å¯å°è¯´æ¨¡å¼`; // æ¢å¤åŸå§‹æ–‡æœ¬
                }
                // åˆ·æ–°æ‰“å¼€çš„æ¨¡æ€æ¡†ä»¥æ›´æ–°æŒ‰é’®çŠ¶æ€å’Œæç¤º
                if (document.getElementById('extracted-content-modal').style.display === 'flex') {
                  this.showExtractedContent();
                }
              });
            }

            // æŒ‡ä»¤ä¸­å¿ƒæŒ‰é’®
            document
              .getElementById('btn-execute-commands')
              ?.addEventListener('click', () => this.executePendingActions());
            document.getElementById('btn-clear-commands')?.addEventListener('click', () => this.clearPendingActions());
            document.getElementById('btn-refresh-storage')?.addEventListener('click', () => this.refreshLocalStorage());
            document.getElementById('action-options-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isActionOptionsEnabled = e.target.checked;
                this.saveActionOptionsState();
                this.showTemporaryMessage(`è¡ŒåŠ¨é€‰é¡¹æ˜¾ç¤ºå·²${this.isActionOptionsEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                // é‡æ–°æ¸²æŸ“è¡ŒåŠ¨é€‰é¡¹ä»¥ç«‹å³åæ˜ å˜åŒ–
                this.renderActionOptions(this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', this.lastExtractedVariables || ''));
            });

            document.getElementById('auto-send-action-checkbox')?.addEventListener('change', (e) => {
               this.isActionAutoSend = e.target.checked;
               this.saveActionAutoSendState();
               this.showTemporaryMessage(`è¡ŒåŠ¨é€‰é¡¹ç‚¹å‡»å³å‘é€å·²${this.isActionAutoSend ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            document.getElementById('streaming-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isStreamingEnabled = e.target.checked;
                this.saveStreamingState();
                this.showTemporaryMessage(`æµå¼å“åº”å·²${this.isStreamingEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            document.getElementById('format-validation-enabled-checkbox')?.addEventListener('change', (e) => {
                this.isFormatValidationEnabled = e.target.checked;
                this.saveFormatValidationState();
                this.showTemporaryMessage(`æ ¼å¼å®¡æŸ¥å·²${this.isFormatValidationEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºå›è½¦å‘é€å¤é€‰æ¡†ç»‘å®šäº‹ä»¶
            document.getElementById('enter-send-checkbox')?.addEventListener('change', (e) => {
                this.isEnterSendEnabled = e.target.checked;
                this.saveEnterSendState();
                this.showTemporaryMessage(`å›è½¦å‘é€å·²${this.isEnterSendEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºé”®ç›˜å¿«æ·é”®å¤é€‰æ¡†ç»‘å®šäº‹ä»¶
            document.getElementById('keyboard-shortcuts-checkbox')?.addEventListener('change', (e) => {
                this.isKeyboardShortcutsEnabled = e.target.checked;
                this.saveKeyboardShortcutsState();
                this.showTemporaryMessage(`é”®ç›˜å¿«æ·é”®å·²${this.isKeyboardShortcutsEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºæ‰‹æœºè¾“å…¥æ¡†é€‚é…å¤é€‰æ¡†ç»‘å®šäº‹ä»¶
            document.getElementById('mobile-input-adapt-checkbox')?.addEventListener('change', (e) => {
                this.isMobileInputAdaptEnabled = e.target.checked;
                this.saveMobileInputAdaptState();
                this.showTemporaryMessage(`æ‰‹æœºè¾“å…¥æ¡†é€‚é…å·²${this.isMobileInputAdaptEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
                
                // å¦‚æœå…³é—­äº†é€‚é…ï¼Œéœ€è¦é‡ç½®è¾“å…¥æ¡†ä½ç½®
                if (!this.isMobileInputAdaptEnabled && this.floatingInputContainer) {
                    this.resetInputPosition();
                }
                
                // é‡æ–°åˆå§‹åŒ–é”®ç›˜å¤„ç†é€»è¾‘
                this.reinitializeInputKeyboardHandling();
            });

            // æ–°å¢ï¼šä¸ºé”®ç›˜å¿«æ·é”®ä¸‰è§’æŒ‰é’®ç»‘å®šç‚¹å‡»äº‹ä»¶
            document.getElementById('keyboard-shortcuts-toggle')?.addEventListener('click', () => {
                this.toggleKeyboardShortcutsDetails();
            });

            // æ–°å¢ï¼šä¸ºå¿«é€Ÿå‘é€è¾“å…¥æ¡†ç»‘å®šå›è½¦é”®äº‹ä»¶
            document.getElementById('quick-send-input')?.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !e.shiftKey && this.isEnterSendEnabled) {
                    e.preventDefault(); // é˜»æ­¢é»˜è®¤çš„æ¢è¡Œè¡Œä¸º
                    this.executeQuickSend();
                }
            });

            // é”®ç›˜å¤„ç†åˆå§‹åŒ–å·²ç§»è‡³çŠ¶æ€åŠ è½½å®Œæˆåæ‰§è¡Œï¼ˆå»¶è¿Ÿåˆå§‹åŒ–ï¼‰
            console.log('[å½’å¢Ÿè¾“å…¥æ³•] é”®ç›˜å¤„ç†å°†åœ¨çŠ¶æ€åŠ è½½å®Œæˆååˆå§‹åŒ–');

 
              document
                .querySelectorAll('.modal-close-btn')
                .forEach(btn => btn.addEventListener('click', (e) => this.handleModalClose(e)));
  
              // æ–°å¢ï¼šä¸ºäººç‰©å…³ç³»é¢æ¿çš„è‡ªå®šä¹‰å…³é—­æŒ‰é’®æ·»åŠ å§”æ‰˜äº‹ä»¶
              // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ç¡®ä¿åŠ¨æ€æ·»åŠ çš„æŒ‰é’®ä¹Ÿèƒ½è¢«ç›‘å¬åˆ°
              document.body.addEventListener('click', (e) => {
                if (e.target.matches('.relationships-close-btn') && e.target.closest('#relationships-modal')) {
                    window.GuixuManager.closeModal('relationships-modal');
                }
              });

              // æ–°å¢ï¼šä¸ºè¾“å…¥ç¼“å­˜æ¨¡æ€æ¡†çš„å†…å®¹åˆ—è¡¨æ·»åŠ äº‹ä»¶å§”æ‰˜
              document.getElementById('input-cache-modal')?.addEventListener('click', e => {
                  if (e.target && e.target.closest('.input-cache-item')) {
                      const item = e.target.closest('.input-cache-item');
                      const content = item.dataset.content;
                      if (content) {
                          this.applyInputFromHistory(content);
                      }
                  }
              });
            document.querySelectorAll('.modal-overlay').forEach(overlay => {
              overlay.addEventListener('click', e => {
                if (e.target === overlay) this.handleModalClose(e);
              });
            });

            // äº‹ä»¶å§”æ‰˜ï¼šèƒŒåŒ…å†…çš„ç‚¹å‡»äº‹ä»¶
            const inventoryModalBody = document.querySelector('#inventory-modal .modal-body');
            if (inventoryModalBody) {
              inventoryModalBody.addEventListener('click', e => {
                if (e.target.classList.contains('item-equip-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  // æ–°å¢ï¼šå¤„ç†åŠŸæ³•è£…å¤‡æŒ‰é’®
                  if (e.target.dataset.equipType === 'zhuxiu') {
                    this.equipItem(itemData, category, e.target, 'zhuxiuGongfa');
                  } else if (e.target.dataset.equipType === 'fuxiu') {
                    this.equipItem(itemData, category, e.target, 'fuxiuXinfa');
                  } else {
                    this.equipItem(itemData, category, e.target);
                  }
                } else if (e.target.classList.contains('item-use-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  this.useItem(itemData, e.target);
                } else if (e.target.classList.contains('item-unequip-btn')) {
                  const slotId = e.target.dataset.slotId;
                  const slotElement = document.getElementById(slotId);
                  if (slotElement) {
                    this.unequipItem(slotId, slotElement, true, true); // ä»èƒŒåŒ…å¸è½½ï¼Œéœ€è¦åˆ·æ–°èƒŒåŒ…UI
                  }
                } else if (e.target.classList.contains('item-discard-btn')) {
                  const itemElement = e.target.closest('.inventory-item');
                  const itemData = JSON.parse(itemElement.dataset.itemDetails.replace(/'/g, "'") || '{}');
                  const category = itemElement.dataset.category;
                  this.discardItem(itemData, category, itemElement);
                }
              });
            }

            // äº‹ä»¶å§”æ‰˜ï¼šå·¦ä¾§è£…å¤‡é¢æ¿çš„äº‹ä»¶
            const characterPanel = document.querySelector('.character-panel');
            if (characterPanel) {
              // æ‚¬æµ®æ˜¾ç¤ºTooltip
              characterPanel.addEventListener('mouseover', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot && slot.classList.contains('equipped')) {
                  this.showEquipmentTooltip(slot, e);
                }
              });
              characterPanel.addEventListener('mouseout', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot) {
                  this.hideEquipmentTooltip();
                }
              });
              // ç‚¹å‡»å¸è½½è£…å¤‡
              characterPanel.addEventListener('click', e => {
                const slot = e.target.closest('.equipment-slot');
                if (slot && slot.classList.contains('equipped')) {
                  this.unequipItem(slot.id, slot, true, false); // ä»ä¸»é¢æ¿å¸è½½ï¼Œä¸éœ€è¦å¼¹å‡ºèƒŒåŒ…
                }
              });
            }

            // ä¸ºå¿«é€Ÿå‘é€æŒ‰é’®ç»‘å®šäº‹ä»¶
            document.getElementById('btn-quick-send')?.addEventListener('click', () => this.executeQuickSend());

            // --- æ–°å¢ï¼šä¸ºè¾“å…¥ç¼“å­˜ç»‘å®šäº‹ä»¶ ---
            document.getElementById('btn-show-cache')?.addEventListener('click', () => this.showInputCacheModal());

            // æ–°å¢ï¼šä¸ºè¡ŒåŠ¨é€‰é¡¹å®¹å™¨ç»‘å®šäº‹ä»¶å§”æ‰˜
            document.getElementById('action-options-container')?.addEventListener('click', (e) => {
                if (e.target && e.target.classList.contains('action-option-btn')) {
                    const actionText = e.target.dataset.actionText;
                    if (actionText) {
                        if (this.isActionAutoSend) {
                            // å¼€å¯æ—¶ï¼Œç›´æ¥ç‚¹å‡»å‘é€
                            this.handleAction(actionText);
                        } else {
                            // å…³é—­æ—¶ï¼ŒåŠ å…¥è¾“å…¥æ¡†
                            const input = document.getElementById('quick-send-input');
                            if (input) {
                                input.value = actionText;
                            }

             // --- æ ¸å¿ƒä¿®æ”¹ï¼šåœ¨è¿™é‡Œå¤„ç†æš‚å­˜çš„ä¼™ä¼´ ---
            // æ­¤æ®µé€»è¾‘å·²è¢«ç§»è‡³handleJoinWorldä¸­è¿›è¡Œä¹è§‚æ›´æ–°ï¼Œæ­¤å¤„ä¸å†éœ€è¦ï¼Œæ•…åˆ é™¤
            // if (this.pendingCompanionJoin) { ... }

            // æ ¸å¿ƒä¿®å¤ï¼šç»Ÿä¸€å¤„ç†æ‰€æœ‰å·²æ¶ˆè€—çš„è¡æ¢¦å°˜æŒ‡ä»¤
            const consumedGachaActions = this.pendingActions.filter(cmd => cmd.action === 'acquire_item_talent' || cmd.action === 'join_world');
            if (consumedGachaActions.length > 0) {
                consumedGachaActions.forEach(cmd => {
                    if (cmd.action === 'join_world') {
                        // è§’è‰²åŠ å…¥ activeCompanions
                        if (!this.gachaState.activeCompanions.some(c => c.id === cmd.itemData.id)) {
                            this.gachaState.activeCompanions.push({ id: cmd.itemData.id, name: cmd.itemData.åç§°, rarity: cmd.itemData.ç¨€æœ‰åº¦ });
                        }
                    } else {
                        // é“å…·/å¤©èµ‹åŠ å…¥ activatedItems
                        if (!this.gachaState.activatedItems.includes(cmd.itemData.id)) {
                            this.gachaState.activatedItems.push(cmd.itemData.id);
                        }
                    }
                });
                this.saveGachaState(); // åœ¨å¾ªç¯å¤„ç†å®Œæ‰€æœ‰é¡¹ç›®åï¼Œç»Ÿä¸€ä¿å­˜ä¸€æ¬¡çŠ¶æ€
            }

            // --- æ–°å¢ï¼šä¿®å¤ä¼™ä¼´åˆ—è¡¨ä¸åˆ·æ–°çš„BUG ---
            if (document.getElementById('gacha-modal').style.display === 'flex') {
                this.renderSummonTab();
            }

                        }
                    }
                }
            });


            // æ–°å¢ï¼šä¸ºè‡ªåŠ¨å­˜æ¡£å¤é€‰æ¡†ç»‘å®šç›‘å¬
            document.getElementById('auto-save-checkbox')?.addEventListener('change', (e) => {
                this.isAutoSaveEnabled = e.target.checked;
                this.saveAutoSaveState();
                this.showTemporaryMessage(`è‡ªåŠ¨å­˜æ¡£å·²${this.isAutoSaveEnabled ? 'å¼€å¯' : 'å…³é—­'}`);
            });

            // æ–°å¢ï¼šä¸ºè‡ªåŠ¨åŒ–ç³»ç»Ÿä¿®å‰ªæ¨¡æ€æ¡†çš„æŒ‰é’®ç»‘å®šäº‹ä»¶
            document.getElementById('btn-confirm-trim')?.addEventListener('click', () => {
                const indexInput = document.getElementById('trim-journey-index-input');
                const index = indexInput ? parseInt(indexInput.value, 10) : this.unifiedIndex;
                if (!isNaN(index) && index > 0) {
                    this.trimJourneyAutomation(index);
                } else {
                    this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„åºå·ã€‚');
                }
            });

            document.getElementById('btn-cancel-trim')?.addEventListener('click', () => {
                this.closeModal('trim-journey-modal');
            });

            // æ–°å¢ï¼šäººç‰©å…³ç³»æ’åºå’Œäº²å¯†å…³ç³»äº‹ä»¶å§”æ‰˜
            document.addEventListener('change', (e) => {
              if (e.target && e.target.id === 'relationship-sort') {
                this.handleRelationshipSort(e.target.value);
              }
            });

            document.addEventListener('click', (e) => {
              // å¤„ç†æ ‡ç­¾é¡µç‚¹å‡»
              if (e.target && e.target.closest('.tab-btn')) {
                const tabBtn = e.target.closest('.tab-btn');
                const tabType = tabBtn.dataset.tab;
                if (tabType) {
                  this.handleTabClick(tabType);
                }
              }
              
              // å¤„ç†äº²å¯†å…³ç³»åˆ‡æ¢æŒ‰é’®ï¼ˆä¿ç•™å…¼å®¹æ€§ï¼‰
              if (e.target && e.target.id === 'toggle-intimate-mode') {
                this.toggleIntimateMode();
              }
              
              // å¤„ç†äººç‰©åå­—ä¸‰è¿å‡» - åªå…è®¸ç‚¹å‡»åå­—è§¦å‘äº²å¯†å…³ç³»
              if (e.target && e.target.closest('.character-name')) {
                const nameElement = e.target.closest('.character-name');
                const card = nameElement.closest('.relationship-card');
                const characterName = card ? card.dataset.characterName : null;
                if (characterName) {
                  this.handleTripleClick(characterName, e);
                }
              }
            });

            // æ–°å¢ï¼šç»‘å®šé”®ç›˜å¿«æ·é”®
            this.bindKeyboardShortcuts();

            this.listenersBound = true; // è®¾ç½®æ ‡å¿—ä½ï¼Œç¡®ä¿æ­¤ä»£ç å—åªè¿è¡Œä¸€æ¬¡


            // æ–°å¢ï¼šä¸ºå­˜æ¡£/è¯»æ¡£æ¨¡æ€æ¡†æ·»åŠ ç»Ÿä¸€çš„äº‹ä»¶å§”æ‰˜
            const saveLoadModalBody = document.querySelector('#save-load-modal .modal-body');
            if (saveLoadModalBody) {
                saveLoadModalBody.addEventListener('click', (e) => {
                    const target = e.target;
                    const slotDiv = target.closest('.save-slot');
                    if (!slotDiv) return;

                    const slotId = slotDiv.dataset.slotId;
                    if (!slotId) return;

                    if (target.classList.contains('btn-save-slot')) {
                        this.saveGame(slotId);
                    } else if (target.classList.contains('btn-load-slot')) {
                        this.loadGame(slotId);
                    } else if (target.classList.contains('btn-delete-slot')) {
                        this.deleteSave(slotId);
                    } else if (target.classList.contains('btn-export-slot')) {
                        this.exportSave(slotId);
                    }
                });
            }
 
            // ç»‘å®šèƒŒæ™¯å›¾è®¾ç½®æ¨¡æ€æ¡†ä¸­çš„é™æ€äº‹ä»¶
            this.bindBackgroundSettingsListeners();
          },
 
            // --- Modal Control ---
           showSettings() {
             this.openModal('settings-modal');
             // åˆå§‹åŒ–é€æ˜åº¦æ»‘å—
             this.initOpacitySlider();
             // åˆå§‹åŒ–æ–‡å­—è®¾ç½®UI
             this.updateTextSettingsUI();
             this.updateCustomFontsList();
             // ç¡®ä¿å½“å‰å­—ä½“æ ·å¼ç«‹å³ç”Ÿæ•ˆ
             this.applyTextSettings();
             // åˆå§‹åŒ–ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€
             this.initWorldbookControlsInSettings();
           },

           // æ–°å¢ï¼šåˆå§‹åŒ–é€æ˜åº¦æ»‘å—
           initOpacitySlider() {
             const slider = document.getElementById('opacity-slider');
             const valueDisplay = document.getElementById('opacity-value');
             
             if (slider && valueDisplay) {
               // è®¾ç½®å½“å‰å€¼
               slider.value = this.mainOpacity;
               valueDisplay.textContent = `å½“å‰è®¾ç½®: ${this.mainOpacity}%`;
               
               // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
               slider.addEventListener('input', (e) => {
                 this.updateOpacity(parseInt(e.target.value));
               });
             }
           },

           // æ–°å¢ï¼šæ›´æ–°é€æ˜åº¦
           updateOpacity(value) {
             this.mainOpacity = value;
             const valueDisplay = document.getElementById('opacity-value');
             if (valueDisplay) {
               valueDisplay.textContent = `å½“å‰è®¾ç½®: ${value}%`;
             }
             
             // åº”ç”¨é€æ˜åº¦åˆ°ä¸»ç•Œé¢
             this.applyOpacityToMainInterface(value);
             
             // ä¿å­˜è®¾ç½®
             this.saveOpacitySettings();
           },

           // æ–°å¢ï¼šåº”ç”¨é€æ˜åº¦åˆ°ä¸»ç•Œé¢
           applyOpacityToMainInterface(opacity) {
             // å°†é€æ˜åº¦å€¼è½¬æ¢ä¸º0-1çš„èŒƒå›´
             const opacityValue = opacity / 100;
             
             // é€šè¿‡åŠ¨æ€åˆ›å»ºCSSè§„åˆ™æ¥æ§åˆ¶ä¼ªå…ƒç´ çš„é€æ˜åº¦
             let styleElement = document.getElementById('dynamic-overlay-style');
             if (!styleElement) {
               styleElement = document.createElement('style');
               styleElement.id = 'dynamic-overlay-style';
               document.head.appendChild(styleElement);
             }
             
             // åˆ›å»ºCSSè§„åˆ™æ¥æ§åˆ¶ä¼ªå…ƒç´ çš„é€æ˜åº¦
             styleElement.textContent = `
               .guixu-root-container::before {
                 content: '';
                 position: absolute;
                 top: 0;
                 left: 0;
                 width: 100%;
                 height: 100%;
                 background: rgba(26, 26, 46, ${opacityValue}) !important;
                 pointer-events: none;
                 z-index: -1;
               }
             `;
             
             console.log(`[å½’å¢Ÿé€æ˜åº¦] è®¾ç½®è¦†ç›–å±‚é€æ˜åº¦ä¸º: ${opacityValue}`);
           },

           // æ–°å¢ï¼šä¿å­˜é€æ˜åº¦è®¾ç½®
           saveOpacitySettings() {
             try {
               localStorage.setItem('guixu_main_opacity', this.mainOpacity.toString());
             } catch (e) {
               console.error('ä¿å­˜é€æ˜åº¦è®¾ç½®å¤±è´¥:', e);
             }
           },

           // æ–°å¢ï¼šåŠ è½½é€æ˜åº¦è®¾ç½®
           loadOpacitySettings() {
             try {
               const saved = localStorage.getItem('guixu_main_opacity');
               if (saved) {
                 this.mainOpacity = parseInt(saved);
                 this.applyOpacityToMainInterface(this.mainOpacity);
               }
             } catch (e) {
               console.error('åŠ è½½é€æ˜åº¦è®¾ç½®å¤±è´¥:', e);
               this.mainOpacity = 100; // é»˜è®¤å€¼
             }
           },

           // --- æ–°å¢ï¼šæ–‡å­—è®¾ç½®ç›¸å…³å‡½æ•° ---
           // åº”ç”¨æ–‡å­—è®¾ç½®åˆ°é¡µé¢
           async applyTextSettings() {
             try {
               // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“çš„CSSæ ·å¼å­˜åœ¨
               await this.ensureCustomFontsLoaded();
               
               // ä¼˜åŒ–æ€§èƒ½ï¼šæŸ¥æ‰¾ç°æœ‰æ ·å¼æ ‡ç­¾ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»ºï¼Œå¦åˆ™ç›´æ¥æ›´æ–°å†…å®¹
               let style = document.getElementById('guixu-text-settings-style');
               if (!style) {
                 style = document.createElement('style');
                 style.id = 'guixu-text-settings-style';
                 document.head.appendChild(style);
               }
               
               style.textContent = `
                 .game-text-container {
                   color: ${this.textSettings.colors.normal} !important;
                   font-size: ${this.textSettings.fontSizes?.normal || this.textSettings.fontSize}px !important;
                   font-family: ${this.textSettings.fontFamily} !important;
                 }
                 .text-language {
                   color: ${this.textSettings.colors.dialogue} !important;
                   font-size: ${this.textSettings.fontSizes?.dialogue || this.textSettings.fontSize}px !important;
                   font-style: italic;
                 }
                 .text-psychology {
                   color: ${this.textSettings.colors.psychology} !important;
                   font-size: ${this.textSettings.fontSizes?.psychology || this.textSettings.fontSize}px !important;
                   font-style: italic;
                   opacity: 0.8;
                 }
                 .text-scenery {
                   color: ${this.textSettings.colors.scenery} !important;
                   font-size: ${this.textSettings.fontSizes?.scenery || this.textSettings.fontSize}px !important;
                 }
                 /* ç¡®ä¿æ­£æ–‡å†…å®¹ä½¿ç”¨æ­£ç¡®çš„å­—ä½“å¤§å° - ä¿®å¤æ­£æ–‡å­—ä½“å¤§å°æ— æ³•è°ƒèŠ‚çš„é—®é¢˜ */
                 .game-text-container,
                 .game-text-container > *:not(.text-language):not(.text-psychology):not(.text-scenery),
                 .game-text-container p,
                 .game-text-container div:not([class*="text-"]) {
                   font-size: ${this.textSettings.fontSizes?.normal || this.textSettings.fontSize}px !important;
                 }
               `;
               
               // å¼ºåˆ¶åˆ·æ–°é¡µé¢ä¸Šçš„æ–‡å­—æ˜¾ç¤º
               this.refreshTextDisplay();
               
               console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²åº”ç”¨æ–‡å­—è®¾ç½®ï¼Œå½“å‰å­—ä½“:', this.textSettings.fontFamily);
             } catch (e) {
               console.error('åº”ç”¨æ–‡å­—è®¾ç½®å¤±è´¥:', e);
             }
           },

           // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“å·²åŠ è½½
           async ensureCustomFontsLoaded() {
             try {
               const loadPromises = this.textSettings.customFonts.map(async (font) => {
                 const existingStyle = document.getElementById(`font-style-${font.hash}`);
                 if (!existingStyle && font.cacheKey) {
                   try {
                     // å¦‚æœå­—ä½“æ ·å¼ä¸å­˜åœ¨ï¼Œå°è¯•ä»ç¼“å­˜é‡æ–°åŠ è½½
                     const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey);
                     const style = document.createElement('style');
                     style.id = `font-style-${font.hash}`;
                     style.textContent = `
                       @font-face {
                         font-family: ${font.family};
                         src: url(${cachedFont.data});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);
                     console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] é‡æ–°åŠ è½½å­—ä½“æ ·å¼:', font.name);
                     return true;
                   } catch (error) {
                     console.warn('[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ— æ³•é‡æ–°åŠ è½½å­—ä½“:', font.name, error);
                     return false;
                   }
                 }
                 return true;
               });
               
               await Promise.all(loadPromises);
               console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ‰€æœ‰è‡ªå®šä¹‰å­—ä½“æ£€æŸ¥å®Œæˆ');
             } catch (e) {
               console.error('ç¡®ä¿è‡ªå®šä¹‰å­—ä½“åŠ è½½å¤±è´¥:', e);
             }
           },

           // å¼ºåˆ¶åˆ·æ–°æ–‡å­—æ˜¾ç¤º
           refreshTextDisplay() {
             try {
               // æ‰¾åˆ°æ‰€æœ‰æ–‡å­—å®¹å™¨å¹¶å¼ºåˆ¶é‡æ–°æ¸²æŸ“
               const textContainers = document.querySelectorAll('.game-text-container');
               textContainers.forEach(container => {
                 // è§¦å‘é‡æ–°æ¸²æŸ“
                 const display = container.style.display;
                 container.style.display = 'none';
                 container.offsetHeight; // å¼ºåˆ¶é‡æ’
                 container.style.display = display;
               });

               // åˆ·æ–°æ‰€æœ‰æ–‡å­—æ ·å¼å…ƒç´ 
               const textElements = document.querySelectorAll('.text-language, .text-psychology, .text-scenery');
               textElements.forEach(element => {
                 // å¼ºåˆ¶é‡æ–°åº”ç”¨æ ·å¼
                 const className = element.className;
                 element.className = '';
                 element.offsetHeight; // å¼ºåˆ¶é‡æ’
                 element.className = className;
               });

               console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²åˆ·æ–°æ–‡å­—æ˜¾ç¤º');
             } catch (e) {
               console.error('åˆ·æ–°æ–‡å­—æ˜¾ç¤ºå¤±è´¥:', e);
             }
           },

           // ä¿å­˜æ–‡å­—è®¾ç½®
           saveTextSettings() {
             try {
               localStorage.setItem('guixu_text_settings', JSON.stringify(this.textSettings));
               console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²ä¿å­˜æ–‡å­—è®¾ç½®');
             } catch (e) {
               console.error('ä¿å­˜æ–‡å­—è®¾ç½®å¤±è´¥:', e);
             }
           },

           // åŠ è½½æ–‡å­—è®¾ç½®
           loadTextSettings() {
             try {
               const saved = localStorage.getItem('guixu_text_settings');
               if (saved) {
                 const settings = JSON.parse(saved);
                 this.textSettings = { ...this.textSettings, ...settings };

                 // åŠ è½½å¹¶åº”ç”¨è‡ªå®šä¹‰å­—ä½“ï¼ˆä»IndexedDBç¼“å­˜ï¼‰
                 if (this.textSettings.customFonts && this.textSettings.customFonts.length > 0) {
                   // ä½¿ç”¨Promise.allç¡®ä¿æ‰€æœ‰å­—ä½“éƒ½åŠ è½½å®Œæˆ
                   const fontLoadPromises = this.textSettings.customFonts.map(async (font) => {
                     try {
                       if (font.cacheKey) {
                         // æ–°ç‰ˆæœ¬ï¼šä»IndexedDBåŠ è½½
                         const cachedFont = await this.loadFontFromIndexedDB(font.cacheKey);
                         
                         // ç§»é™¤å¯èƒ½å­˜åœ¨çš„æ—§æ ·å¼
                         const oldStyle = document.getElementById(`font-style-${font.hash}`);
                         if (oldStyle) {
                           oldStyle.remove();
                         }
                         
                         const style = document.createElement('style');
                         style.id = `font-style-${font.hash}`;
                         style.textContent = `
                           @font-face {
                             font-family: ${font.family};
                             src: url(${cachedFont.data});
                             font-display: swap;
                           }
                         `;
                         document.head.appendChild(style);
                         console.log(`[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²ä»ç¼“å­˜åŠ è½½å­—ä½“: ${font.name}`);
                         return true;
                       } else if (font.data) {
                         // æ—§ç‰ˆæœ¬å…¼å®¹ï¼šç›´æ¥ä½¿ç”¨ä¿å­˜çš„æ•°æ®
                         const style = document.createElement('style');
                         style.id = `font-style-${font.hash || 'legacy'}`;
                         style.textContent = `
                           @font-face {
                             font-family: ${font.family};
                             src: url(${font.data});
                             font-display: swap;
                           }
                         `;
                         document.head.appendChild(style);
                         console.log(`[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²åŠ è½½å­—ä½“ï¼ˆå…¼å®¹æ¨¡å¼ï¼‰: ${font.name}`);
                         return true;
                       }
                     } catch (error) {
                       console.warn(`[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ— æ³•åŠ è½½å­—ä½“ ${font.name}:`, error);
                       return false;
                     }
                   });

                   // ç­‰å¾…æ‰€æœ‰å­—ä½“åŠ è½½å®Œæˆåå†åº”ç”¨è®¾ç½®
                   Promise.all(fontLoadPromises).then((results) => {
                     // ç§»é™¤åŠ è½½å¤±è´¥çš„å­—ä½“
                     this.textSettings.customFonts = this.textSettings.customFonts.filter((font, index) => results[index]);
                     
                     // åº”ç”¨æ–‡å­—è®¾ç½®
                     this.updateTextSettingsUI();
                     this.applyTextSettings();
                     console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ‰€æœ‰å­—ä½“åŠ è½½å®Œæˆï¼Œå·²åº”ç”¨è®¾ç½®');
                   });
                 } else {
                   // æ²¡æœ‰è‡ªå®šä¹‰å­—ä½“ï¼Œç›´æ¥åº”ç”¨è®¾ç½®
                   this.updateTextSettingsUI();
                   this.applyTextSettings();
                 }
               } else {
                 // æ²¡æœ‰ä¿å­˜çš„è®¾ç½®ï¼Œä½¿ç”¨é»˜è®¤è®¾ç½®
                 this.updateTextSettingsUI();
                 this.applyTextSettings();
               }
               console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²åŠ è½½æ–‡å­—è®¾ç½®');
             } catch (e) {
               console.error('åŠ è½½æ–‡å­—è®¾ç½®å¤±è´¥:', e);
               // å‡ºé”™æ—¶ä¹Ÿè¦åº”ç”¨é»˜è®¤è®¾ç½®
               this.updateTextSettingsUI();
               this.applyTextSettings();
             }
           },

           // æ›´æ–°æ–‡å­—è®¾ç½®UI
           updateTextSettingsUI() {
             try {
               const normalInput = document.getElementById('text-color-normal');
               const dialogueInput = document.getElementById('text-color-dialogue');
               const psychologyInput = document.getElementById('text-color-psychology');
               const sceneryInput = document.getElementById('text-color-scenery');
               const fontSizeSlider = document.getElementById('font-size-slider');
               const fontSizeValue = document.getElementById('font-size-value');
               const fontFamilySelect = document.getElementById('font-family-select');

               if (normalInput) normalInput.value = this.textSettings.colors.normal;
               if (dialogueInput) dialogueInput.value = this.textSettings.colors.dialogue;
               if (psychologyInput) psychologyInput.value = this.textSettings.colors.psychology;
               if (sceneryInput) sceneryInput.value = this.textSettings.colors.scenery;
               if (fontSizeSlider) fontSizeSlider.value = this.textSettings.fontSize;
               if (fontSizeValue) fontSizeValue.textContent = this.textSettings.fontSize + 'px';
               
               if (fontFamilySelect) {
                 // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†ï¼ŒåŒ…å«è‡ªå®šä¹‰å­—ä½“
                 this.updateFontFamilyOptions();
                 fontFamilySelect.value = this.textSettings.fontFamily;
               }
             } catch (e) {
               console.error('æ›´æ–°æ–‡å­—è®¾ç½®UIå¤±è´¥:', e);
             }
           },

           // æ–°å¢ï¼šåˆå§‹åŒ–è®¾ç½®ç•Œé¢ä¸­çš„ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€
           initWorldbookControlsInSettings() {
             try {
               // åˆå§‹åŒ–ç»Ÿä¸€åºå·è¾“å…¥æ¡†
               const unifiedIndexInput = document.getElementById('unified-index-input');
               if (unifiedIndexInput) {
                 unifiedIndexInput.value = this.unifiedIndex;
               }

               // åˆå§‹åŒ–è‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦å¤é€‰æ¡†
               const autoToggleCheckbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (autoToggleCheckbox) {
                 autoToggleCheckbox.checked = this.isAutoToggleLorebookEnabled;
               }

               // åˆå§‹åŒ–é¢„è®¾æ˜¾ç¤º
               this.updatePresetsInSettings();

               console.log('[å½’å¢Ÿè®¾ç½®] å·²åˆå§‹åŒ–ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€');
             } catch (e) {
               console.error('åˆå§‹åŒ–ä¸–ç•Œä¹¦æ§åˆ¶çŠ¶æ€å¤±è´¥:', e);
             }
           },

           // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†é€‰é¡¹
           updateFontFamilyOptions() {
             const fontFamilySelect = document.getElementById('font-family-select');
             if (!fontFamilySelect) return;

             // ä¿å­˜å½“å‰é€‰æ‹©çš„å€¼
             const currentValue = fontFamilySelect.value;

             // æ¸…ç©ºç°æœ‰é€‰é¡¹
             fontFamilySelect.innerHTML = '';

             // æ·»åŠ é¢„è®¾å­—ä½“é€‰é¡¹
             const presetFonts = [
               { value: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif", text: "é»˜è®¤å­—ä½“" },
               { value: "'Microsoft YaHei', sans-serif", text: "å¾®è½¯é›…é»‘" },
               { value: "'SimSun', serif", text: "å®‹ä½“" },
               { value: "'KaiTi', serif", text: "æ¥·ä½“" },
               { value: "'FangSong', serif", text: "ä»¿å®‹" },
               { value: "'Arial', sans-serif", text: "Arial" },
               { value: "'Times New Roman', serif", text: "Times New Roman" }
             ];

             presetFonts.forEach(font => {
               const option = document.createElement('option');
               option.value = font.value;
               option.textContent = font.text;
               fontFamilySelect.appendChild(option);
             });

             // æ·»åŠ åˆ†éš”çº¿ï¼ˆå¦‚æœæœ‰è‡ªå®šä¹‰å­—ä½“ï¼‰
             if (this.textSettings.customFonts.length > 0) {
               const separator = document.createElement('option');
               separator.disabled = true;
               separator.textContent = '--- è‡ªå®šä¹‰å­—ä½“ ---';
               fontFamilySelect.appendChild(separator);

               // æ·»åŠ è‡ªå®šä¹‰å­—ä½“é€‰é¡¹
               this.textSettings.customFonts.forEach(font => {
                 const option = document.createElement('option');
                 option.value = font.family;
                 option.textContent = font.name;
                 fontFamilySelect.appendChild(option);
               });
             }

             // æ·»åŠ ä¸Šä¼ æ–°å­—ä½“é€‰é¡¹
             const uploadOption = document.createElement('option');
             uploadOption.value = 'upload_new';
             uploadOption.textContent = '+ ä¸Šä¼ æ–°å­—ä½“';
             fontFamilySelect.appendChild(uploadOption);

             // æ¢å¤ä¹‹å‰çš„é€‰æ‹©
             if (currentValue && currentValue !== 'upload_new') {
               fontFamilySelect.value = currentValue;
             }
           },

           // é‡ç½®æ–‡å­—è®¾ç½®
           resetTextSettings() {
             this.textSettings = {
               colors: {
                 normal: '#e8dcc6',
                 dialogue: '#ff1493',
                 psychology: '#808080',
                 scenery: '#98fb98'
               },
               fontSize: 14,
               fontFamily: "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif",
               customFonts: []
             };
             this.updateTextSettingsUI();
             this.applyTextSettings();
             this.saveTextSettings();
             this.showTemporaryMessage('æ–‡å­—è®¾ç½®å·²é‡ç½®ä¸ºé»˜è®¤å€¼');
           },

           // é¢„è§ˆæ–‡å­—è®¾ç½®æ•ˆæœ
           previewTextSettings() {
             const previewText = `
               <div style="padding: 15px; background: rgba(0,0,0,0.8); border: 1px solid #c9aa71; border-radius: 5px; margin: 10px 0;">
                 <div style="color: #c9aa71; font-size: 14px; margin-bottom: 10px;">æ–‡å­—æ•ˆæœé¢„è§ˆï¼š</div>
                 <div class="text-language">è¿™æ˜¯å¯¹è¯æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</div>
                 <div class="text-psychology">è¿™æ˜¯å¿ƒç†æ´»åŠ¨æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</div>
                 <div class="text-scenery">è¿™æ˜¯æ™¯ç‰©æå†™æ–‡å­—çš„æ•ˆæœé¢„è§ˆ</div>
               </div>
             `;
             
             // åˆ›å»ºé¢„è§ˆæ¨¡æ€æ¡†
             const modal = document.createElement('div');
             modal.className = 'modal-overlay';
             modal.style.display = 'flex';
             modal.style.zIndex = '2002';
             modal.innerHTML = `
               <div class="modal-content" style="max-width: 500px;">
                 <div class="modal-header">
                   <h2 class="modal-title">æ–‡å­—æ•ˆæœé¢„è§ˆ</h2>
                   <button class="modal-close-btn">&times;</button>
                 </div>
                 <div class="modal-body">
                   ${previewText}
                   <div style="text-align: center; margin-top: 15px;">
                     <button class="interaction-btn" onclick="this.closest('.modal-overlay').remove()">å…³é—­é¢„è§ˆ</button>
                   </div>
                 </div>
               </div>
             `;
             
             document.body.appendChild(modal);
             
             // ç»‘å®šå…³é—­äº‹ä»¶
             modal.querySelector('.modal-close-btn').addEventListener('click', () => {
               modal.remove();
             });
             modal.addEventListener('click', (e) => {
               if (e.target === modal) modal.remove();
             });
           },

           // æ˜¾ç¤ºå­—ä½“å‹ç¼©å¸®åŠ©
           showFontCompressHelp() {
             const helpContent = `
               <div style="padding: 15px; line-height: 1.6;">
                 <h3 style="color: #c9aa71; margin-bottom: 15px;">å­—ä½“æ–‡ä»¶å‹ç¼©æŒ‡å—</h3>
                 
                 <div style="margin-bottom: 15px;">
                   <h4 style="color: #e0dcd1; margin-bottom: 8px;">æ¨èåœ¨çº¿å·¥å…·ï¼š</h4>
                   <ul style="color: #a09c91; margin-left: 20px;">
                     <li><strong>FontSquirrel Webfont Generator</strong><br>
                         ç½‘å€ï¼šfontsquirrel.com/tools/webfont-generator<br>
                         æ”¯æŒTTFè½¬WOFF2ï¼Œå‹ç¼©ç‡é«˜</li>
                     <li><strong>CloudConvert</strong><br>
                         ç½‘å€ï¼šcloudconvert.com<br>
                         æ”¯æŒå¤šç§å­—ä½“æ ¼å¼è½¬æ¢</li>
                     <li><strong>Convertio</strong><br>
                         ç½‘å€ï¼šconvertio.co<br>
                         ç®€å•æ˜“ç”¨çš„åœ¨çº¿è½¬æ¢å·¥å…·</li>
                   </ul>
                 </div>
                 
                 <div style="margin-bottom: 15px;">
                   <h4 style="color: #e0dcd1; margin-bottom: 8px;">å‹ç¼©å»ºè®®ï¼š</h4>
                   <ul style="color: #a09c91; margin-left: 20px;">
                     <li>ä¼˜å…ˆé€‰æ‹©WOFF2æ ¼å¼ï¼ˆå‹ç¼©ç‡æœ€é«˜ï¼‰</li>
                     <li>ç§»é™¤ä¸éœ€è¦çš„å­—ç¬¦é›†ï¼ˆå¦‚åªä¿ç•™ä¸­æ–‡+è‹±æ–‡ï¼‰</li>
                     <li>é™ä½å­—ä½“ç²¾åº¦ï¼ˆé€‚å½“å‡å°‘æ›²çº¿ç‚¹æ•°ï¼‰</li>
                     <li>ç§»é™¤å­—ä½“æç¤ºä¿¡æ¯å’Œå…ƒæ•°æ®</li>
                   </ul>
                 </div>
                 
                 <div style="background: rgba(139, 115, 85, 0.2); padding: 10px; border-radius: 5px; margin-top: 15px;">
                   <div style="color: #c9aa71; font-size: 12px;">
                     <strong>æç¤ºï¼š</strong>å¦‚æœå­—ä½“ä»ç„¶è¿‡å¤§ï¼Œå»ºè®®é€‰æ‹©ç³»ç»Ÿé¢„è®¾å­—ä½“æˆ–å¯»æ‰¾æ›´è½»é‡çš„æ›¿ä»£å­—ä½“ã€‚
                   </div>
                 </div>
               </div>
             `;
             
             // åˆ›å»ºå¸®åŠ©æ¨¡æ€æ¡†
             const modal = document.createElement('div');
             modal.className = 'modal-overlay';
             modal.style.display = 'flex';
             modal.style.zIndex = '2002';
             modal.innerHTML = `
               <div class="modal-content" style="max-width: 600px;">
                 <div class="modal-header">
                   <h2 class="modal-title">å­—ä½“å‹ç¼©å¸®åŠ©</h2>
                   <button class="modal-close-btn">&times;</button>
                 </div>
                 <div class="modal-body">
                   ${helpContent}
                   <div style="text-align: center; margin-top: 20px;">
                     <button class="interaction-btn" onclick="this.closest('.modal-overlay').remove()">å…³é—­</button>
                   </div>
                 </div>
               </div>
             `;
             
             document.body.appendChild(modal);
             
             // ç»‘å®šå…³é—­äº‹ä»¶
             modal.querySelector('.modal-close-btn').addEventListener('click', () => {
               modal.remove();
             });
             modal.addEventListener('click', (e) => {
               if (e.target === modal) modal.remove();
             });
           },

           // å¤„ç†å­—ä½“æ–‡ä»¶ä¸Šä¼ 
           handleFontUpload(event) {
             const file = event.target.files[0];
             if (!file) return;

             // é‡ç½®æ–‡ä»¶è¾“å…¥æ¡†ï¼Œå…è®¸é‡æ–°é€‰æ‹©ç›¸åŒæ–‡ä»¶
             event.target.value = '';

             const allowedTypes = ['font/ttf', 'font/otf', 'font/woff', 'font/woff2', 'application/font-woff', 'application/font-woff2'];
             const fileExtension = file.name.split('.').pop().toLowerCase();
             const allowedExtensions = ['ttf', 'otf', 'woff', 'woff2'];

             if (!allowedExtensions.includes(fileExtension)) {
               this.showTemporaryMessage('è¯·é€‰æ‹©æœ‰æ•ˆçš„å­—ä½“æ–‡ä»¶ (.ttf, .otf, .woff, .woff2)');
               return;
             }

             // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º10MBï¼Œä½†ç»™å‡ºè­¦å‘Šï¼‰
             if (file.size > 10 * 1024 * 1024) {
               this.showTemporaryMessage('å­—ä½“æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº10MBçš„æ–‡ä»¶');
               return;
             }
             
             // å¯¹äºå¤§äº2MBçš„æ–‡ä»¶ç»™å‡ºè­¦å‘Š
             if (file.size > 2 * 1024 * 1024) {
               const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
               const shouldContinue = confirm(`å­—ä½“æ–‡ä»¶è¾ƒå¤§ (${sizeMB}MB)ï¼Œå¯èƒ½å½±å“åŠ è½½é€Ÿåº¦å’Œå­˜å‚¨ç©ºé—´ã€‚æ˜¯å¦ç»§ç»­ä¸Šä¼ ï¼Ÿ`);
               if (!shouldContinue) {
                 this.showTemporaryMessage('ä¸Šä¼ å·²å–æ¶ˆ');
                 return;
               }
               this.showTemporaryMessage(`æ­£åœ¨ä¸Šä¼ å¤§å­—ä½“æ–‡ä»¶ (${sizeMB}MB)ï¼Œè¯·ç¨å€™...`);
             }

             // æ˜¾ç¤ºä¸Šä¼ å¼€å§‹æç¤º
             this.showTemporaryMessage(`æ­£åœ¨å¤„ç†å­—ä½“æ–‡ä»¶: ${file.name}`);

             const reader = new FileReader();
             
             reader.onload = (e) => {
               try {
                 const fontData = e.target.result;
                 const fontName = file.name.replace(/\.[^/.]+$/, ""); // ç§»é™¤æ‰©å±•å
                 const fontFamily = `'${fontName}'`;
                 
                 // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨åŒåå­—ä½“
                 const existingFont = this.textSettings.customFonts.find(f => f.name === fontName);
                 if (existingFont) {
                   const shouldReplace = confirm(`å­—ä½“ "${fontName}" å·²å­˜åœ¨ï¼Œæ˜¯å¦æ›¿æ¢ï¼Ÿ`);
                   if (!shouldReplace) {
                     this.showTemporaryMessage('ä¸Šä¼ å·²å–æ¶ˆ');
                     return;
                   }
                   // ç§»é™¤æ—§å­—ä½“
                   const index = this.textSettings.customFonts.indexOf(existingFont);
                   this.removeCustomFont(index);
                 }
                 
                 // ç”Ÿæˆå­—ä½“æ–‡ä»¶çš„å“ˆå¸Œå€¼ä½œä¸ºç¼“å­˜é”®
                 const fontHash = this.generateFontHash(fontName, file.size, file.lastModified);
                 const cacheKey = `guixu_font_${fontHash}`;

                 // ä½¿ç”¨IndexedDBå­˜å‚¨å­—ä½“æ–‡ä»¶
                 this.storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily)
                   .then(() => {
                     // åˆ›å»ºå­—ä½“æ ·å¼
                     const style = document.createElement('style');
                     style.id = `font-style-${fontHash}`;
                     style.textContent = `
                       @font-face {
                         font-family: ${fontFamily};
                         src: url(${fontData});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);

                     // æ·»åŠ åˆ°è‡ªå®šä¹‰å­—ä½“åˆ—è¡¨ï¼ˆåªä¿å­˜å…ƒæ•°æ®ï¼Œä¸ä¿å­˜æ–‡ä»¶æ•°æ®ï¼‰
                     const customFont = {
                       name: fontName,
                       family: fontFamily,
                       hash: fontHash,
                       cacheKey: cacheKey,
                       size: file.size,
                       lastModified: file.lastModified
                     };
                     
                     this.textSettings.customFonts.push(customFont);
                     this.updateCustomFontsList();
                     
                     // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†
                     this.updateFontFamilyOptions();
                     
                     // è‡ªåŠ¨åº”ç”¨æ–°ä¸Šä¼ çš„å­—ä½“
                     this.textSettings.fontFamily = fontFamily;
                     const fontFamilySelect = document.getElementById('font-family-select');
                     if (fontFamilySelect) {
                       fontFamilySelect.value = fontFamily;
                     }
                     this.applyTextSettings();
                     this.saveTextSettings();
                     
                     const sizeMB = (file.size / (1024 * 1024)).toFixed(1);
                     this.showTemporaryMessage(`å­—ä½“ "${fontName}" (${sizeMB}MB) ä¸Šä¼ æˆåŠŸå¹¶å·²åº”ç”¨`);
                   })
                   .catch(error => {
                     console.error('å­—ä½“ç¼“å­˜å¤±è´¥:', error);
                     this.showTemporaryMessage(`å­—ä½“ç¼“å­˜å¤±è´¥: ${error.message}`);
                     
                     // å³ä½¿ç¼“å­˜å¤±è´¥ï¼Œä¹Ÿåˆ›å»ºä¸´æ—¶æ ·å¼
                     const style = document.createElement('style');
                     style.textContent = `
                       @font-face {
                         font-family: ${fontFamily};
                         src: url(${fontData});
                         font-display: swap;
                       }
                     `;
                     document.head.appendChild(style);
                     
                     // æ·»åŠ ä¸´æ—¶å­—ä½“åˆ°åˆ—è¡¨ï¼ˆä¸ä¿å­˜åˆ°localStorageï¼‰
                     const tempFont = {
                       name: fontName + ' (ä¸´æ—¶)',
                       family: fontFamily,
                       hash: fontHash,
                       size: file.size,
                       temporary: true
                     };
                     this.textSettings.customFonts.push(tempFont);
                     this.updateCustomFontsList();
                   });
               } catch (error) {
                 console.error('å­—ä½“å¤„ç†å¤±è´¥:', error);
                 this.showTemporaryMessage(`å­—ä½“å¤„ç†å¤±è´¥: ${error.message}`);
               }
             };
             
             reader.onerror = (error) => {
               console.error('æ–‡ä»¶è¯»å–å¤±è´¥:', error);
               this.showTemporaryMessage('æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•');
             };
             
             reader.readAsDataURL(file);
           },

           // ç”Ÿæˆå­—ä½“æ–‡ä»¶å“ˆå¸Œå€¼
           generateFontHash(name, size, lastModified) {
             const str = `${name}_${size}_${lastModified}`;
             let hash = 0;
             for (let i = 0; i < str.length; i++) {
               const char = str.charCodeAt(i);
               hash = ((hash << 5) - hash) + char;
               hash = hash & hash; // è½¬æ¢ä¸º32ä½æ•´æ•°
             }
             return Math.abs(hash).toString(36);
           },

           // ä½¿ç”¨IndexedDBå­˜å‚¨å­—ä½“æ–‡ä»¶
           // --- IndexedDB ç»Ÿä¸€ç®¡ç† ---
           initDB() {
               if (this.db) {
                   return Promise.resolve(this.db);
               }
               if (this.dbPromise) {
                   return this.dbPromise;
               }

               this.dbPromise = new Promise((resolve, reject) => {
                   const request = indexedDB.open('GuixuDB', 3);

                   request.onerror = () => {
                       console.error('IndexedDBæ‰“å¼€å¤±è´¥:', request.error);
                       this.dbPromise = null; // é‡ç½®ä»¥ä¾¿é‡è¯•
                       reject(request.error);
                   };

                   request.onupgradeneeded = (event) => {
                       console.log('IndexedDBå‡çº§ä¸­...');
                       const db = event.target.result;

                       if (!db.objectStoreNames.contains('fonts')) {
                           const fontStore = db.createObjectStore('fonts', { keyPath: 'cacheKey' });
                           fontStore.createIndex('name', 'name', { unique: false });
                           fontStore.createIndex('timestamp', 'timestamp', { unique: false });
                           console.log('å¯¹è±¡å­˜å‚¨ fonts åˆ›å»ºæˆåŠŸ');
                       }

                       if (!db.objectStoreNames.contains('character_avatars')) {
                           const avatarStore = db.createObjectStore('character_avatars', { keyPath: 'characterName' });
                           avatarStore.createIndex('timestamp', 'timestamp', { unique: false });
                           console.log('å¯¹è±¡å­˜å‚¨ character_avatars åˆ›å»ºæˆåŠŸ');
                       }
                   };

                   request.onsuccess = (event) => {
                       console.log('IndexedDBæ‰“å¼€æˆåŠŸ');
                       this.db = event.target.result;
                       this.dbPromise = null;
                       resolve(this.db);
                   };
               });
               return this.dbPromise;
           },

           async storeFontInIndexedDB(cacheKey, fontData, fontName, fontFamily) {
               try {
                   const db = await this.initDB();
                   const transaction = db.transaction(['fonts'], 'readwrite');
                   const store = transaction.objectStore('fonts');
                   const fontRecord = {
                       cacheKey: cacheKey,
                       name: fontName,
                       family: fontFamily,
                       data: fontData,
                       timestamp: Date.now()
                   };
                   const request = store.put(fontRecord);
                   return new Promise((resolve, reject) => {
                       request.onsuccess = () => {
                           console.log('å­—ä½“ç¼“å­˜æˆåŠŸ:', fontName);
                           resolve();
                       };
                       request.onerror = () => {
                           console.error('å­—ä½“ç¼“å­˜å¤±è´¥:', request.error);
                           reject(request.error);
                       };
                   });
               } catch (error) {
                   console.error('IndexedDBæ“ä½œå¼‚å¸¸:', error);
                   throw error;
               }
           },

           // ä»IndexedDBåŠ è½½å­—ä½“æ–‡ä»¶
           async loadFontFromIndexedDB(cacheKey) {
             return new Promise((resolve, reject) => {
               const request = indexedDB.open('GuixuDB', 3);
               
               request.onerror = () => {
                 console.error('IndexedDBæ‰“å¼€å¤±è´¥:', request.error);
                 reject(request.error);
               };
               
               request.onupgradeneeded = (event) => {
                   console.log('IndexedDBå‡çº§ä¸­ (from loadFont)...');
                   const db = event.target.result;

                   if (!db.objectStoreNames.contains('fonts')) {
                       const fontStore = db.createObjectStore('fonts', { keyPath: 'cacheKey' });
                       fontStore.createIndex('name', 'name', { unique: false });
                       fontStore.createIndex('timestamp', 'timestamp', { unique: false });
                       console.log('å¯¹è±¡å­˜å‚¨ fonts åˆ›å»ºæˆåŠŸ');
                   }

                   if (!db.objectStoreNames.contains('character_avatars')) {
                       const avatarStore = db.createObjectStore('character_avatars', { keyPath: 'characterName' });
                       avatarStore.createIndex('timestamp', 'timestamp', { unique: false });
                       console.log('å¯¹è±¡å­˜å‚¨ character_avatars åˆ›å»ºæˆåŠŸ');
                   }
               };
               
               request.onsuccess = (event) => {
                 const db = event.target.result;
                 
                 try {
                   // æ£€æŸ¥å¯¹è±¡å­˜å‚¨æ˜¯å¦å­˜åœ¨
                   if (!db.objectStoreNames.contains('fonts')) {
                     console.warn('fontså¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨ï¼Œå­—ä½“ç¼“å­˜ä¸ºç©º');
                     db.close();
                     reject(new Error('fontså¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨'));
                     return;
                   }
                   
                   const transaction = db.transaction(['fonts'], 'readonly');
                   const store = transaction.objectStore('fonts');
                   
                   const getRequest = store.get(cacheKey);
                   getRequest.onsuccess = () => {
                     if (getRequest.result) {
                       console.log('å­—ä½“ç¼“å­˜åŠ è½½æˆåŠŸ:', getRequest.result.name);
                       resolve(getRequest.result);
                     } else {
                       console.warn('å­—ä½“ç¼“å­˜æœªæ‰¾åˆ°:', cacheKey);
                       reject(new Error('Font not found in cache'));
                     }
                   };
                   getRequest.onerror = () => {
                     console.error('å­—ä½“ç¼“å­˜è¯»å–å¤±è´¥:', getRequest.error);
                     reject(getRequest.error);
                   };
                   
                   transaction.onerror = () => {
                     console.error('è¯»å–äº‹åŠ¡å¤±è´¥:', transaction.error);
                     reject(transaction.error);
                   };
                 } catch (error) {
                   console.error('IndexedDBè¯»å–å¼‚å¸¸:', error);
                   reject(error);
                 }
               };
             });
           },

           // æ›´æ–°è‡ªå®šä¹‰å­—ä½“åˆ—è¡¨æ˜¾ç¤º
           updateCustomFontsList() {
             const container = document.getElementById('uploaded-fonts-list');
             if (!container) return;

             if (this.textSettings.customFonts.length === 0) {
               container.innerHTML = '<div style="color: #8b7355; font-size: 11px; text-align: center; padding: 10px;">æš‚æ— ä¸Šä¼ çš„å­—ä½“</div>';
               return;
             }

             let html = '';
             this.textSettings.customFonts.forEach((font, index) => {
               html += `
                 <div style="display: flex; align-items: center; justify-content: space-between; padding: 5px; border: 1px solid #8b7355; border-radius: 3px; margin-bottom: 5px;">
                   <span style="font-size: 11px; color: #e0dcd1;">${font.name}</span>
                   <div>
                     <button class="interaction-btn font-use-btn" style="padding: 2px 6px; font-size: 10px; margin-right: 5px;" data-font-index="${index}">ä½¿ç”¨</button>
                     <button class="interaction-btn font-remove-btn" style="padding: 2px 6px; font-size: 10px; background: #8b0000; border-color: #ff6b6b;" data-font-index="${index}">åˆ é™¤</button>
                   </div>
                 </div>
               `;
             });
             
             container.innerHTML = html;

             // ç»‘å®šäº‹ä»¶å§”æ‰˜
             container.addEventListener('click', (e) => {
               const index = parseInt(e.target.dataset.fontIndex);
               if (isNaN(index)) return;

               if (e.target.classList.contains('font-use-btn')) {
                 this.useCustomFont(index);
               } else if (e.target.classList.contains('font-remove-btn')) {
                 this.removeCustomFont(index);
               }
             });
           },
            // ç¡®ä¿è‡ªå®šä¹‰å­—ä½“å·²åŠ è½½
            async ensureCustomFontLoaded(fontFamily) {
              // æ£€æŸ¥æ˜¯å¦æ˜¯è‡ªå®šä¹‰å­—ä½“
              const customFont = this.textSettings.customFonts.find(font => font.family === fontFamily);
              if (!customFont) {
                return; // ä¸æ˜¯è‡ªå®šä¹‰å­—ä½“ï¼Œç›´æ¥è¿”å›
              }

              // æ£€æŸ¥å­—ä½“æ ·å¼æ˜¯å¦å·²å­˜åœ¨
              const existingStyle = document.getElementById(`font-style-${customFont.hash}`);
              if (existingStyle) {
                return; // å­—ä½“æ ·å¼å·²å­˜åœ¨ï¼Œç›´æ¥è¿”å›
              }

              // å­—ä½“æ ·å¼ä¸å­˜åœ¨ï¼Œéœ€è¦é‡æ–°åŠ è½½
              if (customFont.cacheKey) {
                try {
                  const cachedFont = await this.loadFontFromIndexedDB(customFont.cacheKey);
                  const style = document.createElement('style');
                  style.id = `font-style-${customFont.hash}`;
                  style.textContent = `
                    @font-face {
                      font-family: '${cachedFont.name}';
                      src: url(data:font/truetype;base64,${cachedFont.data}) format('truetype');
                    }
                  `;
                  document.head.appendChild(style);
                  console.log('è‡ªå®šä¹‰å­—ä½“é‡æ–°åŠ è½½æˆåŠŸ:', cachedFont.name);
                } catch (error) {
                  console.error('è‡ªå®šä¹‰å­—ä½“åŠ è½½å¤±è´¥:', error);
                }
              }
            },


           // ä½¿ç”¨è‡ªå®šä¹‰å­—ä½“
           useCustomFont(index) {
             if (index >= 0 && index < this.textSettings.customFonts.length) {
               const font = this.textSettings.customFonts[index];
               this.textSettings.fontFamily = font.family;
               
               // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†ä¸ºå¯¹åº”çš„è‡ªå®šä¹‰å­—ä½“
               const fontFamilySelect = document.getElementById('font-family-select');
               if (fontFamilySelect) {
                 fontFamilySelect.value = font.family;
               }
               if (customFontSection) {
                 customFontSection.style.display = 'block';
               }
               
               // ç¡®ä¿å­—ä½“å·²åŠ è½½åå†åº”ç”¨
               this.ensureCustomFontLoaded(font.family).then(() => {
                 this.applyTextSettings();
                 this.saveTextSettings();
               });
               this.showTemporaryMessage(`å·²åº”ç”¨å­—ä½“ "${font.name}"`);
               
               console.log('[å½’å¢Ÿæ–‡å­—è®¾ç½®] å·²åº”ç”¨è‡ªå®šä¹‰å­—ä½“:', font.name, font.family);
             }
           },

           // åˆ é™¤è‡ªå®šä¹‰å­—ä½“
           removeCustomFont(index) {
             if (index >= 0 && index < this.textSettings.customFonts.length) {
               const font = this.textSettings.customFonts[index];
               this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤å­—ä½“ "${font.name}" å—ï¼Ÿ`, async () => {
                 try {
                   // ä»IndexedDBä¸­åˆ é™¤ç¼“å­˜çš„å­—ä½“æ–‡ä»¶
                   if (font.cacheKey) {
                     await this.removeFontFromIndexedDB(font.cacheKey);
                   }
                   
                   // ç§»é™¤é¡µé¢ä¸­çš„å­—ä½“æ ·å¼
                   if (font.hash) {
                     const styleElement = document.getElementById(`font-style-${font.hash}`);
                     if (styleElement) {
                       styleElement.remove();
                     }
                   }
                   
                   // æ£€æŸ¥å½“å‰æ˜¯å¦æ­£åœ¨ä½¿ç”¨è¢«åˆ é™¤çš„å­—ä½“
                   const isCurrentFont = this.textSettings.fontFamily === font.family;
                   
                   // ä»è®¾ç½®ä¸­ç§»é™¤
                   this.textSettings.customFonts.splice(index, 1);
                   this.updateCustomFontsList();
                   
                   // æ›´æ–°å­—ä½“é€‰æ‹©ä¸‹æ‹‰æ¡†
                   this.updateFontFamilyOptions();
                   
                   // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰ä½¿ç”¨çš„å­—ä½“ï¼Œåˆ‡æ¢åˆ°é»˜è®¤å­—ä½“
                   if (isCurrentFont) {
                     this.textSettings.fontFamily = "'ZCOOL+KuaiLe', 'Ma+Shan+Zheng', serif";
                     const fontFamilySelect = document.getElementById('font-family-select');
                     if (fontFamilySelect) {
                       fontFamilySelect.value = this.textSettings.fontFamily;
                     }
                     this.applyTextSettings();
                   }
                   
                   this.saveTextSettings();
                   this.showTemporaryMessage(`å­—ä½“ "${font.name}" å·²åˆ é™¤`);
                 } catch (error) {
                   console.error('åˆ é™¤å­—ä½“ç¼“å­˜å¤±è´¥:', error);
                   // å³ä½¿ç¼“å­˜åˆ é™¤å¤±è´¥ï¼Œä¹Ÿè¦ä»è®¾ç½®ä¸­ç§»é™¤
                   this.textSettings.customFonts.splice(index, 1);
                   this.updateCustomFontsList();
                   this.updateFontFamilyOptions();
                   this.saveTextSettings();
                   this.showTemporaryMessage(`å­—ä½“ "${font.name}" å·²åˆ é™¤ï¼ˆç¼“å­˜æ¸…ç†å¯èƒ½å¤±è´¥ï¼‰`);
                 }
               });
             }
           },

           // ä»IndexedDBä¸­åˆ é™¤å­—ä½“æ–‡ä»¶
           removeFontFromIndexedDB(cacheKey) {
             return new Promise((resolve, reject) => {
               const request = indexedDB.open('GuixuDB', 3);
               
               request.onerror = () => {
                 console.error('IndexedDBæ‰“å¼€å¤±è´¥:', request.error);
                 reject(request.error);
               };
               
               request.onupgradeneeded = (event) => {
                   console.log('IndexedDBå‡çº§ä¸­ (from removeFont)...');
                   const db = event.target.result;

                   if (!db.objectStoreNames.contains('fonts')) {
                       const fontStore = db.createObjectStore('fonts', { keyPath: 'cacheKey' });
                       fontStore.createIndex('name', 'name', { unique: false });
                       fontStore.createIndex('timestamp', 'timestamp', { unique: false });
                       console.log('å¯¹è±¡å­˜å‚¨ fonts åˆ›å»ºæˆåŠŸ');
                   }

                   if (!db.objectStoreNames.contains('character_avatars')) {
                       const avatarStore = db.createObjectStore('character_avatars', { keyPath: 'characterName' });
                       avatarStore.createIndex('timestamp', 'timestamp', { unique: false });
                       console.log('å¯¹è±¡å­˜å‚¨ character_avatars åˆ›å»ºæˆåŠŸ');
                   }
               };
               
               request.onsuccess = (event) => {
                 const db = event.target.result;
                 
                 try {
                   // æ£€æŸ¥å¯¹è±¡å­˜å‚¨æ˜¯å¦å­˜åœ¨
                   if (!db.objectStoreNames.contains('fonts')) {
                     console.warn('fontså¯¹è±¡å­˜å‚¨ä¸å­˜åœ¨ï¼Œæ— éœ€åˆ é™¤');
                     resolve(); // ä¸å­˜åœ¨å°±å½“ä½œåˆ é™¤æˆåŠŸ
                     return;
                   }
                   
                   const transaction = db.transaction(['fonts'], 'readwrite');
                   const store = transaction.objectStore('fonts');
                   
                   const deleteRequest = store.delete(cacheKey);
                   deleteRequest.onsuccess = () => {
                     console.log('å­—ä½“ç¼“å­˜åˆ é™¤æˆåŠŸ:', cacheKey);
                     resolve();
                   };
                   deleteRequest.onerror = () => {
                     console.error('å­—ä½“ç¼“å­˜åˆ é™¤å¤±è´¥:', deleteRequest.error);
                     reject(deleteRequest.error);
                   };
                   
                   transaction.onerror = () => {
                     console.error('åˆ é™¤äº‹åŠ¡å¤±è´¥:', transaction.error);
                     reject(transaction.error);
                   };
                 } catch (error) {
                   console.error('IndexedDBåˆ é™¤å¼‚å¸¸:', error);
                   reject(error);
                 }
               };
             });
           },

           // --- äººç‰©å¤´åƒ IndexedDB æ“ä½œ ---
           async storeAvatarInDB(characterName, imageData, opacity) {
               try {
                   const db = await this.initDB();
                   const transaction = db.transaction(['character_avatars'], 'readwrite');
                   const store = transaction.objectStore('character_avatars');
                   
                   // å…ˆè·å–ç°æœ‰è®°å½•
                   const existingRecord = await new Promise((resolve, reject) => {
                       const request = store.get(characterName);
                       request.onsuccess = () => resolve(request.result);
                       request.onerror = () => reject(request.error);
                   });

                   const avatarRecord = {
                       characterName: characterName,
                       imageData: imageData !== undefined ? imageData : existingRecord?.imageData,
                       opacity: opacity !== undefined ? opacity : existingRecord?.opacity ?? 1.0,
                       timestamp: Date.now()
                   };

                   const request = store.put(avatarRecord);
                   return new Promise((resolve, reject) => {
                       request.onsuccess = () => {
                           console.log(`è§’è‰²å¤´åƒ [${characterName}] ç¼“å­˜æˆåŠŸ`);
                           resolve();
                       };
                       request.onerror = () => {
                           console.error(`è§’è‰²å¤´åƒ [${characterName}] ç¼“å­˜å¤±è´¥:`, request.error);
                           reject(request.error);
                       };
                   });
               } catch (error) {
                   console.error('IndexedDB (å¤´åƒ) æ“ä½œå¼‚å¸¸:', error);
                   throw error;
               }
           },

           async getAvatarFromDB(characterName) {
               try {
                   const db = await this.initDB();
                   const transaction = db.transaction(['character_avatars'], 'readonly');
                   const store = transaction.objectStore('character_avatars');
                   const request = store.get(characterName);
                   return new Promise((resolve, reject) => {
                       request.onsuccess = () => {
                           if (request.result) {
                               resolve(request.result);
                           } else {
                               resolve(null); // æ˜ç¡®è¿”å›null
                           }
                       };
                       request.onerror = () => {
                           console.error(`è¯»å–è§’è‰²å¤´åƒ [${characterName}] å¤±è´¥:`, request.error);
                           reject(request.error);
                       };
                   });
               } catch (error) {
                   // å¦‚æœæ•°æ®åº“åˆå§‹åŒ–å¤±è´¥ç­‰ï¼Œç›´æ¥è¿”å›null
                   console.error('IndexedDB (å¤´åƒ) è¯»å–å¼‚å¸¸:', error);
                   return null;
               }
           },

           async removeAvatarFromDB(characterName) {
               try {
                   const db = await this.initDB();
                   const transaction = db.transaction(['character_avatars'], 'readwrite');
                   const store = transaction.objectStore('character_avatars');
                   const request = store.delete(characterName);
                   return new Promise((resolve, reject) => {
                       request.onsuccess = () => {
                           console.log(`è§’è‰²å¤´åƒ [${characterName}] åˆ é™¤æˆåŠŸ`);
                           resolve();
                       };
                       request.onerror = () => {
                           console.error(`è§’è‰²å¤´åƒ [${characterName}] åˆ é™¤å¤±è´¥:`, request.error);
                           reject(request.error);
                       };
                   });
               } catch (error) {
                   console.error('IndexedDB (å¤´åƒ) åˆ é™¤å¼‚å¸¸:', error);
                   throw error;
               }
           },

           // --- å¤´åƒä¸Šä¼ ä¸å‹ç¼© ---
           async compressImageForAvatar(file) {
               return new Promise((resolve, reject) => {
                   const MAX_WIDTH = 512;
                   const MAX_HEIGHT = 512;
                   const reader = new FileReader();
                   reader.readAsDataURL(file);
                   reader.onload = (e) => {
                       const img = new Image();
                       img.src = e.target.result;
                       img.onload = () => {
                           let width = img.width;
                           let height = img.height;

                           if (width > height) {
                               if (width > MAX_WIDTH) {
                                   height *= MAX_WIDTH / width;
                                   width = MAX_WIDTH;
                               }
                           } else {
                               if (height > MAX_HEIGHT) {
                                   width *= MAX_HEIGHT / height;
                                   height = MAX_HEIGHT;
                               }
                           }

                           const canvas = document.createElement('canvas');
                           canvas.width = width;
                           canvas.height = height;
                           const ctx = canvas.getContext('2d');
                           ctx.drawImage(img, 0, 0, width, height);
                           
                           // ä½¿ç”¨JPEGæ ¼å¼ä»¥è·å¾—æ›´å¥½çš„å‹ç¼©ç‡
                           resolve(canvas.toDataURL('image/jpeg', 0.8));
                       };
                       img.onerror = (error) => reject(error);
                   };
                   reader.onerror = (error) => reject(error);
               });
           },

           async handleAvatarUpload(characterName, file) {
               if (!file.type.startsWith('image/')) {
                   this.showTemporaryMessage('è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶', 'error');
                   return;
               }
               this.showTemporaryMessage('æ­£åœ¨å¤„ç†å›¾ç‰‡...', 'info');
               try {
                   // ç›´æ¥ä½¿ç”¨åŸå§‹å›¾ç‰‡
                   const originalImage = await this.fileToDataUrl(file);
                   const avatarImage = originalImage;
                   const backgroundImage = originalImage;

                   // æ™ºèƒ½å¤„ç†é€æ˜åº¦ï¼šå…ˆè¯»å–æ—§çš„ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™ç”¨é»˜è®¤å€¼0.5
                   const existingRecord = await this.getAvatarFromDB(characterName);
                   const backgroundOpacity = existingRecord ? existingRecord.backgroundOpacity : 0.5;

                   const newRecord = {
                       characterName: characterName,
                       avatarImage: avatarImage,
                       backgroundImage: backgroundImage,
                       backgroundOpacity: backgroundOpacity
                   };

                   await this.storeAvatarInDB(newRecord);
                   
                   this.showTemporaryMessage('å›¾ç‰‡ä¸Šä¼ æˆåŠŸ!', 'success');
                   
                   // ç«‹å³åˆ·æ–°UI
                   if (document.getElementById('relationships-modal').style.display === 'flex') {
                       this.renderCharacterDetails(characterName); // åˆ·æ–°è¯¦æƒ…
                       this.renderCharacterList(); // åˆ·æ–°åˆ—è¡¨
                   }
               } catch (error) {
                   console.error('å¤´åƒä¸Šä¼ å¤±è´¥:', error);
                   this.showTemporaryMessage('å¤´åƒä¸Šä¼ å¤±è´¥ï¼Œè¯·æŸ¥çœ‹æ§åˆ¶å°', 'error');
               }
           },

           // æ¸…ç†è¿‡æœŸçš„å­—ä½“ç¼“å­˜ï¼ˆå¯é€‰åŠŸèƒ½ï¼‰
           cleanupExpiredFontCache() {
             const request = indexedDB.open('GuixuDB', 3);

             request.onerror = () => {
                 console.error('IndexedDBæ‰“å¼€å¤±è´¥ (cleanup):', request.error);
             };

             request.onupgradeneeded = (event) => {
                 console.log('IndexedDBå‡çº§ä¸­ (from cleanup)...');
                 const db = event.target.result;

                 if (!db.objectStoreNames.contains('fonts')) {
                     const fontStore = db.createObjectStore('fonts', { keyPath: 'cacheKey' });
                     fontStore.createIndex('name', 'name', { unique: false });
                     fontStore.createIndex('timestamp', 'timestamp', { unique: false });
                     console.log('å¯¹è±¡å­˜å‚¨ fonts åˆ›å»ºæˆåŠŸ');
                 }

                 if (!db.objectStoreNames.contains('character_avatars')) {
                     const avatarStore = db.createObjectStore('character_avatars', { keyPath: 'characterName' });
                     avatarStore.createIndex('timestamp', 'timestamp', { unique: false });
                     console.log('å¯¹è±¡å­˜å‚¨ character_avatars åˆ›å»ºæˆåŠŸ');
                 }
             };
             
             request.onsuccess = (event) => {
               const db = event.target.result;
               const transaction = db.transaction(['fonts'], 'readwrite');
               const store = transaction.objectStore('fonts');
               
               const now = Date.now();
               const expireTime = 30 * 24 * 60 * 60 * 1000; // 30å¤©è¿‡æœŸ
               
               store.openCursor().onsuccess = (event) => {
                 const cursor = event.target.result;
                 if (cursor) {
                   const record = cursor.value;
                   if (now - record.timestamp > expireTime) {
                     cursor.delete();
                     console.log(`[å½’å¢Ÿæ–‡å­—è®¾ç½®] æ¸…ç†è¿‡æœŸå­—ä½“ç¼“å­˜: ${record.name}`);
                   }
                   cursor.continue();
                 }
               };
             };
           },

           async showGuixuSystem() {
            this.openModal('guixu-system-modal');
            const body = document.querySelector('#guixu-system-modal .modal-body');
            if (!body) return;
            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨è¿æ¥å½’å¢Ÿ...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              const stat_data = messages?.[0]?.data?.stat_data;
              if (!stat_data) {
                body.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ— æ³•è¿æ¥å½’å¢Ÿã€‚</p>';
                return;
              }

              const currentLife = this.SafeGetValue(stat_data, 'å½“å‰ç¬¬xä¸–', '1');
              const guixuSpace = this.SafeGetValue(stat_data, 'å½’å¢Ÿç©ºé—´', 'ç©ºæ— ä¸€ç‰©');
              const guixuPoint = this.SafeGetValue(stat_data, 'å½’å¢Ÿç‚¹', '0');
              const currentChoice = this.SafeGetValue(stat_data, 'æœ¬ä¸–å½’å¢Ÿé€‰æ‹©', 'æ— ');
              const chargeTime = this.SafeGetValue(stat_data, 'å½’å¢Ÿå……èƒ½æ—¶é—´', '0');
              const shengli = this.SafeGetValue(stat_data, 'å¹´é¾„', 'N/A');
              const shengliMax = this.SafeGetValue(stat_data, 'å¯¿å…ƒ', 'N/A');
              const xinli = this.SafeGetValue(stat_data, 'å¿ƒç†å¹´é¾„', 'N/A');
              const xinliMax = this.SafeGetValue(stat_data, 'å¿ƒç†å¹´é¾„ä¸Šé™', 'N/A');

              body.innerHTML = `
                    <div class="panel-section">
                        <div class="attributes-list">
                            <div class="attribute-item"><span class="attribute-name">å½“å‰ä¸–æ•°</span><span class="attribute-value">ç¬¬ ${currentLife} ä¸–</span></div>
                            <div class="attribute-item"><span class="attribute-name">ç”Ÿç†å¹´é¾„</span><span class="attribute-value">${shengli} / ${shengliMax}</span></div>
                            <div class="attribute-item"><span class="attribute-name">å¿ƒç†å¹´é¾„</span><span class="attribute-value">${xinli} / ${xinliMax}</span></div>
                            <div class="attribute-item"><span class="attribute-name">å½’å¢Ÿç©ºé—´</span><span class="attribute-value">${guixuSpace}</span></div>
                            <div class="attribute-item"><span class="attribute-name">å½’å¢Ÿç‚¹</span><span class="attribute-value">${guixuPoint}</span></div>
                            <div class="attribute-item"><span class="attribute-name">æœ¬ä¸–æŠ‰æ‹©</span><span class="attribute-value">${currentChoice}</span></div>
                            <div class="attribute-item" style="margin-top: 15px;"><span class="attribute-name">å½’å¢Ÿå……èƒ½</span><span class="attribute-value">${chargeTime}%</span></div>
                            <div class="details-progress-bar">
                                <div class="details-progress-fill" style="width: ${chargeTime}%; background: linear-gradient(90deg, #dc143c, #ff6b6b, #ffd700);"></div>
                            </div>
                          
                          
                                      </div>
                                    </div>
                `;

              // ä¸ºé™æ€æŒ‰é’®ç»‘å®šäº‹ä»¶
              const reincarnateBtn = document.getElementById('btn-guixu-reincarnate');
              if (reincarnateBtn) {
                  // ç§»é™¤æ—§çš„ç›‘å¬å™¨ä»¥é˜²é‡å¤ç»‘å®š
                  const newBtn = reincarnateBtn.cloneNode(true);
                  reincarnateBtn.parentNode.replaceChild(newBtn, reincarnateBtn);

                  newBtn.addEventListener('click', () => {
                      if (chargeTime >= 100) {
                          this.showCustomConfirm('ä½ ç¡®å®šè¦å¼€å¯ä¸‹ä¸€æ¬¡è½®å›å—ï¼Ÿæ‰€æœ‰æœªå‚¨å­˜çš„è®°å¿†éƒ½å°†æ¶ˆæ•£ã€‚', async () => {
                              try {
                                  const command = '{{user}}é€‰æ‹©å½’å¢Ÿï¼Œä¸–ç•Œå°†å›åˆ°æœ€åˆçš„é”šç‚¹';
                                  await this.handleAction(command);
                                  this.showTemporaryMessage('è½®å›å·²å¼€å¯...');
                                  this.closeAllModals();
                              } catch (error) {
                                  console.error('æ‰§è¡Œå½’å¢ŸæŒ‡ä»¤æ—¶å‡ºé”™:', error);
                                  this.showTemporaryMessage('æ‰§è¡Œå½’å¢ŸæŒ‡ä»¤å¤±è´¥ï¼');
                              }
                          });
                      } else {
                          this.showTemporaryMessage('å½’å¢Ÿå……èƒ½è¿›åº¦ä¸è¶³');
                      }
                  });
              }
            } catch (error) {
              console.error('åŠ è½½å½’å¢Ÿç³»ç»Ÿæ—¶å‡ºé”™:', error);
              body.innerHTML =
                '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">åŠ è½½æ•°æ®æ—¶å‡ºé”™ã€‚</p>';
            }
          },

          // --- YAMLè§£æå™¨ (ä» kaiju.html ç§»æ¤) ---
          YAMLParser: {
            parse: function (text) {
              if (!text || typeof text !== 'string') return {};
              const lines = text.split('\n');
              const result = {};
              const stack = [{ indent: -1, obj: result, lastKey: null }];

              for (const line of lines) {
                  const trimmed = line.trim();
                  if (!trimmed || trimmed.startsWith('#')) continue;

                  const indent = line.search(/\S/);

                  while (stack.length > 1 && indent <= stack[stack.length - 1].indent) {
                      stack.pop();
                  }
                  const parent = stack[stack.length - 1].obj;
                  let lastKeyInParent = stack[stack.length - 1].lastKey;

                  if (trimmed.startsWith('- ')) {
                      const value = trimmed.substring(2).trim();
                      if (lastKeyInParent && Array.isArray(parent[lastKeyInParent])) {
                          parent[lastKeyInParent].push(this._parseValue(value));
                      }
                  } else {
                      const colonIndex = trimmed.indexOf(':');
                      if (colonIndex > -1) {
                          const key = trimmed.substring(0, colonIndex).trim();
                          let value = trimmed.substring(colonIndex + 1).trim();
                          
                          stack[stack.length - 1].lastKey = key;

                          if (value === '|' || value === '>') {
                              let multiline = '';
                              const blockStartIndex = lines.indexOf(line) + 1;
                              for (let i = blockStartIndex; i < lines.length; i++) {
                                  const nextLine = lines[i];
                                  const nextIndent = nextLine.search(/\S/);
                                  if (nextLine.trim() === '' || nextIndent > indent) {
                                      multiline += nextLine.substring(indent + 2) + '\n';
                                  } else {
                                      break;
                                  }
                              }
                              parent[key] = multiline.trim();
                          } else if (value === '') {
                               const nextLine = lines[lines.indexOf(line) + 1] || '';
                               const nextTrimmed = nextLine.trim();
                               const nextIndent = nextLine.search(/\S/);
                               if (nextTrimmed.startsWith('- ') && nextIndent > indent) {
                                   const newArr = [];
                                   parent[key] = newArr;
                               } else if (nextIndent > indent) {
                                   const newObj = {};
                                   parent[key] = newObj;
                                   stack.push({ indent: indent, obj: newObj, lastKey: null });
                               } else {
                                   parent[key] = '';
                               }
                          } else {
                              parent[key] = this._parseValue(value);
                          }
                      }
                  }
              }
              return result;
            },
            _parseValue: function (val) {
              const numVal = Number(val);
              if (!isNaN(numVal) && val.trim() !== '') {
                return numVal;
              }
              if (val === 'true') return true;
              if (val === 'false') return false;
              return val;
            },
          },

          // --- å½’å¢Ÿç©ºé—´ï¼šåŠ è½½å•†å“ ---
          async loadGuixuStoreItems() {
            try {
              if (typeof TavernHelper === 'undefined' || typeof TavernHelper.getGlobalWorldbookNames !== 'function' || typeof TavernHelper.getWorldbook !== 'function') {
                console.error('TavernHelper API not available.');
                this.showTemporaryMessage('é”™è¯¯ï¼šä¸–ç•Œä¹¦APIä¸å¯ç”¨');
                return [];
              }

              // 1. è·å–æ‰€æœ‰å¯ç”¨çš„ä¸–ç•Œä¹¦åç§°
              const enabledBookNames = TavernHelper.getGlobalWorldbookNames();
              
              // 2. ç­›é€‰å‡ºç›®æ ‡ä¸–ç•Œä¹¦åç§°
              let targetBookNames = enabledBookNames.filter(name => name.startsWith('ã€å½’å¢Ÿæ‰©å±•ã€‘'));
              
              // 3. æ·»åŠ  '1å½’å¢Ÿ' å¹¶å»é‡
              if (!targetBookNames.includes('1å½’å¢Ÿ')) {
                  targetBookNames.push('1å½’å¢Ÿ');
              }
              
              let allEntries = [];
              for (const bookName of targetBookNames) {
                  try {
                      const entries = await TavernHelper.getWorldbook(bookName);
                      allEntries.push(...entries);
                  } catch (e) {
                      console.warn(`æ— æ³•åŠ è½½ä¸–ç•Œä¹¦ "${bookName}" çš„å†…å®¹:`, e);
                  }
              }

              if (allEntries.length === 0) {
                console.warn('åœ¨ç›®æ ‡ä¸–ç•Œä¹¦ä¸­æœªæ‰¾åˆ°ä»»ä½•æ¡ç›®ã€‚');
                return [];
              }

              const validItemPrefixes = ['ã€å¤©èµ‹ã€‘', 'ã€èƒŒæ™¯ã€‘'];
              const itemEntries = allEntries.filter(entry => {
                return validItemPrefixes.some(prefix => entry.name.startsWith(prefix));
              });

              if (itemEntries.length === 0) {
                  console.log('åœ¨ç›®æ ‡ä¸–ç•Œä¹¦ä¸­æœªæ‰¾åˆ°ç¬¦åˆå•†å“å‰ç¼€çš„æ¡ç›®ã€‚');
                  return [];
              }
              
              const items = itemEntries.map(entry => {
                try {
                  const parsedContent = this.YAMLParser.parse(entry.content);
                  // ä¿®å¤ï¼šå…¼å®¹â€œä»·æ ¼â€å’Œâ€œæ¶ˆè€—ç‚¹æ•°â€ä¸¤ç§å­—æ®µï¼Œå¹¶æä¾›é»˜è®¤å€¼
                  const priceValue = parsedContent.ä»·æ ¼ ?? parsedContent.æ¶ˆè€—ç‚¹æ•° ?? 0;
                  const price = parseInt(priceValue, 10);

                  const itemId = `gs-item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                  return {
                    id: itemId,
                    name: parsedContent.åç§° || entry.name.replace(/ã€.*?ã€‘/g, '').trim(),
                    price: price,
                    description: parsedContent.æè¿° || 'æš‚æ— æè¿°',
                    type: parsedContent.ç±»å‹ || entry.name.match(/ã€(.*?)ã€‘/)?.[1] || 'ç‰©å“',
                    tier: parsedContent.å“é˜¶ || 'å‡¡å“',
                    fullContent: entry.content,
                  };
                } catch (e) {
                  console.error(`è§£æä¸–ç•Œä¹¦æ¡ç›® "${entry.name}" æ—¶å‡ºé”™:`, e);
                  return null;
                }
              }).filter(item => item !== null);

              return items;

            } catch (error) {
              console.error('åŠ è½½å½’å¢Ÿç©ºé—´å•†å“æ—¶å‡ºé”™:', error);
              this.showTemporaryMessage('åŠ è½½å•†å“å¤±è´¥');
              return [];
            }
          },

          currentGuixuSort: 'é»˜è®¤',
          guixuItemDOMElements: {}, // æ–°å¢ï¼šç”¨äºç¼“å­˜DOMå…ƒç´ 
          // --- å½’å¢Ÿç©ºé—´ï¼šä¸»ç•Œé¢ ---
          async showGuixuSpace(filterType = 'å…¨éƒ¨', isUpdate = false) {
            this.currentGuixuFilter = filterType;
            this.openModal('guixu-space-modal', true);
            const body = document.querySelector('#guixu-space-modal .modal-body');
            if (!body) return;

            // --- æ€§èƒ½ä¼˜åŒ–ï¼šä»…åœ¨é¦–æ¬¡åŠ è½½æ—¶å®Œå…¨é‡ç»˜ ---
            if (!isUpdate) {
               if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                   body.innerHTML = '<p class="modal-placeholder">æ­£åœ¨åŠ è½½ç©å®¶æ•°æ®...</p>';
                   await this.loadMvuData();
                   if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                       this.showTemporaryMessage('æ— æ³•åŠ è½½ç©å®¶æ•°æ®ï¼Œè¯·åˆ·æ–°é¡µé¢');
                       return;
                   }
               }

               body.innerHTML = '<p class="modal-placeholder">æ­£åœ¨ä»ä¸–ç•Œä¹¦ä¸­åŠ è½½å•†å“...</p>';
               const allItems = await this.loadGuixuStoreItems();
               this.guixuStoreItems = allItems;
               this.guixuItemDOMElements = {}; // æ¸…ç©ºç¼“å­˜
            }

            let filteredItems = filterType === 'å…¨éƒ¨' ? this.guixuStoreItems : this.guixuStoreItems.filter(item => item.type === filterType);

            switch (this.currentGuixuSort) {
               case 'å“é˜¶ (é«˜åˆ°ä½)':
                   filteredItems = this.sortByTier(filteredItems, item => item.tier);
                   break;
               case 'å“é˜¶ (ä½åˆ°é«˜)':
                   filteredItems = this.sortByTier(filteredItems, item => item.tier).reverse();
                   break;
               case 'ç‚¹æ•° (é«˜åˆ°ä½)':
                   filteredItems.sort((a, b) => b.price - a.price);
                   break;
               case 'ç‚¹æ•° (ä½åˆ°é«˜)':
                   filteredItems.sort((a, b) => a.price - b.price);
                   break;
            }

            const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
            
            // --- æ€§èƒ½ä¼˜åŒ–ï¼šä»…åœ¨é¦–æ¬¡åŠ è½½æ—¶æ¸²æŸ“Headerå’ŒGridå®¹å™¨ ---
            if (!isUpdate) {
               const filters = ['å…¨éƒ¨', 'å¤©èµ‹', 'èƒŒæ™¯'];
               const sorts = ['é»˜è®¤', 'å“é˜¶ (é«˜åˆ°ä½)', 'å“é˜¶ (ä½åˆ°é«˜)', 'ç‚¹æ•° (é«˜åˆ°ä½)', 'ç‚¹æ•° (ä½åˆ°é«˜)'];
               const headerHtml = `
                 <div class="guixu-space-header">
                   <div class="guixu-filter-tabs">
                     ${filters.map(f => `<button class="tab-btn ${filterType === f ? 'active' : ''}" data-filter="${f}">${f}</button>`).join('')}
                   </div>
                   <div class="guixu-controls">
                      <select class="guixu-sort-select">
                          ${sorts.map(s => `<option value="${s}" ${this.currentGuixuSort === s ? 'selected' : ''}>${s}</option>`).join('')}
                      </select>
                      <div class="points-display">
                        <span>å½’å¢Ÿç‚¹: ${guixuPoints}</span>
                      </div>
                   </div>
                 </div>`;
               body.innerHTML = headerHtml + '<div class="guixu-item-grid"></div><p class="modal-placeholder" style="display:none;">æš‚æ— æ­¤ç±»å•†å“</p>';
               this.bindGuixuSpaceEvents(body);
            }
            
            // --- æ€§èƒ½ä¼˜åŒ–ï¼šDOMå¤ç”¨å’Œå±€éƒ¨æ›´æ–° ---
            const grid = body.querySelector('.guixu-item-grid');
            const placeholder = body.querySelector('.modal-placeholder');
            if (!grid || !placeholder) return;

            // æ›´æ–°UIçŠ¶æ€
            body.querySelectorAll('.tab-btn').forEach(btn => btn.classList.toggle('active', btn.dataset.filter === filterType));
            body.querySelector('.guixu-sort-select').value = this.currentGuixuSort;
            body.querySelector('.points-display span').textContent = `å½’å¢Ÿç‚¹: ${guixuPoints}`;

            if (!filteredItems || filteredItems.length === 0) {
                grid.innerHTML = '';
                placeholder.style.display = 'block';
                return;
            }
            
            placeholder.style.display = 'none';

            const fragment = document.createDocumentFragment();
            
            // åˆ›å»ºæˆ–æ›´æ–°DOMå…ƒç´ 
            filteredItems.forEach((item, index) => {
               let card = this.guixuItemDOMElements[item.id];
               if (!card) {
                   const tierStyle = this.getNewTierStyle(item.tier);
                   const cardHtml = `
                       <div class="item-content">
                         <h4 class="item-name" style="${tierStyle}">
                           ${item.name}
                           <span class="item-tier">${item.tier}</span>
                         </h4>
                         <p class="item-description">${item.description}</p>
                       </div>
                       <div class="item-footer">
                         <span class="item-price">${item.price} ç‚¹</span>
                         <button class="purchase-btn" data-item-id="${item.id}"></button>
                       </div>`;
                   card = document.createElement('div');
                   card.className = 'guixu-item-card';
                   card.innerHTML = cardHtml;
                   this.guixuItemDOMElements[item.id] = card;
               }
               
               // æ›´æ–°åŠ¨æ€å†…å®¹
               card.style.animationDelay = `${index * 0.05}s`;
               const purchaseBtn = card.querySelector('.purchase-btn');
               purchaseBtn.disabled = guixuPoints < item.price;
               purchaseBtn.textContent = 'è´­ä¹°';
               
               fragment.appendChild(card);
            });
            
            // ä¸€æ¬¡æ€§æ›´æ–°DOM
            grid.innerHTML = ''; // æ¸…ç©º
            grid.appendChild(fragment); // é™„åŠ 
          },

          bindGuixuSpaceEvents(container) {
              // --- ä¿®å¤ï¼šåˆ†ç¦»clickå’Œchangeäº‹ä»¶å¤„ç†å™¨ï¼Œè§£å†³ç‚¹å‡»å³åˆ·æ–°çš„bug ---
              const clickHandler = (event) => {
                  const target = event.target;
                  if (target.classList.contains('purchase-btn')) {
                      if (target.disabled) {
                          this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³');
                          return;
                      }
                      const itemId = target.dataset.itemId;
                      this.handlePurchase(itemId);
                  } else if (target.classList.contains('tab-btn')) {
                      const filter = target.dataset.filter;
                      this.showGuixuSpace(filter, true);
                  }
              };

              const changeHandler = (event) => {
                  const target = event.target;
                  if (target.classList.contains('guixu-sort-select')) {
                      this.currentGuixuSort = target.value;
                      this.showGuixuSpace(this.currentGuixuFilter, true);
                  }
              };

              if (!this.guixuEventHandlers) {
                  this.guixuEventHandlers = new WeakMap();
              }

              if (this.guixuEventHandlers.has(container)) {
                  const oldHandlers = this.guixuEventHandlers.get(container);
                  container.removeEventListener('click', oldHandlers.click);
                  container.removeEventListener('change', oldHandlers.change);
              }

              container.addEventListener('click', clickHandler);
              container.addEventListener('change', changeHandler);
              
              this.guixuEventHandlers.set(container, {
                  click: clickHandler,
                  change: changeHandler
              });
          },

          // --- æ–°å¢ï¼šå½’å¢Ÿç©ºé—´UIé™é»˜åˆ·æ–° ---
          _silentUpdateGuixuSpaceUI() {
              const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
              const modalBody = document.querySelector('#guixu-space-modal .modal-body');
              if (!modalBody) return;

              // 1. æ›´æ–°å½’å¢Ÿç‚¹æ˜¾ç¤º
              const pointsDisplay = modalBody.querySelector('.points-display span');
              if (pointsDisplay) {
                  pointsDisplay.textContent = `å½’å¢Ÿç‚¹: ${guixuPoints}`;
              }

              // 2. æ›´æ–°æ‰€æœ‰è´­ä¹°æŒ‰é’®çš„çŠ¶æ€
              this.guixuStoreItems.forEach(item => {
                  const purchaseBtn = modalBody.querySelector(`button[data-item-id="${item.id}"]`);
                  if (purchaseBtn) {
                      purchaseBtn.disabled = guixuPoints < item.price;
                  }
              });
              console.log('[å½’å¢Ÿç©ºé—´] UIé™é»˜åˆ·æ–°å®Œæˆ');
          },

          // --- çº¯å‰ç«¯MVUæŒ‡ä»¤æ‰§è¡Œ ---
          async executeMvuCommandFrontend(command, options = { silent: false }) {
              console.log(`[å½’å¢Ÿ-å‰ç«¯æ‰§è¡Œ] å‘½ä»¤: ${command}`, `(Silent: ${options.silent})`);
              const modifiedState = this._applyUpdateFallback(command, this.currentMvuState);
              if (modifiedState) {
                  this.currentMvuState = modifiedState;
                  if (!options.silent) {
                      this.renderUI(this.currentMvuState.stat_data);
                  }
                  console.log('[å½’å¢Ÿ-å‰ç«¯æ‰§è¡Œ] å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆæ‰§è¡ŒæˆåŠŸ');
              } else {
                  throw new Error('MVUå‰ç«¯å‘½ä»¤æ‰§è¡Œå¤±è´¥');
              }
          },

          // --- å½’å¢Ÿç©ºé—´ï¼šå¤„ç†è´­ä¹° (å·²é‡æ„ï¼ŒåŒ…å«äºŒæ¬¡ç¡®è®¤å’Œæ­£ç¡®çš„æŒ‡ä»¤æ ¼å¼) ---
          async handlePurchase(itemId) {
              const item = this.guixuStoreItems.find(i => i.id === itemId);
              if (!item) {
                  console.error('æ‰¾ä¸åˆ°è¦è´­ä¹°çš„å•†å“:', itemId);
                  return;
              }

              const currentPoints = parseInt(this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0), 10);

              if (currentPoints < item.price) {
                  this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³');
                  return;
              }

              const confirmMessage = `ç¡®å®šè¦èŠ±è´¹ ${item.price} å½’å¢Ÿç‚¹è´­ä¹°ã€${item.name}ã€‘å—ï¼Ÿ`;

              this.showCustomConfirm(confirmMessage, async () => {
                  try {
                      // 1. æ„å»ºå¹¶æ‰§è¡Œæ‰£æ¬¾æŒ‡ä»¤
                      const deductCommand = `_.add('å½’å¢Ÿç‚¹[0]', -${item.price}); // è´­ä¹° ${item.name}`;
                      await this.executeMvuCommandFrontend(deductCommand, { silent: true });

                      // 2. é™é»˜æŒä¹…åŒ–çŠ¶æ€
                      const messageId = getCurrentMessageId();
                      if (messageId >= 0) {
                          await setChatMessage({ data: this.currentMvuState }, messageId, { refresh: 'none' });
                      }

                      // 3. æ„å»ºæ­£ç¡®çš„çº¯æ–‡æœ¬æŒ‡ä»¤å¹¶æ·»åŠ åˆ°é˜Ÿåˆ—
                      const gainMessage = `<user>è´­ä¹°äº†${item.name}ï¼Œè¯¦ç»†ä¿¡æ¯ï¼š\n${item.fullContent}`;
                      this.pendingActions.push({
                          action: 'send_as_is', // ä½¿ç”¨ä¸€ä¸ªçº¯æ–‡æœ¬æ ‡è¯†ï¼Œé¿å…è¢«è§£æä¸ºæœªçŸ¥æŒ‡ä»¤
                          text: `[è·å¾—] ${item.name}`, // æŒ‡ä»¤ä¸­å¿ƒæ˜¾ç¤ºçš„æ–‡æœ¬
                          command: gainMessage // æ‰§è¡Œæ—¶å‘é€çš„åŸå§‹æ–‡æœ¬
                      });
                      this.savePendingActions();
                      
                      this.showTemporaryMessage(`è´­ä¹°æˆåŠŸï¼šã€${item.name}ã€‘ã€‚è·å¾—æŒ‡ä»¤å·²å‘é€è‡³æŒ‡ä»¤ä¸­å¿ƒã€‚`);
                      this._silentUpdateGuixuSpaceUI(); // é™é»˜åˆ·æ–°UI,ä¸è·³è½¬

                  } catch (error) {
                      console.error('è´­ä¹°è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
                      this.showTemporaryMessage(`è´­ä¹°å¤±è´¥: ${error.message}`);
                  }
              }, null, true, { customClass: 'guixu-confirm-modal' }); // æ–°å¢ï¼šä¼ å…¥è‡ªå®šä¹‰æ ·å¼ç±»
          },

          openModal(modalId, keepOpen = false) {
            if (!keepOpen) {
                this.closeAllModals();
            }
            const modal = document.getElementById(modalId);
            if (modal) {
                // --- æ–°å¢ä¿®å¤é€»è¾‘ ---
                const rootContainer = document.querySelector('.guixu-root-container');
                // æ£€æŸ¥æ¨¡æ€æ¡†æ˜¯å¦ä¸åœ¨æ ¹å®¹å™¨å†…
                if (rootContainer && modal.parentNode !== rootContainer) {
                    // å¦‚æœæ˜¯ï¼Œåˆ™å°†å…¶ç§»åŠ¨åˆ°æ ¹å®¹å™¨çš„æœ«å°¾ï¼Œä»¥ç¡®ä¿å®ƒåœ¨å…¨å±æ—¶å¯è§
                    rootContainer.appendChild(modal);
                    console.log(`[å½’å¢Ÿä¿®å¤] å·²å°†æ¨¡æ€æ¡† #${modalId} ç§»åŠ¨åˆ°ä¸»å®¹å™¨å†…ä»¥å…¼å®¹å…¨å±æ¨¡å¼ã€‚`);
                }
                // --- ä¿®å¤é€»è¾‘ç»“æŸ ---

                modal.style.display = 'flex';
                if (keepOpen) {
                    // Find the highest z-index among visible modals and set the new one higher
                    const highestZ = Array.from(document.querySelectorAll('.modal-overlay'))
                        .filter(el => el.style.display === 'flex' && el.id !== modalId)
                        .reduce((maxZ, el) => Math.max(maxZ, parseInt(window.getComputedStyle(el).zIndex, 10) || 1000), 1000);
                    modal.style.zIndex = highestZ + 1;
                } else {
                    modal.style.zIndex = ''; // Reset to default CSS z-index
                }
                
                // --- æ–°å¢ï¼šåº”ç”¨ä¿å­˜çš„æ¨¡æ€æ¡†å¤§å°è®¾ç½® ---
                this.applyModalSizeToModal(modal);

            }
          },

          // æ–°å¢ï¼šä¸ºç‰¹å®šæ¨¡æ€æ¡†åº”ç”¨å¤§å°è®¾ç½®
          applyModalSizeToModal(modal) {
              try {
                  // --- æ ¸å¿ƒä¿®å¤ï¼šå¦‚æœæ¨¡æ€æ¡†æ˜¯å®šåˆ¶åŒ–ç¡®è®¤æ¡†ï¼Œåˆ™è·³è¿‡å…¨å±€å¤§å°è°ƒæ•´ ---
                  if (modal.classList.contains('guixu-confirm-modal')) {
                      return;
                  }
                  const savedState = localStorage.getItem('guixu_modal_size');
                  // è±å…äººç‰©å…³ç³»æ¨¡æ€æ¡†ï¼Œå®ƒçš„å°ºå¯¸ç”±å…¶å†…éƒ¨CSSæ§åˆ¶
                  if (savedState && modal.id !== 'relationships-modal') {
                      const { width, height } = JSON.parse(savedState);
                      if (width && height) {
                          const modalContent = modal.querySelector('.modal-content');
                          if (modalContent) {
                              modalContent.style.maxWidth = `${width}px`;
                              modalContent.style.width = `${Math.min(width, window.innerWidth * 0.9)}px`;
                              modalContent.style.height = `${Math.min(height, window.innerHeight * 0.9)}px`;
                              modalContent.style.maxHeight = `${Math.min(height, window.innerHeight * 0.9)}px`;
                              modalContent.style.overflow = 'auto';
                          }
                      }
                  }
              } catch (e) {
                  console.error('åº”ç”¨æ¨¡æ€æ¡†å¤§å°è®¾ç½®å¤±è´¥:', e);
              }
          },

          closeModal(modalId) {
              const modal = document.getElementById(modalId);
              if (modal) {
                  modal.style.display = 'none';
                  modal.style.zIndex = ''; // Reset z-index

              }
          },

          // --- æ–°å¢ï¼šå¤„ç†æ¨¡æ€æ¡†å…³é—­çš„ç»Ÿä¸€æ–¹æ³• ---
           handleModalClose(event) {
            const modalOverlay = event.target.closest('.modal-overlay');

           if (modalOverlay && modalOverlay.id === 'guixu-space-modal') {
               this.closeModal('guixu-space-modal');
               this.openModal('guixu-system-modal');
               return;
           }

            // --- è¡æ¢¦å°˜å­çª—å£å…³é—­é€»è¾‘ä¿®æ”¹ ---
            if (modalOverlay && (modalOverlay.id === 'gacha-results-modal' || modalOverlay.id === 'gacha-history-modal' || modalOverlay.id === 'gacha-details-modal' || modalOverlay.id === 'gacha-gallery-popup' || modalOverlay.id === 'gacha-settings-popup')) {
        this.closeModal(modalOverlay.id); // åªå…³é—­å½“å‰å­çª—å£
                 // æ ¸å¿ƒä¿®å¤ï¼šå¦‚æœå…³é—­çš„æ˜¯å¬å”¤ç»“æœçª—å£ï¼Œåˆ™åˆ·æ–°å¬å”¤ä¸»ç•Œé¢
                if (modalOverlay.id === 'gacha-results-modal') {
                    this.renderSummonTab(this.currentGachaPoolType);
                }
                return; // ç»“æŸå¤„ç†
            }

            // --- è¡æ¢¦å°˜ä¸»çª—å£å…³é—­é€»è¾‘ ---
            if (modalOverlay && modalOverlay.id === 'gacha-modal') {
                // æ£€æŸ¥æ˜¯å¦ä»å½’å¢Ÿç³»ç»Ÿè¿›å…¥
                if (this.isFromGuixuSystem) {
                    this.closeModal(modalOverlay.id); // å…³é—­gachaä¸»çª—å£
                    this.showGuixuSystem(); // è¿”å›å½’å¢Ÿç³»ç»Ÿç•Œé¢
                    this.isFromGuixuSystem = false; // é‡ç½®æ ‡å¿—
                    return; // ç»“æŸå¤„ç†
                }
                // å¦‚æœä¸æ˜¯ä»å½’å¢Ÿç³»ç»Ÿè¿›å…¥ï¼Œåˆ™ä¼šæ‰§è¡Œä¸‹é¢çš„é»˜è®¤å…³é—­é€»è¾‘
            }

            if (!modalOverlay) {
              this.closeAllModals();
              return;
            }

            const modalId = modalOverlay.id;
            
            // ç‰¹æ®Šå¤„ç†æ ¼å¼éªŒè¯æ¨¡æ€æ¡†å…³é—­
            if (modalId === 'format-validation-modal') {
              // å…³é—­ç­‰å¾…æ¶ˆæ¯
              this.hideWaitingMessage();
              // å¡«å……åŸå§‹å†…å®¹è€Œä¸æ˜¯æ¸…ç©º
              const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay && this.lastValidGametxtHTML) {
                gameTextDisplay.innerHTML = this.lastValidGametxtHTML;
                this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
              }
              this.closeModal(modalId);
              this.showTemporaryMessage('å·²å–æ¶ˆæ ¼å¼éªŒè¯ï¼Œå†…å®¹å·²æ¢å¤ã€‚');
              return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯ä»è®¾ç½®ç•Œé¢è¿›å…¥çš„å­çª—å£
            if (this.isFromSettingsModal &&
                (modalId === 'command-center-modal' ||
                 modalId === 'extracted-content-modal' ||
                 modalId === 'map-modal' ||
                 modalId === 'background-settings-modal' ||
                 modalId === 'worldbook-manager-modal' ||
                 modalId === 'segmented-memory-modal')) { // æ–°å¢å¯¹åˆ†æ®µè®°å¿†æ¨¡æ€æ¡†çš„åˆ¤æ–­
              // å…³é—­å½“å‰å­çª—å£å¹¶è¿”å›è®¾ç½®ç•Œé¢
              this.closeModal(modalId);
              this.isFromSettingsModal = false; // é‡ç½®çŠ¶æ€
              this.showSettings();
            } else {
              // æ­£å¸¸å…³é—­æ‰€æœ‰æ¨¡æ€æ¡†
              this.closeAllModals();
            }
          },

          closeAllModals() {
            document.querySelectorAll('.modal-overlay').forEach(modal => {
              modal.style.display = 'none';
            });
           // æ–°å¢ï¼šå…³é—­åœ°å›¾æ—¶é‡ç½®å…¶çŠ¶æ€
           this.resetMapState();
           // æ³¨é‡Šæ‰ï¼šä¸åœ¨è¿™é‡Œé‡ç½®è®¾ç½®çŠ¶æ€æ ‡å¿—ï¼Œè®©handleModalCloseæ¥å¤„ç†
           // this.isFromSettingsModal = false;
           
           // åŒæ—¶å…³é—­çª—å£å¤§å°è°ƒæ•´é¢æ¿
           this.hideWindowSizePanel();
          },

          showCustomConfirm(message, onConfirm, onCancel = null, keepCurrentModal = false, options = {}) {
            const modal = document.getElementById('custom-confirm-modal');
            const messageEl = document.getElementById('custom-confirm-message');
            const okBtn = document.getElementById('custom-confirm-btn-ok');
            const cancelBtn = document.getElementById('custom-confirm-btn-cancel');
            const closeBtn = modal?.querySelector('.modal-close-btn');

            if (!modal || !messageEl || !okBtn || !cancelBtn) return;

            // --- æ–°å¢ï¼šå¤„ç†è‡ªå®šä¹‰æ ·å¼ç±» ---
            if (options.customClass) {
                modal.classList.add(options.customClass);
            }

            messageEl.textContent = message;

            // ä½¿ç”¨ .cloneNode(true) æ¥ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            const newOkBtn = okBtn.cloneNode(true);
            okBtn.parentNode.replaceChild(newOkBtn, okBtn);

            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            const closeAction = () => {
                // --- æ–°å¢ï¼šæ¸…ç†è‡ªå®šä¹‰æ ·å¼ç±» ---
                if (options.customClass) {
                    modal.classList.remove(options.customClass);
                }
                if (keepCurrentModal) {
                    this.closeModal('custom-confirm-modal');
                    // å¦‚æœæ˜¯ä»é¢„è®¾ç®¡ç†ç•Œé¢è¿›å…¥çš„ï¼Œè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
                    if (this.isFromWorldbookManager) {
                        this.showWorldbookPresets();
                    }
                } else {
                    this.closeAllModals();
                }
            };

            newOkBtn.addEventListener('click', () => {
              closeAction();
              if (typeof onConfirm === 'function') {
                onConfirm();
              }
            });

            newCancelBtn.addEventListener('click', () => {
              closeAction();
              if (typeof onCancel === 'function') {
                onCancel();
              }
            });

            // å¤„ç†å…³é—­æŒ‰é’®ï¼ˆÃ—ï¼‰
            if (closeBtn) {
              closeBtn.onclick = () => {
                closeAction();
                if (typeof onCancel === 'function') {
                  onCancel();
                }
              };
            }

            this.openModal('custom-confirm-modal', keepCurrentModal);
          },

          // --- Feature Implementations (now simplified) ---
           async showMap() {
             // ä¼˜åŒ–ï¼šåªåœ¨é¦–æ¬¡æ‰“å¼€æ—¶è¯»å–æ•°æ®ï¼Œä¹‹ååªæ˜¾ç¤º/éšè—
             const modal = document.getElementById('map-modal');
             const body = document.querySelector('#map-modal-body');
             if (!modal || !body) return;

             // å¦‚æœåœ°å›¾å†…å®¹å°šæœªåŠ è½½ï¼Œåˆ™æ‰§è¡Œä¸€æ¬¡æ€§åŠ è½½
             if (!body.dataset.loaded) {
                body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨åŠ è½½åœ°å›¾æ•°æ®...</p>';
                this.openModal('map-modal');

                try {
                    const bookName = '1å½’å¢Ÿ';
                    const mapEntryKey = 'åœ°å›¾';
                    const allEntries = await TavernHelper.getLorebookEntries(bookName);
                    const mapEntry = allEntries.find(entry => entry.comment === mapEntryKey);

                    if (!mapEntry || !mapEntry.content) {
                        body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">åœ¨ä¸–ç•Œä¹¦â€œ1å½’å¢Ÿâ€ä¸­æœªæ‰¾åˆ°â€œåœ°å›¾â€æ¡ç›®æˆ–å†…å®¹ä¸ºç©ºã€‚</p>';
                        return;
                    }

                    const locations = this.parseMapData(mapEntry.content);
                    console.log('[å½’å¢Ÿåœ°å›¾] è§£æå‡ºçš„åœ°ç‚¹æ•°æ®:', locations);

                    const stat_data = this.currentMvuState?.stat_data;
                    const playerPos = stat_data ? this.SafeGetValue(stat_data, 'å½“å‰ä½ç½®', null) : null;
                    
                    // æ¸²æŸ“åœ°å›¾å†…å®¹
                    this.renderMap(body, locations, playerPos);
                    
                    // ä¸ºåœ°å›¾å®¹å™¨ç»‘å®šä¸€æ¬¡æ€§äº‹ä»¶
                    this.bindMapEvents(body);
                    
                    // æ ‡è®°ä¸ºå·²åŠ è½½
                    body.dataset.loaded = 'true';

                } catch (error) {
                    console.error('åŠ è½½åœ°å›¾æ•°æ®æ—¶å‡ºé”™:', error);
                    body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:red; font-size:12px;">åŠ è½½åœ°å›¾å¤±è´¥: ${error.message}</p>`;
                }
             } else {
                // å¦‚æœå·²åŠ è½½ï¼Œç›´æ¥æ‰“å¼€æ¨¡æ€æ¡†
                this.openModal('map-modal');
             }
           },

           parseMapData(content) {
               if (!content || typeof content !== 'string') return [];
               const locations = [];
               const lines = content.trim().split('\n');

               lines.forEach(line => {
                   if (!line.startsWith('[') || !line.endsWith(']')) return; // è·³è¿‡æ ¼å¼ä¸æ­£ç¡®çš„è¡Œ

                   const parts = line.substring(1, line.length - 1).split('|');
                   if (parts.length < 3) return; // è‡³å°‘éœ€è¦ åç§°, x, y

                   const locationData = { name: parts[0].trim() };
                   let hasX = false;
                   let hasY = false;

                   // ä»ç´¢å¼•1å¼€å§‹éå†ï¼Œå› ä¸ºç´¢å¼•0æ˜¯åç§°
                   for (let i = 1; i < parts.length; i++) {
                       const part = parts[i].trim();
                       const separatorIndex = part.indexOf(':');

                       // å¼ºåˆ¶è¦æ±‚æ‰€æœ‰å­—æ®µéƒ½å¿…é¡»æ˜¯ key:value æ ¼å¼
                       if (separatorIndex === -1) {
                           console.warn(`[å½’å¢Ÿåœ°å›¾] æ— æ•ˆçš„é”®å€¼å¯¹æ ¼å¼ï¼Œå·²è·³è¿‡éƒ¨åˆ†: "${part}" in line: "${line}"`);
                           continue; // è·³è¿‡è¿™ä¸ªæ ¼å¼é”™è¯¯çš„éƒ¨åˆ†
                       }

                       const key = part.substring(0, separatorIndex).trim();
                       const value = part.substring(separatorIndex + 1).trim();

                       if (key && value) {
                           locationData[key] = value;
                           if (key === 'x') hasX = true;
                           if (key === 'y') hasY = true;
                       }
                   }

                   // åªæœ‰å½“æ˜ç¡®åŒ…å«xå’Œyåæ ‡æ—¶ï¼Œæ‰å°†åœ°ç‚¹æ·»åŠ åˆ°åˆ—è¡¨ä¸­
                   if (hasX && hasY) {
                       locations.push(locationData);
                   } else {
                       console.warn(`[å½’å¢Ÿåœ°å›¾] è·³è¿‡ä¸åŒ…å«æœ‰æ•ˆx,yåæ ‡çš„åœ°ç‚¹:`, line);
                   }
               });

               return locations;
           },

           renderMap(container, locations, playerPos = null) {
                if (!container) return;
 
                container.innerHTML = ''; // æ¸…ç©ºæ—§å†…å®¹

               const mapContainer = document.createElement('div');
               mapContainer.className = 'map-container';

               // --- æœ€ç»ˆçš„ã€å®Œå–„çš„JSåŠ¨æ€ç½‘æ ¼ ---
               const gridContainer = document.createElement('div');
               const mapSize = 10000; // åˆ›å»ºä¸€ä¸ªå·¨å¤§çš„è™šæ‹Ÿç½‘æ ¼å°ºå¯¸
               const gridSize = 15;   // æ‚¨æœŸæœ›çš„ç½‘æ ¼å¯†åº¦
               const gridColor = '#cccccc'; // æ¸…æ™°çš„æ·¡ç°è‰²

               // ä½¿ç”¨ transform å±…ä¸­è¿™ä¸ªå·¨å¤§çš„ç½‘æ ¼
               gridContainer.style.cssText = `
                   position: absolute;
                   left: 50%;
                   top: 50%;
                   transform: translate(-50%, -50%);
                   width: ${mapSize}px;
                   height: ${mapSize}px;
                   z-index: 0;
                   pointer-events: none;
               `;

               for (let i = 0; i < mapSize; i += gridSize) {
                   // å‚ç›´çº¿
                   const vLine = document.createElement('div');
                   vLine.style.cssText = `position: absolute; left: ${i}px; top: 0; width: 1px; height: 100%; background-color: ${gridColor};`;
                   gridContainer.appendChild(vLine);
                   // æ°´å¹³çº¿
                   const hLine = document.createElement('div');
                   hLine.style.cssText = `position: absolute; left: 0; top: ${i}px; width: 100%; height: 1px; background-color: ${gridColor};`;
                   gridContainer.appendChild(hLine);
               }
               mapContainer.appendChild(gridContainer);
               // --- ç½‘æ ¼ç»˜åˆ¶ç»“æŸ ---

               const SCALE_FACTOR = 100; // å°†ä¸–ç•Œåæ ‡ç¼©å°100å€ä»¥é€‚åº”åƒç´ 

               locations.forEach(loc => {
                   const dot = document.createElement('div');
                   dot.className = 'map-location-dot';

                   const width = parseInt(loc.w || loc.width || 10, 10);
                   const height = parseInt(loc.h || loc.height || 10, 10);
                   const area = width * height;
                   // é¢ç§¯è¶Šå°ï¼Œz-indexè¶Šé«˜ã€‚è®¾ç½®ä¸€ä¸ªåŸºç¡€å€¼ï¼ˆå¦‚10ï¼‰ï¼Œç„¶ååŠ ä¸Šä¸€ä¸ªä¸é¢ç§¯æˆåæ¯”çš„å€¼ã€‚
                   // 100000 æ˜¯ä¸€ä¸ªè°ƒèŠ‚å› å­ï¼Œå¯ä»¥æ ¹æ®å®é™…æƒ…å†µè°ƒæ•´ã€‚
                   dot.style.zIndex = 10 + Math.floor(100000 / (area + 1));

                   const x = parseFloat(loc.x) / SCALE_FACTOR;
                   const y = parseFloat(loc.y) / SCALE_FACTOR;

                   if (isNaN(x) || isNaN(y)) {
                       console.warn('[å½’å¢Ÿåœ°å›¾] åœ°ç‚¹åæ ‡æ— æ•ˆï¼Œè·³è¿‡æ¸²æŸ“:', loc.name, loc.x, loc.y);
                       return; // è·³è¿‡æ— æ•ˆåæ ‡çš„åœ°ç‚¹
                   }
                   
                   // åæ ‡ç›¸å¯¹äºä¸­å¿ƒç‚¹ (50%, 50%) è¿›è¡Œåç§»
                   dot.style.left = `calc(50% + ${x}px)`;
                   dot.style.top = `calc(50% + ${y}px)`;
                   
                   dot.textContent = loc.name; // ç›´æ¥å°†åç§°ä½œä¸ºå†…å®¹
                   dot.dataset.state = loc.state || 'æ­£å¸¸';
                   dot.dataset.type = loc.type || 'ä¸­ç«‹'; // ç¡®ä¿æ€»æœ‰ä¸€ä¸ªtype

                   dot.style.width = `${width}px`;
                   dot.style.height = `${height}px`;

                   // ä¿®æ­£å­—ä½“å¤§å°è®¡ç®—é€»è¾‘ï¼Œç¡®ä¿æ–‡æœ¬å®Œå…¨å®¹çº³
                   const FONT_SCALING_FACTOR = 0.9; // ä½¿ç”¨å°äº1çš„ç³»æ•°æ¥å¢åŠ æ°´å¹³è¾¹è·
                   const minHeightBasedSize = height * 0.8; // å‚ç›´æ–¹å‘æœ€å¤šå 80%
                   const minWidthBasedSize = (width / loc.name.length) * FONT_SCALING_FACTOR;
                   const baseFontSize = Math.max(4, Math.min(minHeightBasedSize, minWidthBasedSize));
                   dot.style.fontSize = `${baseFontSize}px`;

                   // æ ¹æ®ç±»å‹è®¾ç½®ä¸åŒèƒŒæ™¯é¢œè‰²
                   const typeColors = {
                     'å®—é—¨': 'rgba(66, 165, 245, 0.8)', // è“è‰²
                     'é™©åœ°': 'rgba(239, 83, 80, 0.8)', // çº¢è‰²
                     'ä»™å®«': 'rgba(255, 215, 0, 0.8)', // é‡‘è‰²
                     'ä¸­ç«‹': 'rgba(189, 189, 189, 0.8)', // ç°è‰²
                     'åŸæ± ': 'rgba(161, 136, 127, 0.8)', // æ£•è‰²
                   };

                   if (loc.type && typeColors[loc.type]) {
                     dot.style.backgroundColor = typeColors[loc.type]; // ä¿®æ”¹ä¸ºè®¾ç½®èƒŒæ™¯è‰²
                   }
                   
                   dot.addEventListener('click', (e) => {
                       e.stopPropagation();
                       // æ–°å¢ï¼šç‚¹å‡»åå¼¹å‡ºç¡®è®¤æ¡†ï¼Œç¡®è®¤åå°†æŒ‡ä»¤åŠ å…¥é˜Ÿåˆ—
                       // ç¬¬ä¸‰ä¸ªå‚æ•° true è®©ç¡®è®¤æ¡†å åŠ åœ¨å½“å‰åœ°å›¾ä¸Šï¼Œè€Œä¸æ˜¯å…³é—­åœ°å›¾
                       this.showCustomConfirm(`ä½ ç¡®å®šè¦å‰å¾€ã€${loc.name}ã€‘å—ï¼Ÿ`, () => {
                           this.addTravelAction(loc);
                       }, true);
                   });

                   mapContainer.appendChild(dot);
               });

               // åœ¨å¾ªç¯ä¹‹åï¼Œæ·»åŠ æ¸²æŸ“ç©å®¶å…‰æ ‡çš„é€»è¾‘
                if (playerPos && playerPos.x !== undefined && playerPos.y !== undefined) {
                    const cursor = document.createElement('div');
                    cursor.className = 'player-cursor';
                    
                    // ç»Ÿä¸€ä½¿ç”¨åƒç´ å®šä½
                    const playerX = parseFloat(playerPos.x) / SCALE_FACTOR;
                    const playerY = parseFloat(playerPos.y) / SCALE_FACTOR;

                    if (!isNaN(playerX) && !isNaN(playerY)) {
                        cursor.style.left = `calc(50% + ${playerX}px)`;
                        cursor.style.top = `calc(50% + ${playerY}px)`;
                        cursor.title = `ä½ åœ¨è¿™é‡Œï¼š${playerPos.area_name || 'æœªçŸ¥åŒºåŸŸ'} (x:${playerPos.x}, y:${playerPos.y})`;
                        cursor.style.zIndex = '10'; // ç¡®ä¿åœ¨åœ°ç‚¹ä¹‹ä¸Š
                        mapContainer.appendChild(cursor);
                        // æ–°å¢ï¼šç¼“å­˜ç©å®¶åœ¨åœ°å›¾å®¹å™¨ä¸­çš„åƒç´ ä½ç½®
                        this.mapState.playerMapPos = { x: playerX, y: playerY };
                    } else {
                        this.mapState.playerMapPos = null;
                    }
                } else {
                   this.mapState.playerMapPos = null;
                }

                // æ ¹æ®æ˜¯å¦å­˜åœ¨ç©å®¶ä½ç½®æ¥å¯ç”¨/ç¦ç”¨æŒ‰é’®
                const centerBtn = document.getElementById('btn-center-player');
                if(centerBtn) {
                   centerBtn.disabled = !this.mapState.playerMapPos;
                }

               container.appendChild(mapContainer);
              
              this.updateMapTransform();
              this.updateZoomSliderUI(); // æ–°å¢ï¼šåˆå§‹åŒ–æ»‘å—UI
          },

          async showInventory() {
            this.openModal('inventory-modal');
            const body = document.querySelector('#inventory-modal .modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨æ¸…ç‚¹è¡Œå›Š...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                body.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ— æ³•è·å–èƒŒåŒ…æ•°æ®ã€‚</p>';
                console.warn('æ— æ³•ä»å½“å‰æ¶ˆæ¯ä¸­åŠ è½½ stat_data ç”¨äºèƒŒåŒ…ã€‚');
                return;
              }
              const stat_data = messages[0].data.stat_data;
              body.innerHTML = this.renderInventory(stat_data || {});
            } catch (error) {
              console.error('åŠ è½½èƒŒåŒ…æ—¶å‡ºé”™:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">åŠ è½½èƒŒåŒ…æ—¶å‡ºé”™: ${error.message}</p>`;
            }
          },

          // æ–°å¢ï¼šæ˜¾ç¤ºä¸–ç•Œå¤§äº‹
          async showWorldEvents() {
            this.openModal('world-events-modal');
            const body = document.querySelector('#world-events-modal .modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨åŠ è½½ä¸–ç•Œå¤§äº‹...</p>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                body.innerHTML =
                  '<div class="world-events-empty"><div class="world-events-empty-icon">ğŸŒ</div><div class="world-events-empty-title">æš‚æ— ä¸–ç•Œå¤§äº‹</div><div class="world-events-empty-description">å½“å‰æ²¡æœ‰å¯æ˜¾ç¤ºçš„ä¸–ç•Œå¤§äº‹è®°å½•</div></div>';
                console.warn('æ— æ³•ä»å½“å‰æ¶ˆæ¯ä¸­åŠ è½½ stat_data ç”¨äºä¸–ç•Œå¤§äº‹ã€‚');
                return;
              }
              const stat_data = messages[0].data.stat_data;
              body.innerHTML = this.renderWorldEvents(stat_data || {});
            } catch (error) {
              console.error('åŠ è½½ä¸–ç•Œå¤§äº‹æ—¶å‡ºé”™:', error);
              body.innerHTML = `<div class="world-events-empty"><div class="world-events-empty-icon">âŒ</div><div class="world-events-empty-title">åŠ è½½å¤±è´¥</div><div class="world-events-empty-description">åŠ è½½ä¸–ç•Œå¤§äº‹æ—¶å‡ºé”™: ${error.message}</div></div>`;
            }

            // ç»‘å®šä¸–ç•Œå¤§äº‹æ¨¡æ€æ¡†å†…çš„æŒ‰é’®äº‹ä»¶
            this.bindWorldEventsModalEvents();
          },

          // æ–°å¢ï¼šç»‘å®šä¸–ç•Œå¤§äº‹æ¨¡æ€æ¡†äº‹ä»¶
          bindWorldEventsModalEvents() {
            // åˆ·æ–°æŒ‰é’®
            document.getElementById('btn-world-events-refresh')?.addEventListener('click', () => {
              this.showWorldEvents();
            });

            // æ—¶é—´è½´æ¨¡å¼æŒ‰é’®
            const timelineModeBtn = document.getElementById('btn-world-events-timeline-mode');
            if (timelineModeBtn) {
              timelineModeBtn.addEventListener('click', () => {
                this.worldEventsViewMode = this.worldEventsViewMode === 'timeline' ? 'list' : 'timeline';
                this.showWorldEvents(); // é‡æ–°æ¸²æŸ“
              });
              // æ›´æ–°æŒ‰é’®æ–‡æœ¬
              timelineModeBtn.textContent = this.worldEventsViewMode === 'timeline' ? 'åˆ‡æ¢ä¸ºåˆ—è¡¨æ¨¡å¼' : 'åˆ‡æ¢ä¸ºæ—¶é—´è½´æ¨¡å¼';
            }
          },

          // æ–°å¢ï¼šæ¸²æŸ“ä¸–ç•Œå¤§äº‹HTML
          renderWorldEvents(stat_data) {
            // æ£€æŸ¥æ˜¯å¦æœ‰ä¸–ç•Œå¤§äº‹æ•°æ®
            const worldEvents = stat_data.ä¸–ç•Œå¤§äº‹ || stat_data.world_events || {};
            
            if (!worldEvents || Object.keys(worldEvents).length === 0) {
              return `
                <div class="world-events-empty">
                  <div class="world-events-empty-icon">ğŸŒ</div>
                  <div class="world-events-empty-title">æš‚æ— ä¸–ç•Œå¤§äº‹</div>
                  <div class="world-events-empty-description">å½“å‰ä¸–ç•Œè¿˜æ²¡æœ‰å‘ç”Ÿé‡å¤§äº‹ä»¶</div>
                </div>
              `;
            }

            // å°†ä¸–ç•Œå¤§äº‹è½¬æ¢ä¸ºæ•°ç»„å¹¶æŒ‰æ—¶é—´æ’åº
            const eventsArray = Object.entries(worldEvents)
              .filter(([_, event]) => typeof event === 'object' && event !== null)
              .map(([key, event]) => ({ id: key, ...event }));

            // æŒ‰æ—¶é—´æ’åº
            eventsArray.sort((a, b) => {
                const timeA = a.æ—¶é—´?.æ—¥æœŸ || a.time?.æ—¥æœŸ || a.id;
                const timeB = b.æ—¶é—´?.æ—¥æœŸ || b.time?.æ—¥æœŸ || b.id;
                // ç®€å•çš„å­—ç¬¦ä¸²æ¯”è¾ƒå¯èƒ½ä¸é€‚ç”¨äºæ‰€æœ‰æ—¥æœŸæ ¼å¼ï¼Œä½†å¯¹äº "ç„æ˜Šå†Xå¹´XæœˆXæ—¥" æ ¼å¼æ˜¯æœ‰æ•ˆçš„
                return timeB.localeCompare(timeA);
            });

            if (this.worldEventsViewMode === 'list') {
              let html = '<div class="world-events-list">';
              eventsArray.forEach(event => {
                const title = event.title || event.æ ‡é¢˜ || 'æœªçŸ¥äº‹ä»¶';
                let timeString = '';
                 if (event.time || event.æ—¶é—´) {
                    const timeData = event.time || event.æ—¶é—´;
                    const shi = timeData.ç¬¬å‡ ä¸– ? `ç¬¬${timeData.ç¬¬å‡ ä¸–}ä¸– ` : '';
                    const date = timeData.æ—¥æœŸ || '';
                    timeString = `${shi}${date}`;
                }
                html += `
                  <div class="world-events-list-item">
                    <span class="world-events-list-time">${this.escapeHtml(timeString)}</span>
                    <span class="world-events-list-title">${this.escapeHtml(title)}</span>
                  </div>
                `;
              });
              html += '</div>';
              return html;
            } else {
              // é»˜è®¤æ—¶é—´è½´æ¨¡å¼
              let html = '<div class="world-events-timeline"><div class="timeline-container">';
              eventsArray.forEach(event => {
                html += this.renderWorldEventItem(event);
              });
              html += '</div></div>';
              return html;
            }
          },

          // æ–°å¢ï¼šæ¸²æŸ“å•ä¸ªä¸–ç•Œå¤§äº‹é¡¹ç›®
          renderWorldEventItem(event) {
            const title = event.title || event.æ ‡é¢˜ || 'æœªçŸ¥äº‹ä»¶';
            const description = event.description || event.æè¿° || '';
            
            // å¤„ç†æ—¶é—´å¯¹è±¡
            let timeString = '';
            if (event.time || event.æ—¶é—´) {
              const timeData = event.time || event.æ—¶é—´;
              const shi = timeData.ç¬¬å‡ ä¸– ? `ç¬¬${timeData.ç¬¬å‡ ä¸–}ä¸– ` : '';
              const date = timeData.æ—¥æœŸ || '';
              timeString = `${shi}${date}`;
            }
            
            const location = event.location || event.åœ°ç‚¹ || '';
            
            // å¤„ç†å½±å“å¯¹è±¡
            let impactHtml = '';
            if (event.impact || event.å½±å“) {
              const impactData = event.impact || event.å½±å“;
              const shortTerm = impactData.çŸ­æœŸå½±å“ || '';
              const longTerm = impactData.é•¿æœŸå½±å“ || '';
              if (shortTerm || longTerm) {
                impactHtml = `
                    <div class="world-events-impact">
                      <div class="world-events-impact-title">å½±å“ä¸åæœ</div>
                      <div class="world-events-impact-content">
                        ${shortTerm ? `<p><strong>çŸ­æœŸå½±å“:</strong> ${this.escapeHtml(shortTerm)}</p>` : ''}
                        ${longTerm ? `<p><strong>é•¿æœŸå½±å“:</strong> ${this.escapeHtml(longTerm)}</p>` : ''}
                      </div>
                    </div>
                `;
              }
            }

            const tags = event.tags || event.æ ‡ç­¾ || [];
            const importance = event.importance || event.é‡è¦æ€§ || 'normal';

            return `
              <div class="world-events-timeline .timeline-event" data-importance="${importance}">
                <div class="world-events-event-header">
                  <div class="world-events-event-title">${this.escapeHtml(title)}</div>
                  ${timeString ? `<div class="world-events-event-time">${this.escapeHtml(timeString)}</div>` : ''}
                </div>
                <div class="world-events-event-content">
                  ${description ? `<div class="world-events-event-description">${this.escapeHtml(description)}</div>` : ''}
                  ${location ? `<div style="font-size: 12px; color: #c9aa71; margin-bottom: 8px;">ğŸ“ ${this.escapeHtml(location)}</div>` : ''}
                  ${impactHtml}
                  ${tags.length > 0 ? `
                    <div class="world-events-event-tags">
                      ${tags.map(tag => `<span class="world-events-tag">${this.escapeHtml(tag)}</span>`).join('')}
                    </div>
                  ` : ''}
                </div>
              </div>
            `;
          },

          // æ–°å¢ï¼šæ˜¾ç¤ºå˜é‡ä¿®æ”¹å™¨ - å·²ç¦ç”¨
          async showVariableEditor() {
            console.log('[å˜é‡ä¿®æ”¹å™¨] åŠŸèƒ½å·²ç¦ç”¨');
            return;
            /*
            this.openModal('variable-editor-modal');
            this.initVariableEditor();
            
            // åˆå§‹åŒ–æ™ºèƒ½ç¼–è¾‘å™¨åŠŸèƒ½
            this.initKeyboardShortcuts();
            */
          },

          // æ–°å¢ï¼šåˆå§‹åŒ–å˜é‡ä¿®æ”¹å™¨
          initVariableEditor() {
            // é‡ç½®è¡¨å•
            document.getElementById('variable-category').value = '';
            const pathInput = document.getElementById('variable-path');
            if (pathInput) {
              pathInput.value = '';
            }
            document.getElementById('current-variable-value').textContent = 'æœªåŠ è½½';
            document.getElementById('new-variable-value').value = '';
            document.getElementById('change-reason').value = '';
            document.getElementById('mvu-command-preview').textContent = 'è¯·å…ˆåŠ è½½å˜é‡å¹¶è®¾ç½®æ–°å€¼';
            
            // é‡ç½®å˜é‡åˆ—è¡¨
            document.getElementById('variable-list').innerHTML = '<div class="placeholder">è¯·é€‰æ‹©åˆ†ç±»æŸ¥çœ‹å˜é‡</div>';
            
            // è®¾ç½®é»˜è®¤æ“ä½œç±»å‹
            this.setOperationType('set');
            
            // è®¾ç½®é»˜è®¤æ ‡ç­¾é¡µ
            this.switchTab('browse');
            
            // è®¾ç½®é»˜è®¤ç¼–è¾‘æ¨¡å¼
            this.switchEditMode('raw');
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            this.bindVariableEditorEvents();
          },

          // æ–°å¢ï¼šç»‘å®šå˜é‡ä¿®æ”¹å™¨äº‹ä»¶
          bindVariableEditorEvents() {
            // æ ‡ç­¾é¡µåˆ‡æ¢äº‹ä»¶
            document.getElementById('tab-browse').addEventListener('click', () => {
              this.switchTab('browse');
            });
            
            document.getElementById('tab-manual').addEventListener('click', () => {
              this.switchTab('manual');
            });

            // åˆ†ç±»é€‰æ‹©äº‹ä»¶
            document.getElementById('variable-category').addEventListener('change', (e) => {
              this.handleCategoryChange(e.target.value);
            });

            // åŠ è½½å˜é‡æŒ‰é’®ï¼ˆæ‰‹åŠ¨æ¨¡å¼ï¼‰
            const loadBtn = document.getElementById('load-variable-btn');
            if (loadBtn) {
              loadBtn.addEventListener('click', () => {
                this.loadVariableManual();
              });
            }

            // æ“ä½œç±»å‹æŒ‰é’®
            document.querySelectorAll('.operation-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                this.setOperationType(e.target.dataset.op);
              });
            });

            // é¢„è§ˆå‘½ä»¤æŒ‰é’®
            document.getElementById('preview-command-btn').addEventListener('click', () => {
              this.previewMvuCommand();
            });

            // æ‰§è¡Œä¿®æ”¹æŒ‰é’®
            document.getElementById('execute-command-btn').addEventListener('click', () => {
              this.executeMvuCommand();
            });

            // ç¼–è¾‘æ¨¡å¼åˆ‡æ¢æŒ‰é’®
            document.getElementById('mode-raw').addEventListener('click', () => {
              this.switchEditMode('raw');
            });

            document.getElementById('mode-visual').addEventListener('click', () => {
              this.switchEditMode('visual');
            });

            // å˜é‡è·¯å¾„è¾“å…¥å˜åŒ–æ—¶è‡ªåŠ¨é¢„è§ˆ
            document.getElementById('variable-path').addEventListener('input', () => {
              this.previewMvuCommand();
            });

            // æ–°å€¼è¾“å…¥å˜åŒ–æ—¶è‡ªåŠ¨é¢„è§ˆ
            document.getElementById('new-variable-value').addEventListener('input', () => {
              this.previewMvuCommand();
              this.updateVisualEditor();
            });

            // åŸå› è¾“å…¥å˜åŒ–æ—¶è‡ªåŠ¨é¢„è§ˆ
            document.getElementById('change-reason').addEventListener('input', () => {
              this.previewMvuCommand();
            });
          },

          // æ–°å¢ï¼šæ ‡ç­¾é¡µåˆ‡æ¢
          switchTab(tabName) {
            // æ›´æ–°æ ‡ç­¾æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.tab-btn').forEach(btn => {
              btn.classList.remove('active');
            });
            document.getElementById(`tab-${tabName}`).classList.add('active');
            
            // åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
            const browseMode = document.getElementById('browse-mode');
            const manualMode = document.getElementById('manual-mode');
            
            if (tabName === 'browse') {
              browseMode.style.display = 'block';
              manualMode.style.display = 'none';
            } else {
              browseMode.style.display = 'none';
              manualMode.style.display = 'block';
            }
          },

          // æ–°å¢ï¼šå¤„ç†åˆ†ç±»é€‰æ‹©å˜åŒ–
          handleCategoryChange(category) {
            if (category) {
              this.loadVariablesByCategory(category);
            } else {
              document.getElementById('variable-list').innerHTML = '<div class="placeholder">è¯·é€‰æ‹©åˆ†ç±»æŸ¥çœ‹å˜é‡</div>';
            }
          },

          // æ–°å¢ï¼šæ ¹æ®åˆ†ç±»åŠ è½½å˜é‡åˆ—è¡¨
          async loadVariablesByCategory(category) {
            const variableList = document.getElementById('variable-list');
            variableList.innerHTML = '<div class="placeholder">æ­£åœ¨åŠ è½½å˜é‡...</div>';

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                variableList.innerHTML = '<div class="placeholder">æ— æ³•è·å–å˜é‡æ•°æ®</div>';
                return;
              }

              const stat_data = messages[0].data.stat_data;
              const variables = this.getVariablesByCategory(stat_data, category);
              
              if (variables.length === 0) {
                variableList.innerHTML = '<div class="placeholder">è¯¥åˆ†ç±»ä¸‹æš‚æ— å˜é‡</div>';
                return;
              }

              let html = '';
              variables.forEach(variable => {
                html += `
                  <div class="variable-item" data-path="${variable.path}">
                    <span class="variable-name">${variable.name}</span>
                    <span class="variable-value">${variable.displayValue}</span>
                  </div>
                `;
              });

              variableList.innerHTML = html;

              // ç»‘å®šå˜é‡é¡¹ç‚¹å‡»äº‹ä»¶
              variableList.querySelectorAll('.variable-item').forEach(item => {
                item.addEventListener('click', () => {
                  this.selectVariable(item.dataset.path, item.querySelector('.variable-name').textContent);
                });
              });

            } catch (error) {
              console.error('åŠ è½½å˜é‡åˆ—è¡¨æ—¶å‡ºé”™:', error);
              variableList.innerHTML = '<div class="placeholder">åŠ è½½å˜é‡æ—¶å‡ºé”™</div>';
            }
          },

          // æ–°å¢ï¼šæ ¹æ®åˆ†ç±»è·å–å˜é‡
          getVariablesByCategory(stat_data, category) {
            const variables = [];

            switch (category) {
              case 'attributes':
                // åŸºç¡€å±æ€§
                ['æ³•åŠ›', 'ç¥æµ·', 'é“å¿ƒ', 'ç©ºé€Ÿ', 'æ°”è¿'].forEach(attr => {
                  const value = this.SafeGetValue(stat_data, attr);
                  if (value !== undefined) {
                    variables.push({
                      name: attr,
                      path: attr,
                      value: value,
                      displayValue: this.formatDisplayValue(value)
                    });
                  }
                });
                // å½“å‰å±æ€§
                ['å½“å‰æ³•åŠ›', 'å½“å‰ç¥æµ·', 'å½“å‰é“å¿ƒ', 'å½“å‰ç©ºé€Ÿ'].forEach(attr => {
                  const value = this.SafeGetValue(stat_data, attr);
                  if (value !== undefined) {
                    variables.push({
                      name: attr,
                      path: attr,
                      value: value,
                      displayValue: this.formatDisplayValue(value)
                    });
                  }
                });
                break;

              case 'cultivation':
                ['å½“å‰å¢ƒç•Œ', 'å¢ƒç•Œæ˜ å°„', 'ä¿®ä¸ºè¿›åº¦', 'ä¿®ä¸ºç“¶é¢ˆ'].forEach(attr => {
                  const value = this.SafeGetValue(stat_data, attr);
                  if (value !== undefined) {
                    variables.push({
                      name: attr,
                      path: attr,
                      value: value,
                      displayValue: this.formatDisplayValue(value)
                    });
                  }
                });
                break;

              case 'equipment':
                ['ä¸»ä¿®åŠŸæ³•', 'è¾…ä¿®å¿ƒæ³•', 'æ­¦å™¨', 'é˜²å…·', 'é¥°å“', 'æ³•å®æ '].forEach(attr => {
                  const value = this.SafeGetValue(stat_data, attr);
                  variables.push({
                    name: attr,
                    path: attr,
                    value: value,
                    displayValue: this.formatDisplayValue(value)
                  });
                });
                break;

              case 'items':
                ['æ­¦å™¨åˆ—è¡¨', 'é˜²å…·åˆ—è¡¨', 'é¥°å“åˆ—è¡¨', 'æ³•å®åˆ—è¡¨', 'ä¸¹è¯åˆ—è¡¨', 'å…¶ä»–åˆ—è¡¨'].forEach(listName => {
                  const list = this.SafeGetValue(stat_data, listName);
                  if (list && typeof list === 'object') {
                    Object.keys(list).forEach(itemName => {
                      if (itemName !== '$meta') {
                        variables.push({
                          name: `${listName}.${itemName}`,
                          path: `${listName}.${itemName}`,
                          value: list[itemName],
                          displayValue: this.formatDisplayValue(list[itemName])
                        });
                      }
                    });
                  }
                });
                break;

              case 'relationships':
                const relationships = this.SafeGetValue(stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨');
                if (relationships && typeof relationships === 'object') {
                  Object.keys(relationships).forEach(personName => {
                    if (personName !== '$meta') {
                      variables.push({
                        name: `äººç‰©å…³ç³»åˆ—è¡¨.${personName}`,
                        path: `äººç‰©å…³ç³»åˆ—è¡¨.${personName}`,
                        value: relationships[personName],
                        displayValue: this.formatDisplayValue(relationships[personName])
                      });
                    }
                  });
                }
                break;

              case 'world':
                ['å½“å‰ç¬¬xä¸–', 'å½“å‰æ—¶é—´çºªå¹´', 'å½’å¢Ÿç©ºé—´', 'æœ¬ä¸–å½’å¢Ÿé€‰æ‹©', 'å½’å¢Ÿå……èƒ½æ—¶é—´',
                 'å¿ƒç†å¹´é¾„', 'å¿ƒç†å¹´é¾„ä¸Šé™', 'ç”Ÿç†å¹´é¾„', 'ç”Ÿç†å¹´é¾„ä¸Šé™', 'å½“å‰ä½ç½®'].forEach(attr => {
                  const value = this.SafeGetValue(stat_data, attr);
                  if (value !== undefined) {
                    variables.push({
                      name: attr,
                      path: attr,
                      value: value,
                      displayValue: this.formatDisplayValue(value)
                    });
                  }
                });
                break;
            }

            return variables;
          },

          // æ–°å¢ï¼šæ ¼å¼åŒ–æ˜¾ç¤ºå€¼
          formatDisplayValue(value) {
            if (value === null || value === undefined) {
              return 'æœªè®¾ç½®';
            }
            if (typeof value === 'object') {
              if (Array.isArray(value)) {
                return `[${value.length}é¡¹]`;
              }
              return `{${Object.keys(value).length}é¡¹}`;
            }
            const str = String(value);
            return str.length > 30 ? str.substring(0, 30) + '...' : str;
          },

          // æ–°å¢ï¼šé€‰æ‹©å˜é‡
          selectVariable(path, name) {
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            document.querySelectorAll('.variable-item').forEach(item => {
              item.classList.remove('selected');
            });
            const selectedItem = document.querySelector(`[data-path="${path}"]`);
            if (selectedItem) {
              selectedItem.classList.add('selected');
            }

            // è®¾ç½®å½“å‰é€‰ä¸­çš„å˜é‡è·¯å¾„
            this.currentSelectedPath = path;
            this.currentSelectedName = name;
            this.currentVariablePath = path;

            // å°†è·¯å¾„è®¾ç½®åˆ°æ‰‹åŠ¨æ¨¡å¼çš„è¾“å…¥æ¡†ä¸­
            const pathInput = document.getElementById('variable-path');
            if (pathInput) {
              pathInput.value = path;
            }

            // è‡ªåŠ¨åŠ è½½å˜é‡å€¼
            this.loadVariableFromPath(path);
          },

          // æ–°å¢ï¼šä»è·¯å¾„åŠ è½½å˜é‡
          async loadVariableFromPath(path) {
            try {
              console.log('[å˜é‡ç¼–è¾‘å™¨] å¼€å§‹åŠ è½½å˜é‡è·¯å¾„:', path);
              
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                document.getElementById('current-variable-value').textContent = 'æ— æ³•è·å–å˜é‡æ•°æ®';
                return;
              }

              const stat_data = messages[0].data.stat_data;
              const value = this.getVariableByPath(stat_data, path);
              
              console.log('[å˜é‡ç¼–è¾‘å™¨] è·å–åˆ°å˜é‡å€¼:', value, 'ç±»å‹:', typeof value);
              
              document.getElementById('current-variable-value').textContent =
                value !== undefined ? JSON.stringify(value, null, 2) : 'å˜é‡ä¸å­˜åœ¨';
              
              // åŒæ—¶æ›´æ–°æ‰‹åŠ¨æ¨¡å¼çš„å€¼è¾“å…¥æ¡†
              const valueInput = document.getElementById('variable-value');
              if (valueInput) {
                if (value === null) {
                  valueInput.value = 'null';
                } else if (value === undefined) {
                  valueInput.value = 'undefined';
                } else if (typeof value === 'string') {
                  valueInput.value = value;
                } else {
                  valueInput.value = JSON.stringify(value, null, 2);
                }
              }
              
              this.currentVariableValue = value;
              this.currentVariablePath = path;
              this.previewMvuCommand();
              
              console.log('[å˜é‡ç¼–è¾‘å™¨] å½“å‰ç¼–è¾‘æ¨¡å¼:', this.currentEditMode);
              
              // å¦‚æœå½“å‰æ˜¯å¯è§†åŒ–æ¨¡å¼ï¼Œæ›´æ–°å¯è§†åŒ–ç¼–è¾‘å™¨
              if (this.currentEditMode === 'visual') {
                console.log('[å˜é‡ç¼–è¾‘å™¨] è§¦å‘å¯è§†åŒ–ç¼–è¾‘å™¨æ›´æ–°');
                this.updateVisualEditor();
              }
              
            } catch (error) {
              console.error('åŠ è½½å˜é‡æ—¶å‡ºé”™:', error);
              document.getElementById('current-variable-value').textContent = `åŠ è½½å‡ºé”™: ${error.message}`;
            }
          },

          // æ–°å¢ï¼šæ‰‹åŠ¨æ¨¡å¼åŠ è½½å˜é‡
          loadVariableManual() {
            const pathInput = document.getElementById('variable-path');
            if (!pathInput) return;
            
            const path = pathInput.value.trim();
            if (!path) {
              alert('è¯·è¾“å…¥å˜é‡è·¯å¾„');
              return;
            }

            this.loadVariableFromPath(path);
          },

          // æ–°å¢ï¼šä»æ¨¡æ¿é€‰æ‹©å˜é‡
          selectVariableFromTemplate(path) {
            // åˆ‡æ¢åˆ°æ‰‹åŠ¨æ¨¡å¼
            this.switchTab('manual');
            
            // è®¾ç½®è·¯å¾„
            const pathInput = document.getElementById('variable-path');
            if (pathInput) {
              pathInput.value = path;
              this.loadVariableManual();
            }
          },

          // æ–°å¢ï¼šè®¾ç½®æ“ä½œç±»å‹
          setOperationType(opType) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.operation-btn').forEach(btn => {
              btn.classList.remove('active');
            });
            document.getElementById(`op-${opType}`).classList.add('active');
            
            // æ›´æ–°ç•Œé¢æ˜¾ç¤º
            const newValueContainer = document.querySelector('.new-value-input');
            const newValueLabel = newValueContainer.querySelector('label');
            const newValueTextarea = document.getElementById('new-variable-value');
            
            switch(opType) {
              case 'set':
                newValueLabel.textContent = 'æ–°å€¼:';
                newValueTextarea.placeholder = 'è¾“å…¥æ–°çš„å€¼ï¼Œæ”¯æŒJSONæ ¼å¼';
                break;
              case 'add':
                newValueLabel.textContent = 'å¢é‡å€¼:';
                newValueTextarea.placeholder = 'è¾“å…¥è¦å¢åŠ çš„æ•°å€¼ï¼ˆæ­£æ•°æˆ–è´Ÿæ•°ï¼‰';
                break;
              case 'assign':
                newValueLabel.textContent = 'è¦åˆ†é…çš„å€¼:';
                newValueTextarea.placeholder = 'è¾“å…¥è¦åˆ†é…çš„å€¼æˆ–å¯¹è±¡';
                break;
              case 'remove':
                newValueLabel.textContent = 'è¦ç§»é™¤çš„å€¼:';
                newValueTextarea.placeholder = 'è¾“å…¥è¦ç§»é™¤çš„é”®åæˆ–ç´¢å¼•ï¼ˆå¯é€‰ï¼‰';
                break;
            }
            
            this.currentOperation = opType;
            this.previewMvuCommand();
          },

          // æ–°å¢ï¼šåŠ è½½å˜é‡
          async loadVariable() {
            const path = document.getElementById('variable-path').value.trim();
            if (!path) {
              alert('è¯·è¾“å…¥å˜é‡è·¯å¾„');
              return;
            }

            try {
              const messages = await getChatMessages(getCurrentMessageId());
              if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                document.getElementById('current-variable-value').textContent = 'æ— æ³•è·å–å˜é‡æ•°æ®';
                return;
              }

              const stat_data = messages[0].data.stat_data;
              const value = this.getVariableByPath(stat_data, path);
              
              document.getElementById('current-variable-value').textContent =
                value !== undefined ? JSON.stringify(value, null, 2) : 'å˜é‡ä¸å­˜åœ¨';
              
              this.currentVariableValue = value;
              this.previewMvuCommand();
              
            } catch (error) {
              console.error('åŠ è½½å˜é‡æ—¶å‡ºé”™:', error);
              document.getElementById('current-variable-value').textContent = `åŠ è½½å‡ºé”™: ${error.message}`;
            }
          },

          // æ–°å¢ï¼šæ ¹æ®è·¯å¾„è·å–å˜é‡å€¼ï¼ˆå…¼å®¹æ•°ç»„æ ¼å¼å˜é‡ï¼‰
          getVariableByPath(data, path) {
            try {
              // ä½¿ç”¨SafeGetValueå¤„ç†è·¯å¾„
              const value = this.SafeGetValue(data, path);
              
              // å¦‚æœæ˜¯æ•°ç»„æ ¼å¼çš„å˜é‡ï¼ˆå¦‚[å€¼, "æè¿°"]ï¼‰ï¼Œè¿”å›ç¬¬ä¸€ä¸ªå…ƒç´ 
              if (Array.isArray(value) && value.length >= 1) {
                return value[0];
              }
              
              return value;
            } catch (error) {
              console.error('è·å–å˜é‡å€¼æ—¶å‡ºé”™:', error);
              return undefined;
            }
          },

          // æ–°å¢ï¼šé¢„è§ˆMVUå‘½ä»¤ï¼ˆå…¼å®¹UpdateVariableæ ¼å¼ï¼‰
          previewMvuCommand() {
            const path = document.getElementById('variable-path').value.trim();
            const newValue = document.getElementById('new-variable-value').value.trim();
            const reason = document.getElementById('change-reason').value.trim();
            const operation = this.currentOperation || 'set';
            
            if (!path) {
              document.getElementById('mvu-command-preview').textContent = 'è¯·å…ˆè¾“å…¥å˜é‡è·¯å¾„';
              return;
            }

            let command = '';
            const reasonComment = reason ? `//${reason}` : '';
            
            // æ£€æŸ¥æ˜¯å¦æ˜¯æ•°ç»„æ ¼å¼å˜é‡ï¼ˆéœ€è¦[0]è®¿é—®ï¼‰
            const needsArrayAccess = this.isArrayFormatVariable(path);
            const actualPath = needsArrayAccess ? `${path}[0]` : path;
            
            switch(operation) {
              case 'set':
                if (newValue) {
                  if (this.currentVariableValue !== undefined) {
                    command = `_.set('${actualPath}', ${JSON.stringify(this.currentVariableValue)}, ${this.parseValue(newValue)});${reasonComment}`;
                  } else {
                    command = `_.set('${actualPath}', ${this.parseValue(newValue)});${reasonComment}`;
                  }
                } else {
                  command = 'è¯·è¾“å…¥æ–°å€¼';
                }
                break;
              case 'add':
                if (newValue) {
                  command = `_.add('${actualPath}', ${this.parseValue(newValue)});${reasonComment}`;
                } else {
                  command = 'è¯·è¾“å…¥å¢é‡å€¼';
                }
                break;
              case 'assign':
                if (path.includes('åˆ—è¡¨') && newValue) {
                  // å¯¹äºåˆ—è¡¨ç±»å‹ï¼Œéœ€è¦æä¾›é”®å’Œå€¼
                  try {
                    const valueObj = JSON.parse(newValue);
                    if (typeof valueObj === 'object' && valueObj.name) {
                      command = `_.assign('${path}', '${valueObj.name}', ${newValue});${reasonComment}`;
                    } else {
                      command = `_.assign('${path}', ${this.parseValue(newValue)});${reasonComment}`;
                    }
                  } catch (e) {
                    command = `_.assign('${path}', ${this.parseValue(newValue)});${reasonComment}`;
                  }
                } else if (newValue) {
                  command = `_.assign('${actualPath}', ${this.parseValue(newValue)});${reasonComment}`;
                } else {
                  command = 'è¯·è¾“å…¥è¦åˆ†é…çš„å€¼';
                }
                break;
              case 'remove':
                if (newValue) {
                  command = `_.remove('${path}', ${this.parseValue(newValue)});${reasonComment}`;
                } else {
                  command = `_.remove('${actualPath}');${reasonComment}`;
                }
                break;
            }
            
            document.getElementById('mvu-command-preview').textContent = command;
          },

          // æ–°å¢ï¼šæ£€æŸ¥æ˜¯å¦æ˜¯æ•°ç»„æ ¼å¼å˜é‡
          isArrayFormatVariable(path) {
            const arrayFormatVars = [
              'å½“å‰å¢ƒç•Œ', 'å¢ƒç•Œæ˜ å°„', 'ä¿®ä¸ºè¿›åº¦', 'ä¿®ä¸ºç“¶é¢ˆ',
              'å½“å‰ç¬¬xä¸–', 'å½“å‰æ—¶é—´çºªå¹´', 'å½’å¢Ÿç©ºé—´', 'æœ¬ä¸–å½’å¢Ÿé€‰æ‹©',
              'å½’å¢Ÿå……èƒ½æ—¶é—´', 'å¿ƒç†å¹´é¾„', 'å¿ƒç†å¹´é¾„ä¸Šé™', 'ç”Ÿç†å¹´é¾„', 'ç”Ÿç†å¹´é¾„ä¸Šé™'
            ];
            return arrayFormatVars.includes(path);
          },

          // æ–°å¢ï¼šè§£æè¾“å…¥å€¼
          parseValue(valueStr) {
            if (!valueStr) return 'null';
            
            // å°è¯•è§£æä¸ºJSON
            try {
              JSON.parse(valueStr);
              return valueStr;
            } catch (e) {
              // å¦‚æœä¸æ˜¯æœ‰æ•ˆçš„JSONï¼Œä½œä¸ºå­—ç¬¦ä¸²å¤„ç†
              return JSON.stringify(valueStr);
            }
          },

          // æ–°å¢ï¼šæ‰§è¡ŒMVUå‘½ä»¤
          async executeMvuCommand() {
            const command = document.getElementById('mvu-command-preview').textContent;
            
            if (!command || command.includes('è¯·')) {
              alert('è¯·å…ˆå®Œå–„å˜é‡ä¿¡æ¯å¹¶é¢„è§ˆå‘½ä»¤');
              return;
            }

            try {
              // ç¡®è®¤æ‰§è¡Œ
              if (!confirm(`ç¡®å®šè¦æ‰§è¡Œä»¥ä¸‹MVUå‘½ä»¤å—ï¼Ÿ\n\n${command}`)) {
                return;
              }

              // è¿™é‡Œé›†æˆMVUå‘½ä»¤æ‰§è¡ŒåŠŸèƒ½
              await this.executeMvuCommandDirect(command);
              
              alert('å˜é‡ä¿®æ”¹æˆåŠŸï¼');
              this.closeModal('variable-editor-modal');
              
              // åˆ·æ–°ç›¸å…³ç•Œé¢
              if (this.currentMvuState && this.currentMvuState.stat_data) {
                this.renderUI(this.currentMvuState.stat_data);
              }
              
            } catch (error) {
              console.error('æ‰§è¡ŒMVUå‘½ä»¤æ—¶å‡ºé”™:', error);
              alert(`æ‰§è¡Œå¤±è´¥: ${error.message}`);
            }
          },

          // æ–°å¢ï¼šç›´æ¥æ‰§è¡ŒMVUå‘½ä»¤çš„æ–¹æ³• (å·²æ›´æ–°æ”¯æŒé™é»˜å’ŒéæŒä¹…åŒ–æ¨¡å¼)
          async executeMvuCommandDirect(command, options = { silent: false, persist: true }) {
            console.log(`[å˜é‡ä¿®æ”¹å™¨] æ‰§è¡ŒMVUå‘½ä»¤: ${command}`, `(Silent: ${options.silent}, Persist: ${options.persist})`);
            
            if (!this.currentMvuState) {
              throw new Error('MVUçŠ¶æ€ä¸å¯ç”¨ï¼Œè¯·å…ˆè¿›è¡Œä¸€æ¬¡æ¸¸æˆæ“ä½œ');
            }

            // ä½¿ç”¨ç°æœ‰çš„MVUæ‰§è¡Œé€»è¾‘
            const inputData = { old_variables: this.currentMvuState };
            let mvuSucceeded = false;
            
            try {
              // é¦–å…ˆå°è¯•è°ƒç”¨åç«¯MVUäº‹ä»¶
              const mvuPromise = eventEmit('mag_invoke_mvu', command, inputData);
              const timeoutPromise = new Promise((_, reject) =>
                setTimeout(() => reject(new Error('MVU event timeout')), 3000)
              );
              
              await Promise.race([mvuPromise, timeoutPromise]);
              
              if (inputData.new_variables) {
                this.currentMvuState = this._safeLoadMvuData(inputData.new_variables);
                if (!options.silent) {
                    this.renderUI(this.currentMvuState.stat_data);
                }
                mvuSucceeded = true;
                console.log('[å˜é‡ä¿®æ”¹å™¨] MVUåç«¯æ‰§è¡ŒæˆåŠŸ');
              } else {
                console.log('[å˜é‡ä¿®æ”¹å™¨] MVUåç«¯æœªè¿”å›æ–°çŠ¶æ€ï¼Œå°è¯•å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆ');
              }
            } catch (eventError) {
              console.error('[å˜é‡ä¿®æ”¹å™¨] è°ƒç”¨MVUäº‹ä»¶æ—¶å‘ç”Ÿé”™è¯¯æˆ–è¶…æ—¶ï¼Œå°è¯•å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆ:', eventError);
            }

            // å¦‚æœåç«¯æ‰§è¡Œå¤±è´¥ï¼Œä½¿ç”¨å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆ
            if (!mvuSucceeded) {
              const modifiedState = this._applyUpdateFallback(command, this.currentMvuState);
              if (modifiedState) {
                this.currentMvuState = modifiedState;
                if (!options.silent) {
                    this.renderUI(this.currentMvuState.stat_data);
                }
                console.log('[å˜é‡ä¿®æ”¹å™¨] å‰ç«¯å¤‡ç”¨æ–¹æ¡ˆæ‰§è¡ŒæˆåŠŸ');
              } else {
                throw new Error('MVUå‘½ä»¤æ‰§è¡Œå¤±è´¥ï¼šåç«¯å’Œå‰ç«¯æ–¹æ¡ˆéƒ½æ— æ³•å¤„ç†è¯¥å‘½ä»¤');
              }
            }

            // å…³é”®ï¼šå°†ä¿®æ”¹åçš„æ•°æ®ä¿å­˜åˆ°æ¶ˆæ¯ä¸­ï¼Œç¡®ä¿æ•°æ®æŒä¹…åŒ– (é™¤éæŒ‡å®šä¸æŒä¹…åŒ–)
            if (options.persist) {
              await this.saveVariableChangesToMessage();
            }

            // é‡æ–°åŠ è½½å˜é‡æ˜¾ç¤ºå½“å‰å€¼
            setTimeout(() => {
              if (this.currentVariablePath) {
                this.loadVariableFromPath(this.currentVariablePath);
              }
              // å¦‚æœæ˜¯æµè§ˆæ¨¡å¼ï¼Œåˆ·æ–°å˜é‡åˆ—è¡¨
              const activeTab = document.querySelector('.tab-btn.active');
              if (activeTab && activeTab.id === 'tab-browse') {
                const category = document.getElementById('variable-category').value;
                if (category) {
                  this.loadVariablesByCategory(category);
                }
              }
            }, 100);
          },

          // æ–°å¢ï¼šå°†å˜é‡ä¿®æ”¹ä¿å­˜åˆ°æ¶ˆæ¯æ•°æ®ä¸­
          async saveVariableChangesToMessage() {
            try {
              const messageId = getCurrentMessageId();
              if (messageId >= 0 && this.currentMvuState) {
                // ä½¿ç”¨SillyTavernçš„æ ‡å‡†APIä¿å­˜å˜é‡æ•°æ®
                await setChatMessage(
                  { data: this.currentMvuState },
                  messageId,
                  { refresh: 'display_current' }
                );
                console.log('[å˜é‡ä¿®æ”¹å™¨] æ•°æ®å·²ä¿å­˜åˆ°æ¶ˆæ¯ä¸­');
                
                // åŒæ—¶æ›´æ–°èŠå¤©çº§åˆ«çš„å˜é‡
                await replaceVariables(this.currentMvuState, { type: 'chat' });
                console.log('[å˜é‡ä¿®æ”¹å™¨] èŠå¤©å˜é‡å·²æ›´æ–°');
              }
            } catch (error) {
              console.error('[å˜é‡ä¿®æ”¹å™¨] ä¿å­˜æ•°æ®åˆ°æ¶ˆæ¯æ—¶å‡ºé”™:', error);
              // å°è¯•å¤‡ç”¨ä¿å­˜æ–¹æ³•
              try {
                await replaceVariables(this.currentMvuState, {
                  type: 'message',
                  message_id: getCurrentMessageId()
                });
                console.log('[å˜é‡ä¿®æ”¹å™¨] ä½¿ç”¨å¤‡ç”¨æ–¹æ³•ä¿å­˜æˆåŠŸ');
              } catch (backupError) {
                console.error('[å˜é‡ä¿®æ”¹å™¨] å¤‡ç”¨ä¿å­˜æ–¹æ³•ä¹Ÿå¤±è´¥:', backupError);
              }
            }
          },

          // æ–°å¢ï¼šç¼–è¾‘æ¨¡å¼åˆ‡æ¢
          switchEditMode(mode) {
            console.log('[å˜é‡ç¼–è¾‘å™¨] åˆ‡æ¢ç¼–è¾‘æ¨¡å¼åˆ°:', mode);
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.mode-btn').forEach(btn => {
              btn.classList.remove('active');
            });
            document.getElementById(`mode-${mode}`).classList.add('active');
            
            // å…ˆè®¾ç½®ç¼–è¾‘æ¨¡å¼
            this.currentEditMode = mode;
            
            // åˆ‡æ¢æ˜¾ç¤ºå†…å®¹
            const rawMode = document.getElementById('raw-edit-mode');
            const visualMode = document.getElementById('visual-edit-mode');
            
            if (mode === 'raw') {
              rawMode.style.display = 'block';
              visualMode.style.display = 'none';
            } else {
              rawMode.style.display = 'none';
              visualMode.style.display = 'block';
              console.log('[å˜é‡ç¼–è¾‘å™¨] åˆ‡æ¢åˆ°å¯è§†åŒ–æ¨¡å¼ï¼Œå½“å‰å˜é‡å€¼:', this.currentVariableValue);
              this.updateVisualEditor();
            }
          },

          // === é‡æ„ï¼šæ™ºèƒ½å¯è§†åŒ–ç¼–è¾‘å™¨ ===
          updateVisualEditor() {
            const visualContent = document.getElementById('visual-editor-content');
            
            if (this.currentEditMode !== 'visual') {
              return;
            }
            
            if (!this.currentVariableValue && this.currentVariableValue !== 0 && this.currentVariableValue !== false) {
              visualContent.innerHTML = '<div class="placeholder">è¯·å…ˆåŠ è½½å˜é‡ä»¥å¯ç”¨å¯è§†åŒ–ç¼–è¾‘</div>';
              return;
            }

            try {
              const value = this.currentVariableValue;
              console.log('[æ™ºèƒ½å¯è§†åŒ–ç¼–è¾‘å™¨] æ¸²æŸ“å˜é‡å€¼:', value);
              
              // åˆå§‹åŒ–ç‰ˆæœ¬å†å²å’Œæ’¤é”€é‡åšç³»ç»Ÿ
              this.initVersionHistory();
              
              const html = this.renderSmartVisualEditor(value, this.currentVariablePath || 'æ ¹å€¼');
              visualContent.innerHTML = html;
              this.bindSmartEditorEvents();
            } catch (error) {
              console.error('æ¸²æŸ“æ™ºèƒ½å¯è§†åŒ–ç¼–è¾‘å™¨æ—¶å‡ºé”™:', error);
              visualContent.innerHTML = `<div class="placeholder">æ•°æ®è§£æå¤±è´¥ï¼Œæ­£åœ¨å°è¯•å…¼å®¹æ¨¡å¼...<br>é”™è¯¯: ${error.message}</div>`;
              // é™çº§åˆ°ç®€å•æ¨¡å¼
              this.renderFallbackEditor(value);
            }
          },

          // æ™ºèƒ½æ•°æ®ç±»å‹æ£€æµ‹å’Œæ¸²æŸ“
          renderSmartVisualEditor(value, path) {
            // æ£€æµ‹æ•°æ®ç±»å‹å¹¶é€‰æ‹©åˆé€‚çš„æ¸²æŸ“å™¨
            const dataType = this.detectDataType(value, path);
            
            switch (dataType) {
              case 'character':
                return this.renderCharacterCard(value, path);
              case 'relationship_list':
                return this.renderRelationshipList(value, path);
              case 'attributes':
                return this.renderAttributesPanel(value, path);
              case 'simple_object':
                return this.renderSimpleObject(value, path);
              case 'array':
                return this.renderSmartArray(value, path);
              case 'primitive':
                return this.renderPrimitiveValue(value, path);
              default:
                return this.renderGenericObject(value, path);
            }
          },

          // æ•°æ®ç±»å‹æ£€æµ‹å™¨
          detectDataType(value, path) {
            if (value === null || value === undefined) return 'primitive';
            if (typeof value !== 'object') return 'primitive';
            
            // æ£€æµ‹äººç‰©æ•°æ®
            if (this.isCharacterData(value)) return 'character';
            
            // æ£€æµ‹äººç‰©å…³ç³»åˆ—è¡¨
            if (path && path.includes('äººç‰©å…³ç³»åˆ—è¡¨')) return 'relationship_list';
            
            // æ£€æµ‹å±æ€§å¯¹è±¡
            if (this.isAttributesObject(value)) return 'attributes';
            
            // æ£€æµ‹æ•°ç»„
            if (Array.isArray(value)) return 'array';
            
            // æ£€æµ‹ç®€å•å¯¹è±¡
            if (this.isSimpleObject(value)) return 'simple_object';
            
            return 'generic_object';
          },

          // äººç‰©æ•°æ®æ£€æµ‹
          isCharacterData(value) {
            if (!value || typeof value !== 'object' || Array.isArray(value)) return false;
            
            const characterFields = ['èº«ä»½èƒŒæ™¯', 'æ€§æ ¼', 'å¤–è²Œ', 'ç§°å‘¼', 'attributes', 'tier', 'ç­‰çº§', 'favorability'];
            const hasCharacterFields = characterFields.some(field => value.hasOwnProperty(field));
            
            return hasCharacterFields;
          },

          // å±æ€§å¯¹è±¡æ£€æµ‹
          isAttributesObject(value) {
            if (!value || typeof value !== 'object' || Array.isArray(value)) return false;
            
            const keys = Object.keys(value);
            const numericKeys = keys.filter(key => typeof value[key] === 'number');
            
            // å¦‚æœå¤§éƒ¨åˆ†å­—æ®µéƒ½æ˜¯æ•°å€¼ï¼Œè®¤ä¸ºæ˜¯å±æ€§å¯¹è±¡
            return numericKeys.length > keys.length * 0.6;
          },

          // ç®€å•å¯¹è±¡æ£€æµ‹
          isSimpleObject(value) {
            if (!value || typeof value !== 'object' || Array.isArray(value)) return false;
            
            const keys = Object.keys(value);
            return keys.length <= 10 && keys.every(key =>
              typeof value[key] === 'string' ||
              typeof value[key] === 'number' ||
              typeof value[key] === 'boolean'
            );
          },

          // === ä¸“ç”¨æ¸²æŸ“å™¨å®ç° ===
          
          // äººç‰©å¡ç‰‡æ¸²æŸ“å™¨
          renderCharacterCard(character, path) {
            const name = character.ç§°å‘¼ || character.name || 'æœªå‘½åè§’è‰²';
            const identity = character.èº«ä»½èƒŒæ™¯ || character.identity || '';
            const tier = character.tier || '';
            const level = character.ç­‰çº§ || character.level || '';
            
            let html = `<div class="character-card" data-path="${path}">
              <div class="character-header">
                <div class="character-avatar">${name.charAt(0)}</div>
                <div class="character-basic-info">
                  <div class="character-name" contenteditable="true" data-field="name">${name}</div>
                  <div class="character-title">${tier} ${level}</div>
                </div>
              </div>`;

            // å±æ€§é¢æ¿
            if (character.attributes) {
              html += this.renderAttributesPanel(character.attributes, `${path}.attributes`);
            }

            // åŸºæœ¬ä¿¡æ¯
            html += `<div class="details-section">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>åŸºæœ¬ä¿¡æ¯</span>
                <span>â–¼</span>
              </div>
              <div class="details-content">`;

            const basicFields = [
              { key: 'èº«ä»½èƒŒæ™¯', label: 'èº«ä»½èƒŒæ™¯', type: 'textarea' },
              { key: 'æ€§æ ¼', label: 'æ€§æ ¼', type: 'textarea' },
              { key: 'å¤–è²Œ', label: 'å¤–è²Œ', type: 'textarea' },
              { key: 'tier', label: 'ä¿®ä¸ºå¢ƒç•Œ', type: 'select', options: ['å‡¡äºº', 'ç»ƒæ°”', 'ç­‘åŸº', 'é‡‘ä¸¹', 'å…ƒå©´', 'åŒ–ç¥'] },
              { key: 'ç­‰çº§', label: 'ç­‰çº§', type: 'select', options: ['åˆæœŸ', 'ä¸­æœŸ', 'åæœŸ', 'å¤§åœ†æ»¡'] },
              { key: 'favorability', label: 'å¥½æ„Ÿåº¦', type: 'slider', min: -100, max: 100 },
              { key: 'relationship', label: 'å…³ç³»', type: 'text' }
            ];

            basicFields.forEach(field => {
              const value = character[field.key] || '';
              html += this.renderFormField(field, value, `${path}.${field.key}`);
            });

            html += `</div></div>`;

            // äººç‰©å…³ç³»åˆ—è¡¨
            if (character.äººç‰©å…³ç³»åˆ—è¡¨) {
              html += this.renderRelationshipList(character.äººç‰©å…³ç³»åˆ—è¡¨, `${path}.äººç‰©å…³ç³»åˆ—è¡¨`);
            }

            // å…¶ä»–è¯¦ç»†ä¿¡æ¯
            const otherFields = Object.keys(character).filter(key =>
              !['ç§°å‘¼', 'name', 'èº«ä»½èƒŒæ™¯', 'æ€§æ ¼', 'å¤–è²Œ', 'tier', 'ç­‰çº§', 'favorability', 'relationship', 'attributes', 'äººç‰©å…³ç³»åˆ—è¡¨'].includes(key)
            );

            if (otherFields.length > 0) {
              html += `<div class="details-section">
                <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                  <span>å…¶ä»–ä¿¡æ¯</span>
                  <span>â–¼</span>
                </div>
                <div class="details-content">`;

              otherFields.forEach(key => {
                const value = character[key];
                html += this.renderGenericField(key, value, `${path}.${key}`);
              });

              html += `</div></div>`;
            }

            html += `<div class="action-buttons">
              <button class="action-btn secondary" onclick="guixuApp.revertField('${path}')">æ’¤é”€</button>
              <button class="action-btn" onclick="guixuApp.saveField('${path}')">ä¿å­˜</button>
            </div></div>`;

            return html;
          },

          // å±æ€§é¢æ¿æ¸²æŸ“å™¨
          renderAttributesPanel(attributes, path) {
            let html = `<div class="attributes-panel" data-path="${path}">`;
            
            Object.entries(attributes).forEach(([key, value]) => {
              const numValue = typeof value === 'number' ? value : parseInt(value) || 0;
              const maxValue = this.getAttributeMaxValue(key, numValue);
              
              html += `<div class="attribute-item">
                <label class="attribute-label">${key}</label>
                <div class="attribute-value">
                  <input type="range" class="attribute-slider"
                         min="0" max="${maxValue}" value="${numValue}"
                         data-path="${path}.${key}" data-type="number">
                  <input type="number" class="attribute-input"
                         value="${numValue}" min="0" max="${maxValue}"
                         data-path="${path}.${key}" data-type="number">
                </div>
              </div>`;
            });
            
            html += `</div>`;
            return html;
          },

          // å…³ç³»åˆ—è¡¨æ¸²æŸ“å™¨ - é‡æ„ä¸ºç°æœ‰UIé£æ ¼
          renderRelationshipList(relationships, path) {
            if (!relationships || typeof relationships !== 'object') {
              return `<div class="relationships-container" data-path="${path}">
                <div class="empty-relationships-state">
                  <div class="empty-state-icon">ğŸ‘¥</div>
                  <div class="empty-state-title">æš‚æ— äººç‰©å…³ç³»</div>
                  <div class="empty-state-description">
                    <p>ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®æ·»åŠ ç¬¬ä¸€ä¸ªäººç‰©å…³ç³»</p>
                  </div>
                  <div class="action-buttons">
                    <button class="action-btn" onclick="guixuApp.addRelationship('${path}')">æ·»åŠ å…³ç³»</button>
                  </div>
                </div>
              </div>`;
            }

            // ä½¿ç”¨ç°æœ‰äººç‰©å…³ç³»UIé£æ ¼
            let html = `<div class="relationships-container" data-path="${path}">
              <div class="relationships-header">
                <div class="relationship-tabs">
                  <div class="tab-btn active">
                    <span class="tab-icon">ğŸ‘¥</span>
                    <span class="tab-text">äººç‰©å…³ç³»</span>
                    <span class="tab-count">${Object.keys(relationships).length}</span>
                  </div>
                </div>
                <div class="relationships-controls">
                  <div class="action-buttons">
                    <button class="action-btn" onclick="guixuApp.addRelationship('${path}')">æ·»åŠ å…³ç³»</button>
                  </div>
                </div>
              </div>
              <div class="relationships-content">
                <div class="relationships-grid">`;

            // æ¸²æŸ“æ¯ä¸ªäººç‰©å…³ç³»å¡ç‰‡
            Object.entries(relationships).forEach(([name, info]) => {
              html += this.renderSingleRelationshipCard(name, info, path);
            });

            html += `</div></div></div>`;
            return html;
          },

          // æ¸²æŸ“å•ä¸ªäººç‰©å…³ç³»å¡ç‰‡
          renderSingleRelationshipCard(name, info, basePath) {
            const isObject = typeof info === 'object' && info !== null;
            const relationship = isObject ? (info.relationship || 'æœªçŸ¥å…³ç³»') : (typeof info === 'string' ? info : 'æœªçŸ¥å…³ç³»');
            const favorability = isObject ? (info.favorability || 0) : 0;
            const tier = isObject ? (info.tier || '') : '';
            const level = isObject ? (info.ç­‰çº§ || info.level || '') : '';
            const identity = isObject ? (info.èº«ä»½èƒŒæ™¯ || info.identity || '') : '';
            const personality = isObject ? (info.æ€§æ ¼ || info.personality || '') : '';
            const appearance = isObject ? (info.å¤–è²Œ || info.appearance || '') : '';
            const calling = isObject ? (info.ç§°å‘¼ || info.calling || name) : name;

            // è®¡ç®—å¥½æ„Ÿåº¦è¿›åº¦æ¡å®½åº¦
            const favorabilityPercent = Math.max(0, Math.min(100, (favorability + 100) / 2));

            let html = `<div class="relationship-card" data-name="${name}" data-path="${basePath}.${name}">
              <div class="relationship-main">
                <div class="relationship-header">
                  <div class="header-left">
                    <div class="character-name" contenteditable="true" data-field="name" data-original-name="${name}">${name}</div>
                    <div class="character-relationship">${relationship}</div>
                  </div>
                  <div class="cultivation-info">${tier} ${level}</div>
                </div>

                <div class="favorability-section">
                  <div class="favorability-value">å¥½æ„Ÿåº¦: ${favorability}</div>
                  <div class="favorability-bar">
                    <div class="favorability-progress" style="width: ${favorabilityPercent}%"></div>
                  </div>
                </div>`;

            // åŸºæœ¬ä¿¡æ¯ç¼–è¾‘åŒºåŸŸ
            html += `<div class="relationship-details">
              <button class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                åŸºæœ¬ä¿¡æ¯
              </button>
              <div class="details-content hidden">
                <div class="details-row">
                  <div class="smart-form-group">
                    <label class="smart-form-label">ç§°å‘¼</label>
                    <input type="text" class="attribute-input" value="${calling}"
                           data-path="${basePath}.${name}.ç§°å‘¼" data-field="ç§°å‘¼">
                  </div>
                  <div class="smart-form-group">
                    <label class="smart-form-label">å…³ç³»</label>
                    <input type="text" class="attribute-input" value="${relationship}"
                           data-path="${basePath}.${name}.relationship" data-field="relationship">
                  </div>
                  <div class="smart-form-group">
                    <label class="smart-form-label">ä¿®ä¸ºå¢ƒç•Œ</label>
                    <select class="smart-select" data-path="${basePath}.${name}.tier" data-field="tier">
                      <option value="">é€‰æ‹©å¢ƒç•Œ</option>
                      <option value="å‡¡äºº" ${tier === 'å‡¡äºº' ? 'selected' : ''}>å‡¡äºº</option>
                      <option value="ç»ƒæ°”" ${tier === 'ç»ƒæ°”' ? 'selected' : ''}>ç»ƒæ°”</option>
                      <option value="ç­‘åŸº" ${tier === 'ç­‘åŸº' ? 'selected' : ''}>ç­‘åŸº</option>
                      <option value="é‡‘ä¸¹" ${tier === 'é‡‘ä¸¹' ? 'selected' : ''}>é‡‘ä¸¹</option>
                      <option value="å…ƒå©´" ${tier === 'å…ƒå©´' ? 'selected' : ''}>å…ƒå©´</option>
                      <option value="åŒ–ç¥" ${tier === 'åŒ–ç¥' ? 'selected' : ''}>åŒ–ç¥</option>
                      <option value="åˆä½“" ${tier === 'åˆä½“' ? 'selected' : ''}>åˆä½“</option>
                      <option value="é£å‡" ${tier === 'é£å‡' ? 'selected' : ''}>é£å‡</option>
                    </select>
                  </div>
                  <div class="smart-form-group">
                    <label class="smart-form-label">ç­‰çº§</label>
                    <select class="smart-select" data-path="${basePath}.${name}.ç­‰çº§" data-field="ç­‰çº§">
                      <option value="">é€‰æ‹©ç­‰çº§</option>
                      <option value="åˆæœŸ" ${level === 'åˆæœŸ' ? 'selected' : ''}>åˆæœŸ</option>
                      <option value="ä¸­æœŸ" ${level === 'ä¸­æœŸ' ? 'selected' : ''}>ä¸­æœŸ</option>
                      <option value="åæœŸ" ${level === 'åæœŸ' ? 'selected' : ''}>åæœŸ</option>
                      <option value="å¤§åœ†æ»¡" ${level === 'å¤§åœ†æ»¡' ? 'selected' : ''}>å¤§åœ†æ»¡</option>
                    </select>
                  </div>
                  <div class="smart-form-group">
                    <label class="smart-form-label">å¥½æ„Ÿåº¦ (${favorability})</label>
                    <div class="attribute-value">
                      <input type="range" class="attribute-slider" min="-100" max="100" value="${favorability}"
                             data-path="${basePath}.${name}.favorability" data-field="favorability" data-type="number">
                      <input type="number" class="attribute-input" value="${favorability}" min="-100" max="100"
                             data-path="${basePath}.${name}.favorability" data-field="favorability" data-type="number" style="width: 80px;">
                    </div>
                  </div>
                </div>
              </div>
            </div>`;

            // è¯¦ç»†ä¿¡æ¯ç¼–è¾‘åŒºåŸŸ
            if (identity || personality || appearance) {
              html += `<div class="relationship-details">
                <button class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                  è¯¦ç»†ä¿¡æ¯
                </button>
                <div class="details-content hidden">
                  <div class="details-row">`;

              if (identity) {
                html += `<div class="smart-form-group">
                  <label class="smart-form-label">èº«ä»½èƒŒæ™¯</label>
                  <textarea class="rich-text-editor" data-path="${basePath}.${name}.èº«ä»½èƒŒæ™¯" data-field="èº«ä»½èƒŒæ™¯" rows="3">${identity}</textarea>
                </div>`;
              }

              if (personality) {
                html += `<div class="smart-form-group">
                  <label class="smart-form-label">æ€§æ ¼</label>
                  <textarea class="rich-text-editor" data-path="${basePath}.${name}.æ€§æ ¼" data-field="æ€§æ ¼" rows="2">${personality}</textarea>
                </div>`;
              }

              if (appearance) {
                html += `<div class="smart-form-group">
                  <label class="smart-form-label">å¤–è²Œ</label>
                  <textarea class="rich-text-editor" data-path="${basePath}.${name}.å¤–è²Œ" data-field="å¤–è²Œ" rows="2">${appearance}</textarea>
                </div>`;
              }

              html += `</div></div></div>`;
            }

            // æ“ä½œæŒ‰é’®
            html += `<div class="action-buttons">
              <button class="action-btn secondary" onclick="guixuApp.removeRelationship('${basePath}', '${name}')">åˆ é™¤</button>
              <button class="action-btn" onclick="guixuApp.saveRelationshipChanges('${basePath}', '${name}')">ä¿å­˜ä¿®æ”¹</button>
            </div>`;

            html += `</div></div>`;
            return html;
          },

          // è¡¨å•å­—æ®µæ¸²æŸ“å™¨
          renderFormField(field, value, path) {
            let html = `<div class="smart-form-group">
              <label class="smart-form-label">${field.label}</label>`;

            switch (field.type) {
              case 'textarea':
                html += `<textarea class="rich-text-editor" data-path="${path}" rows="3">${value}</textarea>`;
                break;
              case 'select':
                html += `<select class="smart-select" data-path="${path}">`;
                field.options.forEach(option => {
                  const selected = option === value ? 'selected' : '';
                  html += `<option value="${option}" ${selected}>${option}</option>`;
                });
                html += `</select>`;
                break;
              case 'slider':
                const numValue = typeof value === 'number' ? value : parseInt(value) || field.min || 0;
                html += `<div class="attribute-value">
                  <input type="range" class="attribute-slider"
                         min="${field.min}" max="${field.max}" value="${numValue}"
                         data-path="${path}" data-type="number">
                  <input type="number" class="attribute-input"
                         value="${numValue}" min="${field.min}" max="${field.max}"
                         data-path="${path}" data-type="number">
                </div>`;
                break;
              default:
                html += `<input type="text" class="attribute-input" value="${value}" data-path="${path}">`;
            }

            html += `</div>`;
            return html;
          },

          // é€šç”¨å­—æ®µæ¸²æŸ“å™¨
          renderGenericField(key, value, path) {
            if (typeof value === 'object' && value !== null) {
              return `<div class="smart-form-group">
                <label class="smart-form-label">${key}</label>
                <textarea class="rich-text-editor" data-path="${path}" rows="2">${JSON.stringify(value, null, 2)}</textarea>
              </div>`;
            } else {
              return `<div class="smart-form-group">
                <label class="smart-form-label">${key}</label>
                <input type="text" class="attribute-input" value="${value}" data-path="${path}">
              </div>`;
            }
          },

          // è·å–å±æ€§æœ€å¤§å€¼
          getAttributeMaxValue(attributeName, currentValue) {
            const maxValues = {
              'æ³•åŠ›': Math.max(10000, currentValue * 2),
              'ç¥æµ·': Math.max(1000, currentValue * 2),
              'é“å¿ƒ': 100,
              'ç©ºé€Ÿ': 100,
              'æ°”è¿': 100,
              'ä½“è´¨': 100,
              'çµæ ¹': 100
            };
            return maxValues[attributeName] || Math.max(1000, currentValue * 2);
          },

          // é™çº§æ¸²æŸ“å™¨ï¼ˆå…¼å®¹æ¨¡å¼ï¼‰
          renderFallbackEditor(value) {
            const visualContent = document.getElementById('visual-editor-content');
            try {
              const html = this.renderVisualEditor(value, this.currentVariablePath || 'æ ¹å€¼');
              visualContent.innerHTML = html;
              this.bindVisualEditorEvents();
            } catch (error) {
              visualContent.innerHTML = `<div class="placeholder">
                æ•°æ®æ ¼å¼è¿‡äºå¤æ‚ï¼Œè¯·ä½¿ç”¨åŸå§‹æ¨¡å¼ç¼–è¾‘<br>
                <button class="action-btn" onclick="guixuApp.switchEditMode('raw')">åˆ‡æ¢åˆ°åŸå§‹æ¨¡å¼</button>
              </div>`;
            }
          },

          // === æ™ºèƒ½äº‹ä»¶ç»‘å®šç³»ç»Ÿ ===
          bindSmartEditorEvents() {
            // ç»‘å®šæ‰€æœ‰è¾“å…¥æ§ä»¶
            this.bindInputEvents();
            this.bindSliderEvents();
            this.bindContentEditableEvents();
            this.bindSelectEvents();
            
            // ç»‘å®šæ“ä½œæŒ‰é’®
            this.bindActionButtons();
            
            console.log('[æ™ºèƒ½ç¼–è¾‘å™¨] äº‹ä»¶ç»‘å®šå®Œæˆ');
          },

          // ç»‘å®šè¾“å…¥æ¡†äº‹ä»¶
          bindInputEvents() {
            document.querySelectorAll('.attribute-input, .rich-text-editor').forEach(input => {
              input.addEventListener('input', (e) => {
                this.handleFieldChange(e.target);
              });
              
              input.addEventListener('blur', (e) => {
                this.saveFieldChange(e.target);
              });
            });
          },

          // ç»‘å®šæ»‘å—äº‹ä»¶
          bindSliderEvents() {
            document.querySelectorAll('.attribute-slider').forEach(slider => {
              slider.addEventListener('input', (e) => {
                // åŒæ­¥å¯¹åº”çš„æ•°å­—è¾“å…¥æ¡†
                const path = e.target.dataset.path;
                const numberInput = document.querySelector(`input[type="number"][data-path="${path}"]`);
                if (numberInput) {
                  numberInput.value = e.target.value;
                }
                this.handleFieldChange(e.target);
              });
              
              slider.addEventListener('change', (e) => {
                this.saveFieldChange(e.target);
              });
            });

            // ç»‘å®šæ•°å­—è¾“å…¥æ¡†ä¸æ»‘å—çš„åŒå‘åŒæ­¥
            document.querySelectorAll('input[type="number"][data-path]').forEach(input => {
              input.addEventListener('input', (e) => {
                const path = e.target.dataset.path;
                const slider = document.querySelector(`.attribute-slider[data-path="${path}"]`);
                if (slider) {
                  slider.value = e.target.value;
                }
                this.handleFieldChange(e.target);
              });
            });
          },

          // ç»‘å®šå¯ç¼–è¾‘å†…å®¹äº‹ä»¶
          bindContentEditableEvents() {
            document.querySelectorAll('[contenteditable="true"]').forEach(element => {
              element.addEventListener('input', (e) => {
                this.handleContentEditableChange(e.target);
              });
              
              element.addEventListener('blur', (e) => {
                this.saveContentEditableChange(e.target);
              });
              
              // é˜²æ­¢æ¢è¡Œ
              element.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                  e.preventDefault();
                  e.target.blur();
                }
              });
            });
          },

          // ç»‘å®šä¸‹æ‹‰é€‰æ‹©äº‹ä»¶
          bindSelectEvents() {
            document.querySelectorAll('.smart-select').forEach(select => {
              select.addEventListener('change', (e) => {
                this.handleFieldChange(e.target);
                this.saveFieldChange(e.target);
              });
            });
          },

          // ç»‘å®šæ“ä½œæŒ‰é’®äº‹ä»¶
          bindActionButtons() {
            // è¿™äº›æŒ‰é’®é€šè¿‡onclickå±æ€§ç»‘å®šï¼Œè¿™é‡Œå¯ä»¥æ·»åŠ é¢å¤–çš„å…¨å±€äº‹ä»¶å¤„ç†
          },

          // === å­—æ®µå˜æ›´å¤„ç† ===
          handleFieldChange(element) {
            const path = element.dataset.path;
            const field = element.dataset.field;
            const value = this.parseInputValue(element);
            
            if (path) {
              // å®æ—¶æ›´æ–°å†…éƒ¨æ•°æ®
              this.updateFieldValue(path, value);
              
              // ç‰¹æ®Šå¤„ç†ï¼šå¦‚æœæ˜¯å¥½æ„Ÿåº¦æ»‘å—ï¼ŒåŒæ­¥æ›´æ–°è¿›åº¦æ¡
              if (field === 'favorability') {
                this.updateFavorabilityBar(element, value);
              }
              
              // æ›´æ–°åŸå§‹JSONæ˜¾ç¤º
              this.updateRawValueFromVisual();
              
              // æ ‡è®°ä¸ºå·²ä¿®æ”¹
              element.classList.add('modified');
              
              console.log(`[å­—æ®µå˜æ›´] ${path} = ${value}`);
            }
          },

          // ä¿å­˜å­—æ®µå˜æ›´
          saveFieldChange(element) {
            const path = element.dataset.path;
            const field = element.dataset.field;
            if (path) {
              // åˆ›å»ºç‰ˆæœ¬å†å²è®°å½•
              this.createVersionSnapshot(`ä¿®æ”¹å­—æ®µ: ${path}`);
              
              // ç§»é™¤ä¿®æ”¹æ ‡è®°
              element.classList.remove('modified');
              
              console.log(`[å­—æ®µä¿å­˜] ${path}`);
            }
          },

          // æ›´æ–°å¥½æ„Ÿåº¦è¿›åº¦æ¡
          updateFavorabilityBar(element, value) {
            const card = element.closest('.relationship-card');
            if (card) {
              const progressBar = card.querySelector('.favorability-progress');
              const valueDisplay = card.querySelector('.favorability-value');
              if (progressBar && valueDisplay) {
                const percent = Math.max(0, Math.min(100, (parseInt(value) + 100) / 2));
                progressBar.style.width = `${percent}%`;
                valueDisplay.textContent = `å¥½æ„Ÿåº¦: ${value}`;
              }
            }
          },

          // === äººç‰©å…³ç³»æ“ä½œå‡½æ•° ===
          
          // æ·»åŠ æ–°çš„äººç‰©å…³ç³»
          addRelationship(basePath) {
            const name = prompt('è¯·è¾“å…¥äººç‰©å§“å:');
            if (!name || !name.trim()) return;
            
            const trimmedName = name.trim();
            
            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
            if (this.currentVariableValue && this.currentVariableValue[trimmedName]) {
              alert('è¯¥äººç‰©å·²å­˜åœ¨ï¼');
              return;
            }
            
            // åˆ›å»ºæ–°çš„äººç‰©å…³ç³»å¯¹è±¡
            const newRelationship = {
              ç§°å‘¼: trimmedName,
              relationship: 'é™Œç”Ÿäºº',
              favorability: 0,
              tier: '',
              ç­‰çº§: '',
              èº«ä»½èƒŒæ™¯: '',
              æ€§æ ¼: '',
              å¤–è²Œ: ''
            };
            
            // æ›´æ–°æ•°æ®
            if (!this.currentVariableValue) {
              this.currentVariableValue = {};
            }
            this.currentVariableValue[trimmedName] = newRelationship;
            
            // åˆ›å»ºç‰ˆæœ¬å¿«ç…§
            this.createVersionSnapshot(`æ·»åŠ äººç‰©å…³ç³»: ${trimmedName}`);
            
            // é‡æ–°æ¸²æŸ“
            this.updateVisualEditor();
            
            console.log(`[æ·»åŠ å…³ç³»] ${trimmedName}`, newRelationship);
          },

          // åˆ é™¤äººç‰©å…³ç³»
          removeRelationship(basePath, name) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤äººç‰©å…³ç³»"${name}"å—ï¼Ÿ`)) return;
            
            if (this.currentVariableValue && this.currentVariableValue[name]) {
              delete this.currentVariableValue[name];
              
              // åˆ›å»ºç‰ˆæœ¬å¿«ç…§
              this.createVersionSnapshot(`åˆ é™¤äººç‰©å…³ç³»: ${name}`);
              
              // é‡æ–°æ¸²æŸ“
              this.updateVisualEditor();
              
              console.log(`[åˆ é™¤å…³ç³»] ${name}`);
            }
          },

          // ä¿å­˜äººç‰©å…³ç³»ä¿®æ”¹
          saveRelationshipChanges(basePath, originalName) {
            const card = document.querySelector(`[data-name="${originalName}"]`);
            if (!card) return;
            
            // æ”¶é›†æ‰€æœ‰ä¿®æ”¹çš„å­—æ®µ
            const modifiedElements = card.querySelectorAll('.modified');
            if (modifiedElements.length === 0) {
              alert('æ²¡æœ‰æ£€æµ‹åˆ°ä¿®æ”¹ï¼');
              return;
            }
            
            // ç”ŸæˆMVUå‘½ä»¤
            const commands = this.generateRelationshipMvuCommands(basePath, originalName, modifiedElements);
            
            if (commands.length === 0) {
              alert('æ²¡æœ‰ç”Ÿæˆæœ‰æ•ˆçš„MVUå‘½ä»¤ï¼');
              return;
            }
            
            // æ˜¾ç¤ºå‘½ä»¤é¢„è§ˆ
            const commandText = commands.join('\n');
            if (confirm(`å°†æ‰§è¡Œä»¥ä¸‹MVUå‘½ä»¤ï¼š\n\n${commandText}\n\nç¡®å®šæ‰§è¡Œå—ï¼Ÿ`)) {
              this.executeMultipleMvuCommands(commands);
            }
          },

          // ç”Ÿæˆäººç‰©å…³ç³»MVUå‘½ä»¤
          generateRelationshipMvuCommands(basePath, originalName, modifiedElements) {
            const commands = [];
            
            modifiedElements.forEach(element => {
              const path = element.dataset.path;
              const field = element.dataset.field;
              const value = this.parseInputValue(element);
              
              if (!path || !field) return;
              
              // æ™ºèƒ½åˆ¤æ–­ä½¿ç”¨setè¿˜æ˜¯assign
              const command = this.generateSmartMvuCommand(path, field, value, originalName);
              if (command) {
                commands.push(command);
              }
            });
            
            return commands;
          },

          // æ™ºèƒ½ç”ŸæˆMVUå‘½ä»¤
          generateSmartMvuCommand(path, field, value, characterName) {
            // è§£æè·¯å¾„ï¼Œç¡®å®šæ˜¯å¦æ˜¯äººç‰©å…³ç³»åˆ—è¡¨
            const isRelationshipList = path.includes('äººç‰©å…³ç³»åˆ—è¡¨');
            
            if (isRelationshipList) {
              // å¯¹äºäººç‰©å…³ç³»åˆ—è¡¨ï¼Œä½¿ç”¨assignå‘½ä»¤
              const cleanPath = path.replace(/\.äººç‰©å…³ç³»åˆ—è¡¨\.[^.]+\./, '.äººç‰©å…³ç³»åˆ—è¡¨.');
              const fieldPath = `äººç‰©å…³ç³»åˆ—è¡¨.${characterName}.${field}`;
              
              // æ ¹æ®å­—æ®µç±»å‹å†³å®šå€¼çš„æ ¼å¼
              let formattedValue;
              if (typeof value === 'string') {
                formattedValue = `"${value}"`;
              } else if (typeof value === 'number') {
                formattedValue = value.toString();
              } else {
                formattedValue = JSON.stringify(value);
              }
              
              return `_.assign('${fieldPath}', ${formattedValue}); // ä¿®æ”¹${characterName}çš„${field}`;
            } else {
              // å¯¹äºå…¶ä»–æƒ…å†µï¼Œä½¿ç”¨setå‘½ä»¤
              let formattedValue;
              if (typeof value === 'string') {
                formattedValue = `"${value}"`;
              } else if (typeof value === 'number') {
                formattedValue = value.toString();
              } else {
                formattedValue = JSON.stringify(value);
              }
              
              return `_.set('${path}', ${formattedValue}); // ä¿®æ”¹${field}`;
            }
          },

          // æ‰§è¡Œå¤šä¸ªMVUå‘½ä»¤
          async executeMultipleMvuCommands(commands) {
            try {
              for (const command of commands) {
                await this.executeMvuCommandDirect(command);
                // çŸ­æš‚å»¶è¿Ÿï¼Œé¿å…å‘½ä»¤å†²çª
                await new Promise(resolve => setTimeout(resolve, 100));
              }
              
              alert('æ‰€æœ‰ä¿®æ”¹å·²æˆåŠŸä¿å­˜ï¼');
              
              // æ¸…é™¤æ‰€æœ‰ä¿®æ”¹æ ‡è®°
              document.querySelectorAll('.modified').forEach(el => {
                el.classList.remove('modified');
              });
              
              // é‡æ–°åŠ è½½æ•°æ®
              if (this.currentVariablePath) {
                setTimeout(() => {
                  this.loadVariableFromPath(this.currentVariablePath);
                }, 500);
              }
              
            } catch (error) {
              console.error('æ‰§è¡ŒMVUå‘½ä»¤æ—¶å‡ºé”™:', error);
              alert(`ä¿å­˜å¤±è´¥: ${error.message}`);
            }
          },

          // å¤„ç†å¯ç¼–è¾‘å†…å®¹å˜æ›´
          handleContentEditableChange(element) {
            const field = element.dataset.field;
            const value = element.textContent.trim();
            
            if (field === 'name') {
              // ç‰¹æ®Šå¤„ç†åç§°å˜æ›´
              this.handleNameChange(element, value);
            }
          },

          // ä¿å­˜å¯ç¼–è¾‘å†…å®¹å˜æ›´
          saveContentEditableChange(element) {
            const field = element.dataset.field;
            const value = element.textContent.trim();
            
            if (field === 'name') {
              this.createVersionSnapshot(`ä¿®æ”¹åç§°: ${value}`);
            }
          },

          // è§£æè¾“å…¥å€¼
          parseInputValue(element) {
            const value = element.value;
            const type = element.dataset.type;
            
            switch (type) {
              case 'number':
                return parseFloat(value) || 0;
              case 'boolean':
                return value === 'true' || value === '1';
              default:
                return value;
            }
          },

          // æ›´æ–°å­—æ®µå€¼
          updateFieldValue(path, value) {
            try {
              this.setValueByPath(this.currentVariableValue, path, value);
            } catch (error) {
              console.error(`[å­—æ®µæ›´æ–°å¤±è´¥] ${path}:`, error);
            }
          },

          // ä»å¯è§†åŒ–ç¼–è¾‘å™¨æ›´æ–°åŸå§‹å€¼æ˜¾ç¤º
          updateRawValueFromVisual() {
            const rawTextarea = document.getElementById('new-variable-value');
            if (rawTextarea && this.currentVariableValue !== undefined) {
              try {
                rawTextarea.value = JSON.stringify(this.currentVariableValue, null, 2);
                this.previewMvuCommand();
              } catch (error) {
                console.error('æ›´æ–°åŸå§‹å€¼æ˜¾ç¤ºå¤±è´¥:', error);
              }
            }
          },

          // è·¯å¾„å€¼è®¾ç½®å·¥å…·å‡½æ•°
          setValueByPath(obj, path, value) {
            // ç§»é™¤åŸºç¡€è·¯å¾„å‰ç¼€ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            const cleanPath = path.replace(/^[^.]+\./, '');
            const keys = cleanPath.split('.');
            let current = obj;
            
            // å¯¼èˆªåˆ°ç›®æ ‡å¯¹è±¡
            for (let i = 0; i < keys.length - 1; i++) {
              const key = keys[i];
              if (!(key in current) || typeof current[key] !== 'object') {
                current[key] = {};
              }
              current = current[key];
            }
            
            // è®¾ç½®æœ€ç»ˆå€¼
            const finalKey = keys[keys.length - 1];
            current[finalKey] = value;
          },

          // è·¯å¾„å€¼è·å–å·¥å…·å‡½æ•°
          getValueByPath(obj, path) {
            const cleanPath = path.replace(/^[^.]+\./, '');
            const keys = cleanPath.split('.');
            let current = obj;
            
            for (const key of keys) {
              if (current === null || current === undefined || !(key in current)) {
                return undefined;
              }
              current = current[key];
            }
            
            return current;
          },

          // === ç‰ˆæœ¬å†å²å’Œæ’¤é”€é‡åšç³»ç»Ÿ ===
          initVersionHistory() {
            if (!this.versionHistory) {
              this.versionHistory = [];
              this.currentVersionIndex = -1;
            }
            
            // åˆ›å»ºåˆå§‹ç‰ˆæœ¬
            if (this.versionHistory.length === 0) {
              this.createVersionSnapshot('åˆå§‹çŠ¶æ€', false);
            }
            
            // åˆå§‹åŒ–å†å²è®°å½•é¢æ¿
            this.initHistoryPanel();
          },

          // åˆå§‹åŒ–å†å²è®°å½•é¢æ¿
          initHistoryPanel() {
            const visualContent = document.getElementById('visual-editor-content');
            if (!visualContent) return;
            
            // åˆ›å»ºå†å²è®°å½•é¢æ¿å®¹å™¨
            let historyPanel = document.getElementById('version-history-panel');
            if (!historyPanel) {
              historyPanel = document.createElement('div');
              historyPanel.id = 'version-history-panel';
              historyPanel.className = 'version-history-panel';
              historyPanel.innerHTML = `
                <div class="history-panel-header">
                  <h4>ä¿®æ”¹å†å²</h4>
                  <button class="history-toggle-btn" onclick="this.parentElement.parentElement.classList.toggle('collapsed')">
                    <span>â–¼</span>
                  </button>
                </div>
                <div class="history-panel-content">
                  <div class="history-list" id="version-history-list">
                    
                  </div>
                  <div class="history-actions">
                    <button class="action-btn secondary" onclick="guixuApp.clearHistory()">æ¸…ç©ºå†å²</button>
                  </div>
                </div>
              `;
              
              // å°†å†å²é¢æ¿æ’å…¥åˆ°å¯è§†åŒ–ç¼–è¾‘å™¨æ—è¾¹
              const visualMode = document.getElementById('visual-edit-mode');
              if (visualMode) {
                visualMode.appendChild(historyPanel);
              }
            }
            
            this.updateVersionHistoryUI();
          },

          // æ’¤é”€æ“ä½œ
          undo() {
            if (this.currentVersionIndex > 0) {
              this.currentVersionIndex--;
              const version = this.versionHistory[this.currentVersionIndex];
              this.restoreVersion(version);
              console.log(`[æ’¤é”€] æ¢å¤åˆ°: ${version.description}`);
            }
          },

          // é‡åšæ“ä½œ
          redo() {
            if (this.currentVersionIndex < this.versionHistory.length - 1) {
              this.currentVersionIndex++;
              const version = this.versionHistory[this.currentVersionIndex];
              this.restoreVersion(version);
              console.log(`[é‡åš] æ¢å¤åˆ°: ${version.description}`);
            }
          },

          // æ¢å¤åˆ°æŒ‡å®šç‰ˆæœ¬
          restoreVersion(version) {
            this.currentVariableValue = JSON.parse(JSON.stringify(version.data));
            this.updateVisualEditor();
            this.updateRawValueFromVisual();
            this.updateVersionHistoryUI();
          },

          // æ›´æ–°ç‰ˆæœ¬å†å²UI
          updateVersionHistoryUI() {
            const historyList = document.getElementById('version-history-list');
            if (!historyList || !this.versionHistory) return;

            // æ¸…ç©ºç°æœ‰å†…å®¹
            historyList.innerHTML = '';

            // å¦‚æœæ²¡æœ‰å†å²è®°å½•ï¼Œæ˜¾ç¤ºæç¤º
            if (this.versionHistory.length === 0) {
              historyList.innerHTML = '<div style="text-align: center; color: #888; padding: 20px;">æš‚æ— å†å²è®°å½•</div>';
              return;
            }

            // æ¸²æŸ“å†å²è®°å½•åˆ—è¡¨ï¼ˆå€’åºæ˜¾ç¤ºï¼Œæœ€æ–°çš„åœ¨ä¸Šé¢ï¼‰
            for (let i = this.versionHistory.length - 1; i >= 0; i--) {
              const version = this.versionHistory[i];
              const isCurrent = i === this.currentVersionIndex;
              
              const historyItem = document.createElement('div');
              historyItem.className = `history-item ${isCurrent ? 'current' : ''}`;
              historyItem.dataset.index = i;
              
              // æ ¼å¼åŒ–æ—¶é—´
              const time = new Date(version.timestamp).toLocaleString('zh-CN', {
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
              });
              
              historyItem.innerHTML = `
                <div class="history-item-info">
                  <div class="history-item-description">${version.description}</div>
                  <div class="history-item-time">${time}</div>
                </div>
              `;
              
              // æ·»åŠ ç‚¹å‡»äº‹ä»¶
              historyItem.addEventListener('click', () => {
                this.restoreToVersion(parseInt(historyItem.dataset.index));
              });
              
              historyList.appendChild(historyItem);
            }

            console.log(`[ç‰ˆæœ¬å†å²] å½“å‰ç‰ˆæœ¬: ${this.currentVersionIndex + 1}/${this.versionHistory.length}`);
          },

          // æ¢å¤åˆ°æŒ‡å®šç‰ˆæœ¬
          restoreToVersion(versionIndex) {
            if (versionIndex >= 0 && versionIndex < this.versionHistory.length) {
              this.currentVersionIndex = versionIndex;
              const version = this.versionHistory[versionIndex];
              this.restoreVersion(version);
              console.log(`[ç‰ˆæœ¬å†å²] æ¢å¤åˆ°ç‰ˆæœ¬: ${version.description}`);
            }
          },

          // æ¸…ç©ºå†å²è®°å½•
          clearHistory() {
            if (this.versionHistory && this.versionHistory.length > 1) {
              // ä¿ç•™å½“å‰çŠ¶æ€ä½œä¸ºå”¯ä¸€çš„å†å²è®°å½•
              const currentVersion = this.versionHistory[this.currentVersionIndex];
              this.versionHistory = [currentVersion];
              this.currentVersionIndex = 0;
              this.updateVersionHistoryUI();
              console.log('[ç‰ˆæœ¬å†å²] å†å²è®°å½•å·²æ¸…ç©º');
            }
          },

          // === æ•°æ®åŒæ­¥å’Œæ›´æ–° ===
          updateRawValueFromVisual() {
            try {
              const rawTextarea = document.getElementById('new-variable-value');
              if (rawTextarea) {
                rawTextarea.value = JSON.stringify(this.currentVariableValue, null, 2);
                this.previewMvuCommand();
              }
            } catch (error) {
              console.error('ä»å¯è§†åŒ–ç¼–è¾‘å™¨æ›´æ–°åŸå§‹å€¼æ—¶å‡ºé”™:', error);
            }
          },

          // === æ“ä½œæ–¹æ³• ===
          
          // æ¢å¤å­—æ®µ
          revertField(path) {
            if (this.versionHistory.length > 1) {
              const previousVersion = this.versionHistory[this.currentVersionIndex - 1];
              if (previousVersion) {
                const previousValue = this.getValueByPath(previousVersion.data, path);
                this.setValueByPath(this.currentVariableValue, path, previousValue);
                this.updateVisualEditor();
                this.updateRawValueFromVisual();
                console.log(`[å­—æ®µæ¢å¤] ${path}`);
              }
            }
          },

          // ä¿å­˜å­—æ®µ
          saveField(path) {
            this.createVersionSnapshot(`ä¿å­˜å­—æ®µ: ${path}`);
          },

          // æ·»åŠ å…³ç³»
          addRelationship(path) {
            const name = prompt('è¯·è¾“å…¥äººç‰©å§“å:');
            if (name && name.trim()) {
              const relationships = this.getValueByPath(this.currentVariableValue, path) || {};
              relationships[name.trim()] = {
                relationship: 'æœªçŸ¥å…³ç³»',
                favorability: 0
              };
              this.setValueByPath(this.currentVariableValue, path, relationships);
              this.createVersionSnapshot(`æ·»åŠ å…³ç³»: ${name.trim()}`);
              this.updateVisualEditor();
              this.updateRawValueFromVisual();
            }
          },

          // åˆ é™¤å…³ç³»
          removeRelationship(path, name) {
            if (confirm(`ç¡®å®šè¦åˆ é™¤ä¸ ${name} çš„å…³ç³»å—ï¼Ÿ`)) {
              const relationships = this.getValueByPath(this.currentVariableValue, path) || {};
              delete relationships[name];
              this.setValueByPath(this.currentVariableValue, path, relationships);
              this.createVersionSnapshot(`åˆ é™¤å…³ç³»: ${name}`);
              this.updateVisualEditor();
              this.updateRawValueFromVisual();
            }
          },

          // å¤„ç†åç§°å˜æ›´
          handleNameChange(element, newName) {
            // è¿™é‡Œå¯ä»¥æ·»åŠ åç§°å˜æ›´çš„ç‰¹æ®Šé€»è¾‘
            console.log(`[åç§°å˜æ›´] ${newName}`);
          },

          // === é”®ç›˜å¿«æ·é”®æ”¯æŒ ===
          initKeyboardShortcuts() {
            document.addEventListener('keydown', (e) => {
              // åªåœ¨å¯è§†åŒ–ç¼–è¾‘æ¨¡å¼ä¸‹å¯ç”¨å¿«æ·é”®
              if (this.currentEditMode !== 'visual') return;
              
              // Ctrl+Z: æ’¤é”€
              if (e.ctrlKey && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                this.undo();
              }
              
              // Ctrl+Shift+Z æˆ– Ctrl+Y: é‡åš
              if ((e.ctrlKey && e.shiftKey && e.key === 'Z') || (e.ctrlKey && e.key === 'y')) {
                e.preventDefault();
                this.redo();
              }
              
              // Ctrl+S: ä¿å­˜å½“å‰çŠ¶æ€
              if (e.ctrlKey && e.key === 's') {
                e.preventDefault();
                this.createVersionSnapshot('æ‰‹åŠ¨ä¿å­˜');
              }
              
              // Esc: å–æ¶ˆå½“å‰ç¼–è¾‘
              if (e.key === 'Escape') {
                document.activeElement.blur();
              }
            });
          },

          // === æ•°æ®æ”¶é›†å’Œè§£æ ===
          collectVisualEditorData() {
            // ç›´æ¥è¿”å›å½“å‰çš„å˜é‡å€¼ï¼Œå› ä¸ºæˆ‘ä»¬å·²ç»å®æ—¶æ›´æ–°äº†
            return this.currentVariableValue;
          },

          parseVisualValue(value) {
            if (value === '' || value === 'null') return null;
            if (value === 'true') return true;
            if (value === 'false') return false;
            if (!isNaN(value) && !isNaN(parseFloat(value))) return parseFloat(value);
            return value;
          },

          // === ç®€å•å¯¹è±¡å’Œæ•°ç»„æ¸²æŸ“å™¨ ===
          renderSimpleObject(obj, path) {
            let html = `<div class="smart-form-group" data-path="${path}">
              <label class="smart-form-label">${path.split('.').pop() || 'å¯¹è±¡'}</label>`;
            
            Object.entries(obj).forEach(([key, value]) => {
              const fieldPath = `${path}.${key}`;
              html += `<div class="attribute-item">
                <label class="attribute-label">${key}</label>
                <input type="text" class="attribute-input"
                       value="${value}" data-path="${fieldPath}">
              </div>`;
            });
            
            html += `</div>`;
            return html;
          },

          renderSmartArray(arr, path) {
            let html = `<div class="relationships-container" data-path="${path}">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>${path.split('.').pop() || 'æ•°ç»„'} (${arr.length}é¡¹)</span>
                <span>â–¼</span>
              </div>
              <div class="details-content">
                <ul class="sortable-list" data-path="${path}">`;

            arr.forEach((item, index) => {
              const itemPath = `${path}[${index}]`;
              html += `<li class="sortable-item" data-index="${index}">
                <span class="drag-handle">â‹®â‹®</span>
                <div style="flex: 1;">`;
              
              if (typeof item === 'object' && item !== null) {
                html += `<textarea class="rich-text-editor" data-path="${itemPath}" rows="2">${JSON.stringify(item, null, 2)}</textarea>`;
              } else {
                html += `<input type="text" class="attribute-input" value="${item}" data-path="${itemPath}">`;
              }
              
              html += `</div>
                <button class="action-btn secondary" onclick="guixuApp.removeArrayItem('${path}', ${index})">åˆ é™¤</button>
              </li>`;
            });

            html += `</ul>
              <div class="action-buttons">
                <button class="action-btn" onclick="guixuApp.addArrayItem('${path}')">æ·»åŠ é¡¹ç›®</button>
              </div>
            </div></div>`;

            return html;
          },

          renderPrimitiveValue(value, path) {
            const type = typeof value;
            let inputType = 'text';
            let inputClass = 'attribute-input';
            
            if (type === 'number') {
              inputType = 'number';
            } else if (type === 'boolean') {
              return `<div class="smart-form-group">
                <label class="smart-form-label">${path.split('.').pop() || 'å€¼'}</label>
                <select class="smart-select" data-path="${path}">
                  <option value="true" ${value ? 'selected' : ''}>æ˜¯</option>
                  <option value="false" ${!value ? 'selected' : ''}>å¦</option>
                </select>
              </div>`;
            }

            return `<div class="smart-form-group">
              <label class="smart-form-label">${path.split('.').pop() || 'å€¼'}</label>
              <input type="${inputType}" class="${inputClass}"
                     value="${value}" data-path="${path}">
            </div>`;
          },

          renderGenericObject(obj, path) {
            let html = `<div class="details-section" data-path="${path}">
              <div class="details-toggle" onclick="this.nextElementSibling.classList.toggle('hidden')">
                <span>${path.split('.').pop() || 'å¯¹è±¡'} (${Object.keys(obj).length}ä¸ªå±æ€§)</span>
                <span>â–¼</span>
              </div>
              <div class="details-content">`;

            Object.entries(obj).forEach(([key, value]) => {
              const fieldPath = `${path}.${key}`;
              html += this.renderGenericField(key, value, fieldPath);
            });

            html += `</div></div>`;
            return html;
          },

          // === æ•°ç»„æ“ä½œæ–¹æ³• ===
          addArrayItem(path) {
            const arr = this.getValueByPath(this.currentVariableValue, path) || [];
            const newItem = prompt('è¯·è¾“å…¥æ–°é¡¹ç›®çš„å€¼:');
            if (newItem !== null) {
              arr.push(newItem);
              this.setValueByPath(this.currentVariableValue, path, arr);
              this.createVersionSnapshot(`æ·»åŠ æ•°ç»„é¡¹: ${newItem}`);
              this.updateVisualEditor();
              this.updateRawValueFromVisual();
            }
          },

          removeArrayItem(path, index) {
            const arr = this.getValueByPath(this.currentVariableValue, path) || [];
            if (confirm(`ç¡®å®šè¦åˆ é™¤ç¬¬ ${index + 1} é¡¹å—ï¼Ÿ`)) {
              arr.splice(index, 1);
              this.setValueByPath(this.currentVariableValue, path, arr);
              this.createVersionSnapshot(`åˆ é™¤æ•°ç»„é¡¹: ç´¢å¼•${index}`);
              this.updateVisualEditor();
              this.updateRawValueFromVisual();
            }
          },

          // æ–°å¢ï¼šæ ¹æ®è·¯å¾„è®¾ç½®å€¼
          setValueByPath(obj, path, value) {
            const keys = path.split(/[\.\[\]]/).filter(key => key !== '');
            let current = obj;
            
            for (let i = 0; i < keys.length - 1; i++) {
              const key = keys[i];
              if (!(key in current)) {
                current[key] = isNaN(keys[i + 1]) ? {} : [];
              }
              current = current[key];
            }
            
            const lastKey = keys[keys.length - 1];
            current[lastKey] = value;
          },

          async showRelationships() {
             // --- æœ€ç»ˆä¿®å¤æ–¹æ¡ˆï¼šåŠ¨æ€æ³¨å…¥CSSå˜é‡ ---
             document.documentElement.style.setProperty('--relationship-modal-width', '98vw');
             document.documentElement.style.setProperty('--relationship-modal-height', '98vh');
             
              this.loadRelationshipSortSettings(); // åŠ è½½æ’åºè®¾ç½®
              this.openModal('relationships-modal');
              const container = document.querySelector('#relationships-modal .relationships-container');
              if (!container) return;

              const listPanel = container.querySelector('.character-list-panel .character-list');
              const detailsPanel = container.querySelector('.character-details-panel');
              if (!listPanel || !detailsPanel) return;

              listPanel.innerHTML = '<p class="modal-placeholder">æ­£åœ¨æ¢³ç†äººè„‰...</p>';
              detailsPanel.innerHTML = '';

              try {
                  const messages = await getChatMessages(getCurrentMessageId());
                  if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
                      listPanel.innerHTML = '<p class="modal-placeholder">æ— æ³•è·å–äººç‰©å…³ç³»æ•°æ®ã€‚</p>';
                      return;
                  }
                  const stat_data = messages[0].data.stat_data;
                  this.loadIntimateList();
                  const relationships = this.SafeGetValue(stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨', {});
                  console.log('[å½’å¢Ÿ-è°ƒè¯•] ä»MVUè·å–çš„å®Œæ•´äººç‰©å…³ç³»åˆ—è¡¨:', JSON.parse(JSON.stringify(relationships)));
                  
                  this.currentRelationshipData = relationships; // ç¼“å­˜æ•°æ®
                  
                  this.renderCharacterList();
                  
                  // é»˜è®¤æ˜¾ç¤ºç¬¬ä¸€ä¸ªäººç‰©çš„è¯¦æƒ…
                  const firstCharacterName = listPanel.querySelector('.character-card')?.dataset.characterName;
                  if (firstCharacterName) {
                      this.renderCharacterDetails(firstCharacterName);
                  } else {
                      detailsPanel.innerHTML = '<p class="modal-placeholder">æš‚æ— äººç‰©è¯¦æƒ…ã€‚</p>';
                  }
                  
                  this.adjustRelationshipPanelWidth();

                  // äº‹ä»¶ç»‘å®šç°åœ¨ç§»åŠ¨åˆ° renderCharacterDetails å†…éƒ¨ï¼Œä»¥ç¡®ä¿æ¯æ¬¡æ¸²æŸ“éƒ½ç”Ÿæ•ˆ

                  // --- ç»ˆæå°ºå¯¸ä¿®å¤ï¼šåœ¨æ‰€æœ‰æ¸²æŸ“å®Œæˆåï¼Œç”¨JSç›´æ¥è¦†ç›–å†…è”æ ·å¼ ---
                  const modalContent = container.closest('.modal-content');
                  if (modalContent) {
                    modalContent.style.setProperty('width', '100vw', 'important');
                    modalContent.style.setProperty('height', '100vh', 'important');
                    modalContent.style.setProperty('top', '0', 'important');
                    modalContent.style.setProperty('left', '0', 'important');
                    modalContent.style.setProperty('max-width', 'none', 'important');
                    modalContent.style.setProperty('max-height', 'none', 'important');
                  }

              } catch (error) {
                  console.error('åŠ è½½äººç‰©å…³ç³»æ—¶å‡ºé”™:', error);
                  listPanel.innerHTML = `<p class="modal-placeholder">åŠ è½½äººç‰©å…³ç³»æ—¶å‡ºé”™: ${error.message}</p>`;
              }
          },

          renderCharacterList() {
              const listPanel = document.querySelector('#relationships-modal .character-list');
              const listHeader = document.querySelector('#relationships-modal .character-list-header');
              if (!listPanel || !this.currentRelationshipData || !listHeader) return;

              const relationships = this.currentRelationshipData;
              let allRelationshipEntries = Object.entries(relationships).filter(([name, rel]) => {
                  return name && name !== '$meta' && rel && typeof rel === 'object';
              });

              // æœç´¢è¿‡æ»¤
              const searchTerm = listHeader.querySelector('.character-search-input')?.value || '';
              if (searchTerm) {
                  allRelationshipEntries = allRelationshipEntries.filter(([name, rel]) => {
                      return name.toLowerCase().includes(searchTerm.toLowerCase());
                  });
              }

              // æ›´æ–°è§’è‰²è®¡æ•°
              const subtitleElement = document.querySelector('#relationships-modal .character-list-header .subtitle');
              if (subtitleElement) {
                  subtitleElement.textContent = `å…± ${allRelationshipEntries.length} ä¸ªè§’è‰²`;
              }

              const sortedEntries = this.sortRelationshipEntries(allRelationshipEntries);

              if (sortedEntries.length === 0) {
                  listPanel.innerHTML = '<p class="modal-placeholder">æš‚æ— äººç‰©å…³ç³»ã€‚</p>';
                  return;
              }

              listPanel.innerHTML = sortedEntries.map(([name, rel]) => {
                  const cultivation = this.SafeGetValue(rel, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº');
                  const tierMatch = cultivation.match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|é£å‡|ç¥æ¡¥|å‡¡äºº)/);
                  const tier = tierMatch ? tierMatch[0] : 'å‡¡äºº';
                  const style = this.getJingJieStyle(tier);
                  const favorability = this.SafeGetValue(rel, 'å¥½æ„Ÿåº¦', 0);
                  const favorPercentage = Math.min(Math.abs(favorability) / 200 * 100, 100);
                  const favorClass = favorability >= 0 ? 'positive' : 'negative';

                  // ä¸ºå¡ç‰‡èƒŒæ™¯é¢„ç•™ä¸€ä¸ªstyleå±æ€§
                  return `
                      <div class="character-card" id="card-${name}" data-character-name="${name}" style="">
                          <div class="card-background-overlay"></div>
                          <div class="avatar" id="avatar-${name}">${name.charAt(0)}</div>
                          <div class="info">
                              <div class="name" style="${style}">${name}</div>
                              <div class="favor-bar-container">
                                  <div class="favor-bar-bg">
                                      <div class="favor-bar ${favorClass}" style="width: ${favorPercentage}%;"></div>
                                  </div>
                                  <div class="favor-value">${favorability}</div>
                              </div>
                          </div>
                      </div>
                  `;
              }).join('');

              // --- å¼‚æ­¥åŠ è½½æ‰€æœ‰åˆ—è¡¨å¤´åƒå’ŒèƒŒæ™¯ ---
              sortedEntries.forEach(([name, rel]) => {
                  this.getAvatarFromDB(name).then(avatarRecord => {
                      const avatarEl = document.getElementById(`avatar-${name}`);
                      if (avatarEl && avatarRecord && avatarRecord.avatarImage) {
                          avatarEl.style.backgroundImage = `url(${avatarRecord.avatarImage})`;
                          avatarEl.style.backgroundSize = 'cover';
                          avatarEl.style.backgroundPosition = 'center';
                          avatarEl.textContent = ''; // æ¸…ç©ºæ–‡å­—
                      }

                      const cardEl = document.getElementById(`card-${name}`);
                      if (cardEl && avatarRecord && avatarRecord.backgroundImage) {
                          cardEl.style.backgroundImage = `url(${avatarRecord.backgroundImage})`;
                          cardEl.style.backgroundSize = 'cover';
                          cardEl.style.backgroundPosition = 'center';
                      }
                  });
              });
          },

           async renderCharacterDetails(characterName) {
               const detailsPanel = document.querySelector('#relationships-modal .character-details-panel');
               if (!detailsPanel || !this.currentRelationshipData) return;

               const characterData = this.currentRelationshipData[characterName];
               console.log(`[å½’å¢Ÿ-è°ƒè¯•] æ­£åœ¨æ¸²æŸ“è§’è‰²'${characterName}'çš„è¯¦æƒ…æ•°æ®:`, JSON.parse(JSON.stringify(characterData)));
               if (!characterData) {
                   detailsPanel.innerHTML = `<p class="modal-placeholder">æ— æ³•æ‰¾åˆ° ${characterName} çš„ä¿¡æ¯ã€‚</p>`;
                   return;
               }

               // 1. å¼‚æ­¥è·å–å›¾ç‰‡å’Œé€æ˜åº¦æ•°æ®
               const avatarRecord = await this.getAvatarFromDB(characterName);
               const avatarImage = avatarRecord ? avatarRecord.avatarImage : '';
               const backgroundImage = avatarRecord ? avatarRecord.backgroundImage : '';
               const backgroundOpacity = avatarRecord ? avatarRecord.backgroundOpacity : 0.5;

               const name = characterName;
               const cultivation = this.SafeGetValue(characterData, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº');
               const tierMatch = cultivation.match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|é£å‡|ç¥æ¡¥|å‡¡äºº)/);
               const tier = tierMatch ? tierMatch[0] : 'å‡¡äºº';
               const age = this.SafeGetValue(characterData, 'å¹´é¾„', '??');
               const appearance = this.SafeGetValue(characterData, 'å¤–è²Œ', 'æš‚æ— ');
               const personality = this.SafeGetValue(characterData, 'æ€§æ ¼', 'æš‚æ— ');
               const origin = this.SafeGetValue(characterData, 'å‡ºèº«', 'æš‚æ— ');
               const lifespan = this.SafeGetValue(characterData, 'å¯¿å…ƒ', '??');
               const location = this.SafeGetValue(characterData, 'æ‰€å¤„åœ°ç‚¹', 'æœªçŸ¥');

               const style = this.getJingJieStyle(tier);
               
               // 2. æ›´æ–°HTMLæ¨¡æ¿
               const avatarStyle = avatarImage ? `background-image: url(${avatarImage}); background-size: cover; background-position: center;` : '';
               
               // æ–°é€»è¾‘ï¼šé€šè¿‡åŠ¨æ€styleæ ‡ç­¾æ›´æ–°ä¼ªå…ƒç´ 
               this.updateCharacterDetailsBackground(backgroundImage, backgroundOpacity);

               let html = `
                   <div class="details-header">
                       <div class="avatar-container">
                           <div class="large-avatar" id="large-avatar-${name}" style="${avatarStyle}">${avatarImage ? '' : name.charAt(0)}</div>
                           <div class="custom-image-prompt">
                               <i class="fas fa-camera"></i>
                               <span>ç‚¹å‡»ä¸Šä¼ å›¾ç‰‡</span>
                           </div>
                       </div>
                       <div class="main-info">
                           <div class="name" style="${style}">${name}</div>
                           <div style="display: flex; align-items: center; justify-content: space-between; gap: 15px; margin-top: 5px;">
                             <div style="display: flex; align-items: center; gap: 15px;">
                               <div class="title">${cultivation} Â· ${age}/${lifespan}</div>
                               <div class="location-tag"><i class="fas fa-map-marker-alt"></i> ${location}</div>
                             </div>
                             <div class="avatar-controls">
                                 <i class="fas fa-eye"></i>
                                 <input type="range" id="avatar-opacity-slider" min="0" max="1" step="0.05" value="${backgroundOpacity}" title="è°ƒæ•´èƒŒæ™¯é€æ˜åº¦">
                                 <span id="avatar-opacity-value">${Math.round(backgroundOpacity * 100)}%</span>
                             </div>
                           </div>
                       </div>
                   </div>
                   <div class="details-tabs">
                       <button class="tab-button active" data-tab="attributes">è¯¦æƒ…</button>
                       <button class="tab-button" data-tab="journey">é“é€”</button>
                       <button class="tab-button" data-tab="skills">åŠŸæ³•</button>
                       <button class="tab-button" data-tab="equipment">è£…å¤‡</button>
                       <button class="tab-button" data-tab="inventory">å‚¨ç‰©è¢‹</button>
                       <button class="tab-button" data-tab="social">ç¤¾äº¤</button>
                       <button class="tab-button" data-tab="memory">è®°å¿†</button>
                   </div>
                   <div class="details-content" style="display: flex; flex-direction: column; flex-grow: 1; min-height: 0;">
                       <div class="tab-pane active" id="tab-attributes">
                           <div class="info-section">
                               <h4>åŸºæœ¬ä¿¡æ¯</h4>
                               <div class="info-grid">
                                   <div class="info-item"><strong>å¥½æ„Ÿåº¦:</strong> ${this.SafeGetValue(characterData, 'å¥½æ„Ÿåº¦', 0)}</div>
                                   <div class="info-item"><strong>å…³ç³»:</strong> ${this.SafeGetValue(characterData, 'å…³ç³»', 'æœªçŸ¥')}</div>
                               </div>
                               <div class="info-grid" style="margin-top: 12px;">
                                   <div class="info-item full-width"><strong>èº«ä»½èƒŒæ™¯:</strong> ${this.SafeGetValue(characterData, 'èº«ä»½èƒŒæ™¯', 'æš‚æ— ')}</div>
                                   <div class="info-item full-width"><strong>æ€§æ ¼:</strong> ${personality}</div>
                                   <div class="info-item full-width"><strong>å¤–è²Œ:</strong> ${appearance}</div>
                                   <div class="info-item full-width"><strong>ç©¿ç€:</strong> ${this.SafeGetValue(characterData, 'ç©¿ç€', 'æš‚æ— ')}</div>
                                   <input type="checkbox" id="toggle-mind" class="hidden-toggle">
                                   <label for="toggle-mind" class="info-item full-width separator-line">â€”â€” å†…å¿ƒ â€”â€”</label>
                                   <div class="collapsible-content">
                                       <div class="info-item full-width"><strong>å½“å‰å†…å¿ƒæƒ³æ³•:</strong> ${this.SafeGetValue(characterData, 'å½“å‰å†…å¿ƒæƒ³æ³•', 'æš‚æ— ')}</div>
                                       <div class="info-item full-width"><strong>çŸ­æœŸç›®æ ‡:</strong> ${this.SafeGetValue(characterData, 'çŸ­æœŸç›®æ ‡', 'æš‚æ— ')}</div>
                                       <div class="info-item full-width"><strong>é•¿æœŸç›®æ ‡:</strong> ${this.SafeGetValue(characterData, 'é•¿æœŸç›®æ ‡', 'æš‚æ— ')}</div>
                                   </div>
                               </div>
                           </div>
                           <div class="info-section">
                               <h4>å±æ€§æ€»è§ˆ</h4>
                               <div class="info-grid">
                                    <div class="info-item"><strong>è¡€é‡:</strong> ${this.SafeGetValue(characterData, 'å½“å‰è¡€é‡', 0)} / ${this.SafeGetValue(characterData, 'è¡€é‡', 0)}</div>
                                    <div class="info-item"><strong>æ³•åŠ›:</strong> ${this.SafeGetValue(characterData, 'å½“å‰æ³•åŠ›', 0)} / ${this.SafeGetValue(characterData, 'æ³•åŠ›', 0)}</div>
                               </div>
                               <div class="info-grid" style="margin-top: 12px;">
                                    <div class="info-item"><strong>ç¥æµ·:</strong> ${this.SafeGetValue(characterData, 'å½“å‰ç¥æµ·', 0)} / ${this.SafeGetValue(characterData, 'ç¥æµ·', 0)}</div>
                                    <div class="info-item"><strong>é“å¿ƒ:</strong> ${this.SafeGetValue(characterData, 'å½“å‰é“å¿ƒ', 0)} / ${this.SafeGetValue(characterData, 'é“å¿ƒ', 0)}</div>
                               </div>
                               <div class="info-grid" style="margin-top: 12px;">
                                    <div class="info-item"><strong>ç©ºé€Ÿ:</strong> ${this.SafeGetValue(characterData, 'å½“å‰ç©ºé€Ÿ', 0)} / ${this.SafeGetValue(characterData, 'ç©ºé€Ÿ', 0)}</div>
                                    <div class="info-item"><strong>æ°”è¿:</strong> ${this.SafeGetValue(characterData, 'æ°”è¿', 0)}</div>
                               </div>
                               <div class="info-grid" style="margin-top: 12px;">
                                    <div class="info-item"><strong>é­…åŠ›:</strong> ${this.SafeGetValue(characterData, 'é­…åŠ›', 0)}</div>
                                    <div class="info-item"><strong>æ‚Ÿæ€§:</strong> ${this.SafeGetValue(characterData, 'æ‚Ÿæ€§', 0)}</div>
                               </div>
                           </div>
                       </div>
                       <div class="tab-pane" id="tab-journey">${this._renderDaotuContent(characterData)}</div>
                       <div class="tab-pane" id="tab-skills">${this._renderGongfaSection(characterData)}</div>
                       <div class="tab-pane" id="tab-equipment">${this._renderEquipmentSection(characterData)}</div>
                       <div class="tab-pane" id="tab-inventory">${this._renderInventorySection(characterData)}</div>
                       <div class="tab-pane" id="tab-social">${this._renderSocialSection(characterData)}</div>
                       <div class="tab-pane" id="tab-memory">${this._renderMemorySection(characterData)}</div>
                   </div>
               `;
               detailsPanel.innerHTML = html;

               // 3. æ›´æ–°äº‹ä»¶ç»‘å®š
               const avatarContainer = detailsPanel.querySelector('.avatar-container');
               const opacitySlider = detailsPanel.querySelector('#avatar-opacity-slider');
               const opacityValueEl = detailsPanel.querySelector('#avatar-opacity-value');
               let debounceTimer;

               // ç»‘å®šå¤´åƒä¸Šä¼ äº‹ä»¶
               if (avatarContainer) {
                   avatarContainer.onclick = (e) => {
                       if (e.target.closest('.large-avatar') || e.target.closest('.custom-image-prompt')) {
                           const input = document.createElement('input');
                           input.type = 'file';
                           input.accept = 'image/*';
                           input.onchange = (event) => {
                               const file = event.target.files[0];
                               if (file) this.handleAvatarUpload(characterName, file);
                           };
                           input.click();
                       }
                   };
               }

               // ç»‘å®šèƒŒæ™¯é€æ˜åº¦æ»‘å—äº‹ä»¶
               if (opacitySlider) {
                   let animationFrameId = null;
                   opacitySlider.addEventListener('input', () => {
                       const newOpacity = opacitySlider.value;

                       // ä½¿ç”¨requestAnimationFrameä¼˜åŒ–UIæ›´æ–°
                       if (animationFrameId) {
                           cancelAnimationFrame(animationFrameId);
                       }
                       animationFrameId = requestAnimationFrame(() => {
                           this.updateCharacterDetailsBackground(backgroundImage, newOpacity); // æ›´æ–°ä¼ªå…ƒç´ æ ·å¼
                           if (opacityValueEl) opacityValueEl.textContent = `${Math.round(newOpacity * 100)}%`;
                       });
                       
                       // ä½¿ç”¨é˜²æŠ–ä¼˜åŒ–æ•°æ®åº“å†™å…¥
                       clearTimeout(debounceTimer);
                       debounceTimer = setTimeout(() => {
                           this.storeAvatarInDB({
                               characterName: characterName,
                               backgroundOpacity: parseFloat(newOpacity)
                           });
                       }, 500);
                   });
               }

               // Re-bind tab events
               const tabs = detailsPanel.querySelectorAll('.tab-button');
               const panes = detailsPanel.querySelectorAll('.tab-pane');
               tabs.forEach(tab => {
                   tab.addEventListener('click', () => {
                       tabs.forEach(t => t.classList.remove('active'));
                       tab.classList.add('active');
                       panes.forEach(p => p.classList.remove('active'));
                       const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                       if(targetPane) targetPane.classList.add('active');
                   });
               });
           },

          _renderSocialSection(characterData) {
              const socialNetwork = this.SafeGetValue(characterData, 'äººç‰©å…³ç³»ç½‘', {});
              const entries = Object.entries(socialNetwork).filter(([name]) => name !== '$meta');
              if (entries.length === 0) {
                  return '<p>æ­¤äººç‹¬æ¥ç‹¬å¾€ï¼Œå°šæœªå»ºç«‹èµ·è‡ªå·±çš„äººè„‰ã€‚</p>';
              }
              let html = '<div class="social-network-grid">';
              entries.forEach(([name, details]) => {
                  html += `
                      <div class="social-card">
                          <div class="social-card-name">${name}</div>
                          <div class="social-card-relationship">${this.SafeGetValue(details, 'relationship', 'æœªçŸ¥å…³ç³»')}</div>
                          <div class="social-card-intimacy">äº²å¯†åº¦: ${this.SafeGetValue(details, 'intimacy', '??')}</div>
                          <div class="social-card-description">${this.SafeGetValue(details, 'description', 'æš‚æ— æè¿°')}</div>
                      </div>
                  `;
              });
              html += '</div>';
              return html;
          },

          _renderMemorySection(characterData) {
              const memory = this.SafeGetValue(characterData, 'é‡è¦äº‹ä»¶è®°å½•', {});
              const entries = Object.entries(memory).filter(([name]) => name !== '$meta');
              if (entries.length === 0) {
                  return '<p class="modal-placeholder">å¾€äº‹å¦‚çƒŸï¼Œæ­¤äººå¿ƒä¸­æœªç•™ä¸‹æ·±åˆ»çš„è®°å¿†ã€‚</p>';
              }
              
              // æŒ‰æ—¶é—´å€’åºæ’åˆ— (ä¿®å¤ï¼šç¡®ä¿èƒ½å¤„ç† "ç¬¬xä¸–-..." å‰ç¼€)
              try {
                entries.sort((a, b) => {
                    const dateA = new Date(a[0].substring(a[0].indexOf('-') + 1));
                    const dateB = new Date(b[0].substring(b[0].indexOf('-') + 1));
                    return dateB - dateA;
                });
              } catch (e) {
                console.error("è§£æè®°å¿†äº‹ä»¶æ—¶é—´å¤±è´¥:", e);
              }

              let html = '<div class="memory-list-new">';
              entries.forEach(([time, details]) => {
                  const type = this.SafeGetValue(details, 'type', 'äº‹ä»¶');
                  const description = this.SafeGetValue(details, 'description', '...');
                  html += `
                      <div class="memory-event-new">
                          <div class="event-dot"></div>
                          <div class="event-main-content">
                              <span class="event-time">${time}</span>
                              <span class="event-description">${description}</span>
                          </div>
                          <div class="event-type-tag">${type}</div>
                      </div>
                  `;
              });
              html += '</div>';
              return html;
          },

          _renderDaotuContent(characterData) {
              const daotuOrder = ['çœŸæ°”', 'ç­‘åŸºå¥‡ç‰©', 'æ´å¤©', 'ç¥å¦™', 'æœ¬å‘½ç¥å¦™', 'ä»™çµä¹‹æ°”'];
              let html = '';
              let hasContent = false;

              daotuOrder.forEach(key => {
                  const data = this.SafeGetValue(characterData, key, null);
                  if (data && (typeof data !== 'object' || Object.keys(data).filter(k => k !== '$meta').length > 0)) {
                      hasContent = true;
                      switch (key) {
                          case 'çœŸæ°”':
                              html += this._renderZhenqiSection(data);
                              break;
                          case 'ç­‘åŸºå¥‡ç‰©':
                              html += this._renderZhujiSection(data);
                              break;
                          case 'æ´å¤©':
                              html += this._renderDongtianSection(data);
                              break;
                          case 'æœ¬å‘½ç¥å¦™':
                              html += this._renderBenmingSection(data);
                              break;
                          case 'ç¥å¦™':
                              html += this._renderShenmiaoSection(data);
                              break;
                          case 'ä»™çµä¹‹æ°”':
                              html += this._renderXianlingqiSection(data);
                              break;
                      }
                  }
              });

              return hasContent ? html : '<p>é“é€”æ¼«æ¼«ï¼Œæ­¤äººå°šæœªç•™ä¸‹ç‹¬ç‰¹çš„è¶³è¿¹ã€‚</p>';
          },

          _renderZhenqiSection(data) {
              if (!data) return '';
              const title = 'çœŸæ°”';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}%</div>`).join('');
              }

              let termsHtml = '';
              const effects = item.special_effects || item.è¯æ¡;
              if (effects && typeof effects === 'object') {
                  const termEntries = Object.entries(effects).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderBenmingSection(data) {
              if (!data) return '';
              const title = 'æœ¬å‘½ç¥å¦™';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);
              
              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}%</div>`).join('');
              }

              let termsHtml = '';
              if (item.è¯æ¡ && typeof item.è¯æ¡ === 'object') {
                  const termEntries = Object.entries(item.è¯æ¡).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              let fusedShenmiaoHtml = '';
              if (item.èåˆç¥å¦™ && typeof item.èåˆç¥å¦™ === 'object') {
                  const fusedEntries = Object.entries(item.èåˆç¥å¦™).filter(([key]) => key !== '$meta');
                  if (fusedEntries.length > 0) {
                      fusedShenmiaoHtml += `<div class="content-divider"><h4 class="daotu-subtitle">èåˆç¥å¦™</h4></div>`;
                      fusedEntries.forEach(([fusedName, fusedData]) => {
                          const fusedTier = fusedData.å“é˜¶ || '';
                          const fusedDesc = fusedData.æè¿° || 'æš‚æ— æè¿°';
                          fusedShenmiaoHtml += `<div class="info-item full-width"><strong>${fusedName}</strong> ${fusedTier ? `ã€${fusedTier}ã€‘` : ''}: ${fusedDesc}</div>`;
                      });
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
                  ${fusedShenmiaoHtml}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderZhujiSection(data) {
              if (!data) return '';
              const title = 'ç­‘åŸºå¥‡ç‰©';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.å¥‘åˆåº¦) descriptiveFieldsHtml += `<div class="info-item"><strong>å¥‘åˆåº¦:</strong> ${item.å¥‘åˆåº¦}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}%</div>`).join('');
              }

              let specialEffectsHtml = '';
              if (item.è¯æ¡ && Object.keys(item.è¯æ¡).filter(k => k !== '$meta').length > 0) {
                  specialEffectsHtml = `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div>` + Object.entries(item.è¯æ¡)
                      .filter(([key]) => key !== '$meta')
                      .map(([key, value]) => `<div class="info-item"><strong>${key}:</strong> ${value}</div>`)
                      .join('');
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  <div class="info-grid">${descriptiveFieldsHtml}</div>
                  <div class="info-grid">${specialEffectsHtml}</div>
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderDongtianSection(data) {
              if (!data) return '';
              const title = 'æ´å¤©';
              const name = Object.keys(data).find(k => k !== '$meta');
              if (!name) return '';
              const item = data[name];
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}%</div>`).join('');
              }

              let daohanHtml = '';
              if (item.é“ç—• && typeof item.é“ç—• === 'object') {
                  const daohanEntries = Object.entries(item.é“ç—•).filter(([key]) => key !== '$meta');
                  if (daohanEntries.length > 0) {
                      daohanHtml += `<div class="content-divider" style="margin-top:10px; padding-top:10px;"><h4 class="daotu-subtitle">é“ç—•</h4></div>`;
                      daohanEntries.forEach(([daohanName, daohanData]) => {
                          const daohanTier = daohanData.å“é˜¶ || '';
                          const daohanDesc = daohanData.æè¿° || 'æš‚æ— æè¿°';
                          daohanHtml += `<div class="info-item full-width"><strong>${daohanName}</strong> ${daohanTier ? `ã€${daohanTier}ã€‘` : ''}: ${daohanDesc}`;
                          
                          // æ–°å¢ï¼šæ¸²æŸ“é“ç—•è¯æ¡
                          if (daohanData.é“ç—•è¯æ¡ && typeof daohanData.é“ç—•è¯æ¡ === 'object') {
                              const termsEntries = Object.entries(daohanData.é“ç—•è¯æ¡).filter(([key]) => key !== '$meta');
                              if (termsEntries.length > 0) {
                                  daohanHtml += `<div class="daotu-terms">`;
                                  termsEntries.forEach(([termName, termData]) => {
                                      daohanHtml += `<div class="term-item"><strong>${termName}:</strong> ${termData.æè¿° || termData}</div>`;
                                  });
                                  daohanHtml += `</div>`;
                              }
                          }
                          daohanHtml += `</div>`;
                      });
                  }
              }
              
              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${daohanHtml}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderShenmiaoSection(data) {
              if (!data || typeof data !== 'object') return '';
              const title = 'ç¥å¦™';
              let html = '';
              const shenmiaoEntries = Object.entries(data).filter(([key]) => key !== '$meta');
              if (shenmiaoEntries.length === 0) return '';
              
              shenmiaoEntries.forEach(([name, item]) => {
                  html += this._renderSingleShenmiao(title, name, item);
              });
              return html;
          },

          _renderSingleShenmiao(title, name, item) {
              const uniqueId = `toggle-daotu-${title}-${name}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let descriptiveFieldsHtml = '';
              const time = item.è·å–æ—¶é—´ || item.ç‚¼å°±æ—¶é—´ || item.å¼€è¾Ÿæ—¶é—´ || item.å‡ç»ƒæ—¶é—´;
              if (time) descriptiveFieldsHtml += `<div class="info-item"><strong>è·å¾—äº:</strong> ${time}</div>`;
              if (item.ç»å†) descriptiveFieldsHtml += `<div class="info-item full-width"><strong>ç»å†:</strong> ${item.ç»å†}</div>`;

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}%</div>`).join('');
              }

              let termsHtml = '';
              if (item.è¯æ¡ && typeof item.è¯æ¡ === 'object') {
                  const termEntries = Object.entries(item.è¯æ¡).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${descriptiveFieldsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">æ¥å†</h4></div><div class="info-grid">${descriptiveFieldsHtml}</div>` : ''}
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">è¯æ¡</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderGongfaSection(characterData) {
              const mainGongfaData = this.SafeGetValue(characterData, 'ä¸»ä¿®åŠŸæ³•', null);
              const subGongfaData = this.SafeGetValue(characterData, 'è¾…ä¿®åŠŸæ³•', null);

              let html = '';
              let hasGongfa = false;

              if (mainGongfaData && typeof mainGongfaData === 'object') {
                  const mainEntries = Object.entries(mainGongfaData).filter(([key]) => key !== '$meta');
                  if (mainEntries.length > 0) {
                      const [name, item] = mainEntries[0];
                      html += this._renderSingleGongfa('ä¸»ä¿®åŠŸæ³•', name, item);
                      hasGongfa = true;
                  }
              }

              if (subGongfaData && typeof subGongfaData === 'object') {
                  const subEntries = Object.entries(subGongfaData).filter(([key]) => key !== '$meta');
                  if (subEntries.length > 0) {
                      const [name, item] = subEntries[0];
                      html += this._renderSingleGongfa('è¾…ä¿®åŠŸæ³•', name, item);
                      hasGongfa = true;
                  }
              }

              return hasGongfa ? html : '<p>æ­¤äººå°šæœªä¿®è¡Œä»»ä½•åŠŸæ³•ã€‚</p>';
          },

          _renderSingleGongfa(title, name, item) {
              if (!item || typeof item !== 'object' || Object.keys(item).length === 0) return '';
              const uniqueId = `toggle-gongfa-${title}-${name.replace(/\s/g, '-')}`;
              const tier = item.tier || item.å“é˜¶ || 'å‡¡å“';
              const style = this.getItemTierStyle(tier);

              let attributesHtml = '';
              if (item.attributes_bonus) {
                  attributesHtml += Object.entries(item.attributes_bonus).map(([key, value]) => `<div class="info-item">${key}: +${value}</div>`).join('');
              }
              if (item.ç™¾åˆ†æ¯”åŠ æˆ) {
                  attributesHtml += Object.entries(item.ç™¾åˆ†æ¯”åŠ æˆ).map(([key, value]) => `<div class="info-item">${key}: +${value}%</div>`).join('');
              }

              let termsHtml = '';
              const effects = item.special_effects || item.è¯æ¡;
              if (effects && typeof effects === 'object') {
                  const termEntries = Object.entries(effects).filter(([key]) => key !== '$meta');
                  if (termEntries.length > 0) {
                      termsHtml += termEntries.map(([key, value]) => `<div class="info-item full-width"><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
                  }
              }

              const contentHtml = `
                  <div class="info-item full-width daotu-description">${item.description || item.æè¿° || ''}</div>
                  ${attributesHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">å±æ€§åŠ æˆ</h4></div><div class="info-grid">${attributesHtml}</div>` : ''}
                  ${termsHtml ? `<div class="content-divider"><h4 class="daotu-subtitle">ç‰¹æ®Šæ•ˆæœ</h4></div><div class="info-grid">${termsHtml}</div>` : ''}
              `;

              return `
                  <div class="info-section">
                      <input type="checkbox" id="${uniqueId}" class="hidden-toggle">
                      <label for="${uniqueId}" class="info-item full-width separator-line">
                          <span>${title}: <span style="${style}">ã€${tier}ã€‘ ${name}</span></span>
                      </label>
                      <div class="collapsible-content"><div>${contentHtml}</div></div>
                  </div>
              `;
          },

          _renderEquipmentSection(characterData) {
              const equipmentKeys = ['æ­¦å™¨', 'é˜²å…·', 'é¥°å“', 'æ³•å®'];
              let html = '';
              let hasEquipment = false;

              equipmentKeys.forEach(key => {
                  const equipmentData = this.SafeGetValue(characterData, key, null);
                  if (equipmentData && typeof equipmentData === 'object') {
                      const entries = Object.entries(equipmentData).filter(([k]) => k !== '$meta');
                      if (entries.length > 0) {
                          const [name, item] = entries[0];
                          html += this._renderSingleGongfa(key, name, item); // å¤ç”¨åŠŸæ³•çš„æ¸²æŸ“é€»è¾‘
                          hasEquipment = true;
                      }
                  }
              });

              return hasEquipment ? html : '<p>æ­¤äººæœªç€å¯¸ç¼•ï¼Œäº¦æ— æ³•å®å‚èº«ã€‚</p>';
          },

          _renderInventorySection(characterData) {
              const inventoryData = this.SafeGetValue(characterData, 'å‚¨ç‰©è¢‹', null);
              if (!inventoryData || typeof inventoryData !== 'object') {
                  return '<p class="modal-placeholder" style="text-align:center;">æ­¤äººèº«æ— é•¿ç‰©ï¼Œå‚¨ç‰©è¢‹ç©ºç©ºå¦‚ä¹Ÿã€‚</p>';
              }

              const itemEntries = Object.entries(inventoryData).filter(([key]) => key !== '$meta');

              if (itemEntries.length === 0) {
                  return '<p class="modal-placeholder" style="text-align:center;">æ­¤äººèº«æ— é•¿ç‰©ï¼Œå‚¨ç‰©è¢‹ç©ºç©ºå¦‚ä¹Ÿã€‚</p>';
              }

              let html = '<div class="inventory-item-list">';
              const sortedItems = this.sortByTier(itemEntries, ([, item]) => this.SafeGetValue(item, 'tier', 'å‡¡å“'));
              
              sortedItems.forEach(([name, item]) => {
                  html += this._renderInventoryItem(name, item);
              });
              html += '</div>';

              return html;
          },

          _renderInventoryItem(name, item) {
              if (!item || typeof item !== 'object') return '';

              const tier = this.SafeGetValue(item, 'tier', 'å‡¡å“');
              const tierStyle = this.getItemTierStyle(tier);
              const quantity = this.SafeGetValue(item, 'quantity', 1);
              const quantityDisplay = quantity > 1 ? `<span class="item-quantity">x${quantity}</span>` : '';
              const description = this.SafeGetValue(item, 'description', this.SafeGetValue(item, 'effect', 'æ— æè¿°'));
              
              const tierDisplay = tier !== 'æ— ' ? `<span style="${tierStyle}">å“é˜¶: ${tier}</span>` : '';

              let detailsHtml = '';
              const attributes = this.SafeGetValue(item, 'attributes_bonus', null);
              const percentage = this.SafeGetValue(item, 'ç™¾åˆ†æ¯”åŠ æˆ', null);
              const effects = item.special_effects || item.è¯æ¡;

              if (attributes) {
                  detailsHtml += Object.entries(attributes).map(([key, value]) => `<div>${key}: +${value}</div>`).join('');
              }
              if (percentage) {
                  detailsHtml += Object.entries(percentage).map(([key, value]) => `<div>${key}: +${value}</div>`).join('');
              }
              if (effects && typeof effects === 'object') {
                  detailsHtml += Object.entries(effects).filter(([key]) => key !== '$meta').map(([key, value]) => `<div><strong>${key}:</strong> ${value.æè¿° || value}</div>`).join('');
              }

              return `
                  <div class="inventory-item">
                      <div class="item-header">
                          <div class="item-name" style="${tierStyle}">${name}</div>
                          <div class="item-meta">
                              ${tierDisplay}
                              ${quantityDisplay}
                          </div>
                      </div>
                      <div class="item-description">${description}</div>
                      ${detailsHtml ? `<div class="item-details">${detailsHtml}</div>` : ''}
                  </div>
              `;
          },

          _renderXianlingqiSection(data) {
             if (!data || data <= 0) return '';
             return `<div class="info-section"><h4>ä»™çµä¹‹æ°”</h4><div class="info-grid"><div class="info-item">${data}</div></div></div>`;
          },

           updateCharacterDetailsBackground(imageUrl, opacity) {
               const styleId = 'character-details-bg-style';
               let styleElement = document.getElementById(styleId);
               if (!styleElement) {
                   styleElement = document.createElement('style');
                   styleElement.id = styleId;
                   document.head.appendChild(styleElement);
               }
               
               let styleContent = '';
               if (imageUrl) {
                   styleContent = `
                       .character-details-panel::before {
                           background-image: url(${imageUrl});
                           opacity: ${opacity};
                       }
                   `;
               } else {
                   styleContent = `
                       .character-details-panel::before {
                           background-image: none;
                       }
                   `;
               }
               styleElement.textContent = styleContent;
           },

          bindRelationshipEvents() {
              // å…³é—­æŒ‰é’®çš„äº‹ä»¶ç°åœ¨ç”±ä¸€ä¸ªåœ¨ initEventListeners ä¸­è®¾ç½®çš„
              // å…¨å±€å§”æ‰˜ç›‘å¬å™¨å¤„ç†ï¼Œæ­¤å¤„æ— éœ€å†ç»‘å®šã€‚

              // æœç´¢åŠŸèƒ½äº‹ä»¶ç»‘å®š
              const searchIcon = document.querySelector('#relationships-modal .header-icon[title="æœç´¢"]');
              const searchInput = document.querySelector('#relationships-modal .character-search-input');
              const listHeader = document.querySelector('#relationships-modal .character-list-header');

              if (searchIcon && searchInput && listHeader) {
                  // é˜²æ­¢é‡å¤ç»‘å®š
                  if (!searchIcon.dataset.listenerAttached) {
                      searchIcon.addEventListener('click', () => {
                          listHeader.classList.toggle('is-searching');
                          if (listHeader.classList.contains('is-searching')) {
                              searchInput.focus();
                          }
                      });
                      searchInput.addEventListener('input', () => {
                          this.renderCharacterList();
                      });
                      searchIcon.dataset.listenerAttached = 'true';
                  }
              }

              const listPanel = document.querySelector('#relationships-modal .character-list');
              if(listPanel) {
                  listPanel.addEventListener('click', (e) => {
                      const card = e.target.closest('.character-card');
                      if (card && card.dataset.characterName) {
                          // ç§»é™¤å…¶ä»–å¡ç‰‡çš„activeçŠ¶æ€
                          listPanel.querySelectorAll('.character-card').forEach(c => c.classList.remove('active'));
                          // ç»™å½“å‰å¡ç‰‡æ·»åŠ activeçŠ¶æ€
                          card.classList.add('active');
                          this.renderCharacterDetails(card.dataset.characterName);
                      }
                  });
              }

              // æ’åºä¸‹æ‹‰èœå•äº‹ä»¶ç»‘å®š
              const sortDropdown = document.querySelector('#relationships-modal .sort-dropdown');
              if (sortDropdown && !sortDropdown.dataset.listenerAttached) {
                  const sortIcon = sortDropdown.querySelector('.header-icon');
                  const sortMenu = sortDropdown.querySelector('.sort-menu');

                  sortIcon.addEventListener('click', (e) => {
                      e.stopPropagation();
                      sortMenu.classList.toggle('active');
                  });

                  sortMenu.addEventListener('click', (e) => {
                      const option = e.target.closest('.sort-option');
                      if (option && option.dataset.sort) {
                          this.relationshipSortType = option.dataset.sort;
                          this.saveRelationshipSortSettings();
                          this.renderCharacterList();
                          
                          // æ›´æ–°é€‰ä¸­çŠ¶æ€
                          sortMenu.querySelectorAll('.sort-option').forEach(opt => opt.classList.remove('selected'));
                          option.classList.add('selected');

                          sortMenu.classList.remove('active');
                      }
                  });

                  // ç‚¹å‡»å…¶ä»–åœ°æ–¹å…³é—­èœå•
                  document.addEventListener('click', (e) => {
                      if (!sortDropdown.contains(e.target)) {
                          sortMenu.classList.remove('active');
                      }
                  });

                  sortDropdown.dataset.listenerAttached = 'true';
              }

              const detailsPanel = document.querySelector('#relationships-modal .character-details-panel');
              if(detailsPanel) {
                  detailsPanel.addEventListener('click', (e) => {
                      const tab = e.target.closest('.tab-button');
                      if (tab && tab.dataset.tab) {
                          detailsPanel.querySelectorAll('.tab-button').forEach(t => t.classList.remove('active'));
                          tab.classList.add('active');

                          detailsPanel.querySelectorAll('.tab-pane').forEach(p => p.classList.remove('active'));
                          const targetPane = detailsPanel.querySelector(`#tab-${tab.dataset.tab}`);
                          if (targetPane) {
                              targetPane.classList.add('active');
                          }
                      }
                  });
              }
          },

          adjustRelationshipPanelWidth() {
            const container = document.querySelector('#relationships-modal .relationships-container');
            if (!container) return;
        
            const listPanel = container.querySelector('.character-list-panel');
            const detailsPanel = container.querySelector('.character-details-panel');
            if (!listPanel || !detailsPanel) return;
        
            const tabPanes = detailsPanel.querySelectorAll('.tab-pane');
            if (tabPanes.length === 0) return;
        
            let minContentWidth = Infinity;
            let maxContentWidth = 0;
        
            // Temporarily show all panes to calculate their min and max widths
            tabPanes.forEach(pane => {
                const originalDisplay = pane.style.display;
                pane.style.display = 'block'; // Make it visible to measure
                
                const currentWidth = pane.scrollWidth;
                if (currentWidth > 0) {
                    minContentWidth = Math.min(minContentWidth, currentWidth);
                }
                maxContentWidth = Math.max(maxContentWidth, currentWidth);
                
                pane.style.display = originalDisplay; // Restore original display style
            });
        
            // If minContentWidth was not updated (e.g., all panes were empty), default it
            if (minContentWidth === Infinity) {
                minContentWidth = 200; // A reasonable default min-width
            }
        
            const padding = 40; // Account for padding/margins
            const finalDetailsWidth = maxContentWidth + padding;
        
            // Apply the calculated widths
            detailsPanel.style.width = `${finalDetailsWidth}px`;
            detailsPanel.style.flexShrink = '0';
        
            tabPanes.forEach(pane => {
                pane.style.minWidth = `${minContentWidth}px`;
            });
        
            listPanel.style.flexGrow = '1';
          },



          renderRelationships(relationships) {
            // æ­¤å‡½æ•°ç°åœ¨ä»…ä½œä¸ºæ—§ä»£ç çš„å…¼å®¹å±‚æˆ–è°ƒåº¦å™¨ï¼Œä¸»è¦é€»è¾‘å·²ç§»è‡³æ–°å‡½æ•°
            // å®é™…æ¸²æŸ“åœ¨æ–°showRelationshipsä¸­å®Œæˆ
            console.warn("renderRelationships is deprecated. Use renderCharacterList and renderCharacterDetails instead.");
            return ""; // è¿”å›ç©ºå­—ç¬¦ä¸²ï¼Œå› ä¸ºæ¸²æŸ“å·²ç”±æ–°å‡½æ•°å¤„ç†
          },

renderIntimateRelationships(relationships) {
    // This function is now a proxy to renderRelationships, ensuring UI consistency.
    return this.renderRelationships(relationships);
},

         // --- æ–°å¢ï¼šäº²å¯†å…³ç³»ç›¸å…³å‡½æ•° ---
         async showIntimateRelationships() {
           this.openModal('intimate-relationships-modal');
           const body = document.querySelector('#intimate-relationships-modal .modal-body');
           if (!body) return;

           body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨åŠ è½½äº²å¯†å…³ç³»...</p>';

           try {
             const messages = await getChatMessages(getCurrentMessageId());
             if (!messages || messages.length === 0 || !messages[0].data || !messages[0].data.stat_data) {
               body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ— æ³•è·å–äººç‰©å…³ç³»æ•°æ®ã€‚</p>';
               return;
             }
             const stat_data = messages[0].data.stat_data;
             this.loadIntimateList(); // æ¸²æŸ“å‰åŠ è½½äº²å¯†åˆ—è¡¨
             // å˜é‡é€‚é…: 'äººç‰©å…³ç³»åˆ—è¡¨' ç°åœ¨æ˜¯ä¸€ä¸ªå¯¹è±¡
             const relationships = this.SafeGetValue(stat_data, 'äººç‰©å…³ç³»åˆ—è¡¨', {});
             body.innerHTML = this.renderIntimateRelationships(relationships);

             // Add event listener for un-marking
             body.addEventListener('click', e => {
               const button = e.target.closest('.btn-unmark-intimate');
               if (button) {
                   const characterId = button.dataset.characterId;
                   if (characterId) {
                       this.toggleIntimateStatus(characterId, false);
                   }
               }
             });

           } catch (error) {
             console.error('åŠ è½½äº²å¯†å…³ç³»æ—¶å‡ºé”™:', error);
             body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">åŠ è½½äº²å¯†å…³ç³»æ—¶å‡ºé”™: ${error.message}</p>`;
           }
         },

         saveIntimateList() {
           try {
             localStorage.setItem('guixu_intimate_characters', JSON.stringify(Array.from(this.intimateCharacters)));
           } catch (e) {
             console.error('ä¿å­˜äº²å¯†å…³ç³»åˆ—è¡¨å¤±è´¥:', e);
           }
         },

         loadIntimateList() {
           try {
             const savedList = localStorage.getItem('guixu_intimate_characters');
             if (savedList) {
               this.intimateCharacters = new Set(JSON.parse(savedList) || []);
             } else {
               this.intimateCharacters = new Set(); // å…³é”®ï¼šå¦‚æœæ²¡æœ‰ä¿å­˜çš„åˆ—è¡¨ï¼Œç¡®ä¿åˆå§‹åŒ–ä¸ºç©ºSet
             }
           } catch (e) {
             console.error('åŠ è½½äº²å¯†å…³ç³»åˆ—è¡¨å¤±è´¥:', e);
             this.intimateCharacters = new Set(); // å‡ºé”™æ—¶ä¹Ÿè¦ç¡®ä¿æ˜¯Set
           }
         },

         // æ–°å¢ï¼šåŠ è½½äººç‰©å…³ç³»è®¾ç½®
         loadRelationshipSettings() {
           try {
             // åŠ è½½æ’åºè®¾ç½®
             const savedSort = localStorage.getItem('guixu_relationship_sort');
             this.relationshipSortType = savedSort || 'default';
             
             // åŠ è½½æ˜¾ç¤ºæ¨¡å¼è®¾ç½®
             const savedDisplayMode = localStorage.getItem('guixu_intimate_display_mode');
             this.intimateDisplayMode = savedDisplayMode === 'true';
             
             console.log('åŠ è½½çš„æ’åºè®¾ç½®:', this.relationshipSortType);
             console.log('åŠ è½½çš„æ˜¾ç¤ºæ¨¡å¼:', this.intimateDisplayMode);
           } catch (e) {
             console.error('åŠ è½½äººç‰©å…³ç³»è®¾ç½®å¤±è´¥:', e);
             this.relationshipSortType = 'default';
             this.intimateDisplayMode = false;
           }
         },

         // æ–°å¢ï¼šè®¾ç½®æ’åºä¸‹æ‹‰æ¡†çš„å€¼ï¼ˆåœ¨æ¸²æŸ“åè°ƒç”¨ï¼‰
         setRelationshipSortValue() {
           setTimeout(() => {
             const sortSelect = document.getElementById('relationship-sort');
             if (sortSelect && this.relationshipSortType) {
               sortSelect.value = this.relationshipSortType;
               console.log('è®¾ç½®æ’åºä¸‹æ‹‰æ¡†å€¼ä¸º:', this.relationshipSortType);
             }
           }, 100);
         },

        toggleIntimateStatus(characterName, markAsIntimate) {
          const id = String(characterName);
          
          if (markAsIntimate) {
            if (!this.intimateCharacters.has(id)) {
              this.intimateCharacters.add(id);
              this.showTemporaryMessage(`å·²å°† [${id}] æ·»åŠ åˆ°äº²å¯†å…³ç³»`);
            }
          } else {
            if (this.intimateCharacters.has(id)) {
              this.intimateCharacters.delete(id);
              this.showTemporaryMessage(`å·²å°† [${id}] ä»äº²å¯†å…³ç³»ä¸­ç§»é™¤`);
            }
          }
          this.saveIntimateList();

          // Refresh the currently open modal to reflect the change immediately
          if (document.getElementById('relationships-modal').style.display === 'flex') {
              this.showRelationships();
          }
        },

         saveRelationshipSortSettings() {
             localStorage.setItem('guixu_relationship_sort', this.relationshipSortType);
         },

         loadRelationshipSortSettings() {
             this.relationshipSortType = localStorage.getItem('guixu_relationship_sort') || 'default';
         },

         // æ–°å¢ï¼šæ’åºå…³ç³»æ¡ç›®çš„å‡½æ•°
         sortRelationshipEntries(entries) {
           const sortType = this.relationshipSortType || 'default';
           
           switch (sortType) {
               case 'cultivation-desc':
               case 'cultivation-asc':
                   const tierOrder = {'å‡¡äºº':0, 'ç»ƒæ°”':1, 'ç­‘åŸº':2, 'æ´ç„':3, 'åˆé“':4, 'ç¥æ¡¥':5 };
                   entries.sort(([nameA, relA], [nameB, relB]) => {
                       const tierA = this.SafeGetValue(relA, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº').match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|ç¥æ¡¥|å‡¡äºº)/)[0];
                       const tierB = this.SafeGetValue(relB, 'å½“å‰ä¿®ä¸º', 'å‡¡äºº').match(/^(ç»ƒæ°”|ç­‘åŸº|æ´ç„|åˆé“|ç¥æ¡¥|å‡¡äºº)/)[0];
                       const orderA = tierOrder[tierA] || 0;
                       const orderB = tierOrder[tierB] || 0;
                       if (orderA !== orderB) {
                           return sortType === 'cultivation-desc' ? orderB - orderA : orderA - orderB;
                       }
                       return nameA.localeCompare(nameB);
                   });
                   break;
               case 'favor-desc':
               case 'favor-asc':
                   entries.sort(([nameA, relA], [nameB, relB]) => {
                       const favA = parseInt(this.SafeGetValue(relA, 'å¥½æ„Ÿåº¦', 0), 10);
                       const favB = parseInt(this.SafeGetValue(relB, 'å¥½æ„Ÿåº¦', 0), 10);
                       if (favA !== favB) {
                           return sortType === 'favor-desc' ? favB - favA : favA - favB;
                       }
                       return nameA.localeCompare(nameB);
                   });
                   break;
               case 'default':
               default:
                   entries.sort(([nameA], [nameB]) => nameA.localeCompare(nameB));
                   break;
           }
           return entries;
         },

         // æ–°å¢ï¼šå¤„ç†æ’åºå˜æ›´
         handleRelationshipSort(sortType) {
           this.relationshipSortType = sortType;
           localStorage.setItem('guixu_relationship_sort', sortType);
           this.showRelationships(); // é‡æ–°æ¸²æŸ“
         },

         // æ–°å¢ï¼šä¸‰è¿å‡»ç›¸å…³å˜é‡å’Œå‡½æ•°
         clickCount: 0,
         clickTimer: null,
         lastClickTarget: null,

         handleTripleClick(characterName, event) {
           // ç°åœ¨åªæœ‰ç‚¹å‡»åå­—æ‰ä¼šè§¦å‘ï¼Œå¯ä»¥å®‰å…¨åœ°é˜»æ­¢é»˜è®¤è¡Œä¸º
           if (event) {
             event.preventDefault();
             event.stopPropagation();
           }
           
           console.log(`ç‚¹å‡»è§’è‰²åå­—: ${characterName}, å½“å‰è®¡æ•°: ${this.clickCount}, ç›®æ ‡: ${this.lastClickTarget}`);
           
           // å¦‚æœç‚¹å‡»çš„æ˜¯ä¸åŒçš„è§’è‰²ï¼Œé‡ç½®è®¡æ•°
           if (this.lastClickTarget !== characterName) {
             this.clickCount = 0;
             this.lastClickTarget = characterName;
           }
           
           this.clickCount++;
           
           // æ¸…é™¤ä¹‹å‰çš„è®¡æ—¶å™¨
           if (this.clickTimer) {
             clearTimeout(this.clickTimer);
           }
           
           // å¦‚æœè¾¾åˆ°3æ¬¡ç‚¹å‡»ï¼Œè§¦å‘äº²å¯†å…³ç³»åˆ‡æ¢
           if (this.clickCount >= 3) {
             console.log(`ä¸‰è¿å‡»æˆåŠŸï¼Œåˆ‡æ¢ ${characterName} çš„äº²å¯†å…³ç³»çŠ¶æ€`);
             this.toggleIntimateStatus(characterName, !this.intimateCharacters.has(characterName));
             this.clickCount = 0;
             this.lastClickTarget = null;
             
             // æ·»åŠ è§†è§‰åé¦ˆ
             const card = event ? event.target.closest('.relationship-card') : null;
             if (card) {
               card.classList.add('triple-clicked');
               setTimeout(() => {
                 card.classList.remove('triple-clicked');
               }, 500);
             }
           } else {
             // è®¾ç½®1ç§’åé‡ç½®è®¡æ•°å™¨
             this.clickTimer = setTimeout(() => {
               console.log(`é‡ç½®ç‚¹å‡»è®¡æ•°å™¨`);
               this.clickCount = 0;
               this.lastClickTarget = null;
             }, 1000);
           }
         },

         // æ–°å¢ï¼šåˆ‡æ¢äº²å¯†å…³ç³»æ˜¾ç¤ºæ¨¡å¼ï¼ˆå¸¦åŠ¨ç”»æ•ˆæœï¼‰
         toggleIntimateMode(targetMode = null) {
           // å¦‚æœæŒ‡å®šäº†ç›®æ ‡æ¨¡å¼ï¼Œåˆ™åˆ‡æ¢åˆ°è¯¥æ¨¡å¼
           if (targetMode !== null) {
             this.intimateDisplayMode = targetMode === 'intimate';
           } else {
             this.intimateDisplayMode = !this.intimateDisplayMode;
           }
           
           localStorage.setItem('guixu_intimate_display_mode', this.intimateDisplayMode);
           
           // æ·»åŠ åˆ‡æ¢åŠ¨ç”»
           const grid = document.querySelector('.relationships-grid');
           if (grid) {
             grid.classList.add('switching');
             
             setTimeout(() => {
               this.showRelationships(); // é‡æ–°æ¸²æŸ“
               
               // æ¸²æŸ“å®Œæˆåç§»é™¤åˆ‡æ¢çŠ¶æ€å¹¶æ·»åŠ è¿›å…¥åŠ¨ç”»
               setTimeout(() => {
                 const newGrid = document.querySelector('.relationships-grid');
                 if (newGrid) {
                   newGrid.classList.remove('switching');
                 }
               }, 50);
             }, 200);
           } else {
             this.showRelationships(); // å¦‚æœæ²¡æœ‰æ‰¾åˆ°gridï¼Œç›´æ¥é‡æ–°æ¸²æŸ“
           }
         },

         // æ–°å¢ï¼šå¤„ç†æ ‡ç­¾é¡µç‚¹å‡»
         handleTabClick(tabType) {
           const targetMode = tabType === 'intimate';
           if (this.intimateDisplayMode !== targetMode) {
             this.toggleIntimateMode(tabType);
           }
         },


          // --- æ–°å¢ï¼šå“é˜¶æ’åºæ ¸å¿ƒå‡½æ•° ---
          getTierOrder(tier) {
            // å“é˜¶ç­‰çº§æ˜ å°„ï¼šæ•°å€¼è¶Šé«˜ï¼Œå“é˜¶è¶Šé«˜
            // å®šä¹‰äº†æ‰€æœ‰å“é˜¶çš„æ’åºè§„åˆ™ï¼Œç”¨äº sortByTier å‡½æ•°ã€‚
            const tierOrder = {
              // ç»ƒæ°”æœŸ
              'å‡¡å“': 1,
              'ç„å“': 2,
              'é“å“': 3,
              // ç­‘åŸºæœŸ
              'äººé˜¶': 4,
              'åœ°é˜¶': 5,
              'å¤©é˜¶': 6,

              // æ´ç„å¢ƒ
              'å‡¡å°˜': 7,
              'çµè„‰': 8,
              'å¤©è±¡': 9,
              'æœ¬æº': 10,
              
              // åˆé“å¢ƒ
              'æå“': 11,
              'å¤©å“': 12,
              'ä»™å“': 13,

              // ç¥å¦™
              'ä¸€å­—ç¥å¦™': 14,
              'äºŒå­—ç¥å¦™': 15,
              'ä¸‰å­—ç¥å¦™': 16,
              'å†åŠ«': 17,
              'çœŸä¸€': 18,
              'ç‹¬ä»™': 19,

              // é£å‡æœŸ
              'ç¥å“': 20,
              'ä¼ªä»™å™¨': 21,
              'ä»™å™¨': 22,

              // å…¼å®¹é“ç—•
              'å‡¡å°˜æµéŸµä¹‹ç—•': 7,
              'çµè„‰å¥”æ¶Œä¹‹ç—•': 8,
              'å¤©è±¡æ˜¾åŒ–ä¹‹ç—•': 9,
              'æœ¬æºé“­åˆ»ä¹‹ç—•': 10
            };
            return tierOrder[tier] || 0; // æœªçŸ¥å“é˜¶æ’åœ¨æœ€å‰
          },

          // --- æ–°å¢ï¼šé€šç”¨å“é˜¶æ’åºå‡½æ•° ---
          sortByTier(items, getTierFn) {
            if (!Array.isArray(items)) return items;
            
            return [...items].sort((a, b) => {
              const tierA = getTierFn(a);
              const tierB = getTierFn(b);
              const orderA = this.getTierOrder(tierA);
              const orderB = this.getTierOrder(tierB);
              
              // æŒ‰ getTierOrder ä¸­å®šä¹‰çš„å“é˜¶é¡ºåºä»é«˜åˆ°ä½è¿›è¡Œç¨³å®šæ’åºã€‚
              if (orderA === orderB) {
                return 0;
              }
              return orderB - orderA;
            });
          },

          // --- ä½“ç³»åˆ†ç¦»: å¢ƒç•ŒæŸ“è‰²ç³»ç»Ÿ ---
          getJingJieStyle(jingjie) {
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const baseStyle = 'font-style: italic;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              
              const styles = {
                  'ç»ƒæ°”': 'color: #B0C4DE;', // LightSteelBlue
                  'ç­‘åŸº': 'color: #66CDAA;', // MediumAquamarine
                  'æ´ç„': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`, // åŸå…ƒå©´é¢œè‰²
                  'åˆé“': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation};`,
                  'é£å‡': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation};`
              };
              return (styles[jingjie] || 'color: #e0dcd1;') + baseStyle;
          },

          // --- ä½“ç³»åˆ†ç¦»: å“é˜¶æŸ“è‰²ç³»ç»Ÿ ---
          getItemTierStyle(tier) {
              const animatedStyle = 'background-size: 200% auto; -webkit-background-clip: text; background-clip: text; color: transparent; font-weight: bold;';
              const baseStyle = 'font-style: italic;';
              const gradientAnimation = 'god-tier-animation 5s linear infinite';
              const fluorescentAnimation = 'breathing-glow 4s ease-in-out infinite';

              const styles = {
                // ç»ƒæ°”æœŸå“é˜¶
                'å‡¡å“': 'color: #FFFFFF;',
                'ç„å“': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'é“å“': `background: linear-gradient(90deg, #FFD700, #FFFFFF, #FFD700, #FFFFFF, #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                // ç­‘åŸºæœŸå“é˜¶
                'äººé˜¶': 'color: #66CDAA;',
                'åœ°é˜¶': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©é˜¶': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                // æ´ç„å¢ƒå“é˜¶
                'å‡¡å°˜': 'color: #66CDAA;',
                'çµè„‰': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©è±¡': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                'æœ¬æº': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                
                // æ´å¤©é“ç—•å…¼å®¹
                'å‡¡å°˜æµéŸµä¹‹ç—•': 'color: #66CDAA;',
                'çµè„‰å¥”æ¶Œä¹‹ç—•': `background: linear-gradient(90deg, #DA70D6, #BA55D3, #9932CC, #BA55D3, #DA70D6); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©è±¡æ˜¾åŒ–ä¹‹ç—•': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                'æœ¬æºé“­åˆ»ä¹‹ç—•': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,

                // åˆé“å¢ƒå“é˜¶
                'æå“': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation};`,
                'å¤©å“': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation};`,
                'ä»™å“': `background: linear-gradient(90deg, #FF416C, #FF4B2B, #FF6B6B, #FF4B2B, #FF416C); ${animatedStyle} animation: ${gradientAnimation};`,
                // é£å‡æœŸå“é˜¶
                'ç¥å“': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle} animation: ${gradientAnimation};`,
                'ä¼ªä»™å™¨': `background: linear-gradient(90deg, #cccccc, #FFFACD, #ffffff, #FFFACD, #bbbbbb, #FFFACD, #cccccc); ${animatedStyle} animation: ${gradientAnimation};`,
                'ä»™å™¨': `background: linear-gradient(90deg, #FFFACD, #206864, #ffffff, #206864, #FFFACD); ${animatedStyle} animation: ${gradientAnimation};`,
                // ç¥å¦™/æœ¬å‘½ç¥å¦™å“é˜¶
                'ä¸€å­—ç¥å¦™': `background: linear-gradient(90deg, #C71585, #FF1493, #DB7093, #FF1493, #C71585); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'äºŒå­—ç¥å¦™': `background: linear-gradient(90deg, #DC143C, #FF4500, #B22222, #FF4500, #DC143C); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'ä¸‰å­—ç¥å¦™': `background: linear-gradient(90deg, #cccccc, #ffffff, #bbbbbb, #ffffff, #cccccc); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'å†åŠ«': `background: linear-gradient(90deg, #6A1B9A, #FFFFFF, #6A1B9A); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'çœŸä¸€': `background: linear-gradient(90deg, #FFD700, rgba(255, 255, 255, 0.8), #FFD700); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
                'ç‹¬ä»™': `background: linear-gradient(135deg, #a8ff78, #78ffd6, #a8ff78); ${animatedStyle} animation: ${gradientAnimation}, ${fluorescentAnimation};`,
              };

              return (styles[tier] || 'color: #e0dcd1;') + baseStyle;
          },
          updateTalentAndLinggen(data) {
            const container = document.getElementById('talent-linggen-list');
            if (!container) return;
            container.innerHTML = '';

            let html = '';

            // å˜é‡é€‚é…: å¤„ç†å¯¹è±¡å½¢å¼çš„çµæ ¹åˆ—è¡¨
            const linggenList = this.SafeGetValue(data, 'çµæ ¹åˆ—è¡¨', {});
            const linggenEntries = Object.entries(linggenList).filter(([name]) => name !== '$meta');

            if (linggenEntries.length > 0) {
              const sortedLinggen = this.sortByTier(linggenEntries, ([, linggen]) =>
                this.SafeGetValue(linggen, 'tier', 'å‡¡å“')
              );

              sortedLinggen.forEach(([name, linggen]) => {
                const tier = this.SafeGetValue(linggen, 'tier', 'å‡¡å“');
                const description = this.SafeGetValue(linggen, 'description', 'æ— æè¿°');
                const tierStyle = this.getItemTierStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(linggen);

                html += `
                     <details class="details-container" style="margin-top: 10px;">
                         <summary>
                             <span class="attribute-name">çµæ ¹</span>
                             <span class="attribute-value" style="${tierStyle}">ã€${tier}ã€‘ ${name}</span>
                         </summary>
                         <div class="details-content">
                             <p>${description}</p>
                             ${itemDetailsHtml ? `<div class="item-details" style="border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 10px; margin-top: 10px;">${itemDetailsHtml}</div>` : ''}
                         </div>
                     </details>
                 `;
              });
            } else {
                 html += `
                   <div class="attribute-item">
                       <span class="attribute-name">çµæ ¹</span>
                       <span class="attribute-value">æœªè§‰é†’</span>
                   </div>
               `;
            }

            // å˜é‡é€‚é…: å¤„ç†å¯¹è±¡å½¢å¼çš„å¤©èµ‹åˆ—è¡¨
            const tianfuList = this.SafeGetValue(data, 'å¤©èµ‹åˆ—è¡¨', {});
            const tianfuEntries = Object.entries(tianfuList).filter(([name]) => name !== '$meta');
            
            if (tianfuEntries.length > 0) {
              const sortedTianfu = this.sortByTier(tianfuEntries, ([, tianfu]) =>
                this.SafeGetValue(tianfu, 'tier', 'å‡¡å“')
              );

              sortedTianfu.forEach(([name, tianfu]) => {
                const tier = this.SafeGetValue(tianfu, 'tier', 'å‡¡å“');
                const description = this.SafeGetValue(tianfu, 'description', 'æ— æè¿°');
                const tierStyle = this.getItemTierStyle(tier);
                const itemDetailsHtml = this.renderItemDetailsForInventory(tianfu);

                html += `
                         <details class="details-container" style="margin-top: 10px;">
                             <summary>
                                 <span class="attribute-name">å¤©èµ‹</span>
                                 <span class="attribute-value" style="${tierStyle}">ã€${tier}ã€‘ ${name}</span>
                             </summary>
                             <div class="details-content">
                                 <p>${description}</p>
                                 ${itemDetailsHtml ? `<div class="item-details" style="border-top: 1px solid rgba(201, 170, 113, 0.2); padding-top: 10px; margin-top: 10px;">${itemDetailsHtml}</div>` : ''}
                             </div>
                         </details>
                     `;
              });
            } else {
              html += `
                   <div class="attribute-item">
                       <span class="attribute-name">å¤©èµ‹</span>
                       <span class="attribute-value">æœªè§‰é†’</span>
                   </div>
               `;
            }

            container.innerHTML = html;
          },

          renderInventory(stat_data) {
            if (!stat_data || Object.keys(stat_data).length === 0) {
              return '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">èƒŒåŒ…æ•°æ®ä¸ºç©ºã€‚</p>';
            }

            const categories = [
              { title: 'åŠŸæ³•', key: 'åŠŸæ³•åˆ—è¡¨', equipable: true },
              { title: 'æ­¦å™¨', key: 'æ­¦å™¨åˆ—è¡¨', equipable: true },
              { title: 'é˜²å…·', key: 'é˜²å…·åˆ—è¡¨', equipable: true },
              { title: 'é¥°å“', key: 'é¥°å“åˆ—è¡¨', equipable: true },
              { title: 'æ³•å®', key: 'æ³•å®åˆ—è¡¨', equipable: true },
              { title: 'ä¸¹è¯', key: 'ä¸¹è¯åˆ—è¡¨', equipable: false },
              { title: 'æ‚ç‰©', key: 'å…¶ä»–åˆ—è¡¨', equipable: false },
            ];

            let html = '';

            categories.forEach(cat => {
              // å˜é‡é€‚é…: rawItems ç°åœ¨æ˜¯å¯¹è±¡
              const rawItems = this.SafeGetValue(stat_data, cat.key, {});
              
              html += `<details class="inventory-category" open>`;
              html += `<summary class="inventory-category-title">${cat.title}</summary>`;

              const itemEntries = Object.entries(rawItems).filter(([name]) => name !== '$meta');

              if (itemEntries.length > 0) {
                html += '<div class="inventory-item-list">';
                
                const sortedItems = this.sortByTier(itemEntries, ([, item]) =>
                  this.SafeGetValue(item, 'tier', 'å‡¡å“')
                );

                sortedItems.forEach(([name, item]) => {
                  try {
                    const itemWithFixName = { ...item, name };
                    const itemJson = JSON.stringify(itemWithFixName).replace(/'/g, "'");
                    
                    const tier = this.SafeGetValue(item, 'tier', 'æ— ');
                    const hasQuantity = item.hasOwnProperty('quantity');
                    const quantity = parseInt(this.SafeGetValue(item, 'quantity', 1), 10);
                    const description = this.SafeGetValue(
                      item,
                      'description',
                      this.SafeGetValue(item, 'effect', 'æ— æè¿°'),
                    );

                    const pendingUses = this.pendingActions
                      .filter(action => action.action === 'use' && action.itemName === name)
                      .reduce((total, action) => total + action.quantity, 0);
                    const pendingDiscards = this.pendingActions
                      .filter(action => action.action === 'discard' && action.itemName === name)
                      .reduce((total, action) => total + action.quantity, 0);
                    const displayQuantity = quantity - pendingUses - pendingDiscards;

                    if (hasQuantity && displayQuantity <= 0) {
                      return;
                    }
                    if (!hasQuantity && pendingDiscards > 0) {
                      return;
                    }

                    const tierStyle = this.getItemTierStyle(tier);
                    const tierDisplay =
                      tier !== 'æ— ' ? `<span style="${tierStyle} margin-right: 15px;">å“é˜¶: ${tier}</span>` : '';
                    const quantityDisplay = hasQuantity ? `<span class="item-quantity">æ•°é‡: ${displayQuantity}</span>` : '';

                    const isEquipped = Object.values(this.equippedItems).some(equippedItem => equippedItem && equippedItem.name === name);
                    let actionButton = '';

                    if (cat.title === 'åŠŸæ³•') {
                      const isEquippedAsMain =
                        this.equippedItems.zhuxiuGongfa && this.equippedItems.zhuxiuGongfa.name === name;
                      const isEquippedAsAux =
                        this.equippedItems.fuxiuXinfa && this.equippedItems.fuxiuXinfa.name === name;

                      if (isEquippedAsMain) {
                        actionButton = `
                                <button class="item-unequip-btn" data-slot-id="equip-zhuxiuGongfa" style="margin-left: 5px;">å¸ä¸‹</button>
                                <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>è¾…ä¿®</button>
                            `;
                      } else if (isEquippedAsAux) {
                        actionButton = `
                                <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px; opacity: 0.5; cursor: not-allowed;" disabled>ä¸»ä¿®</button>
                                <button class="item-unequip-btn" data-slot-id="equip-fuxiuXinfa" style="margin-left: 5px;">å¸ä¸‹</button>
                            `;
                      } else {
                        actionButton = `
                                <button class="item-equip-btn" data-equip-type="zhuxiu" style="margin-left: 5px;">ä¸»ä¿®</button>
                                <button class="item-equip-btn" data-equip-type="fuxiu" style="margin-left: 5px;">è¾…ä¿®</button>
                            `;
                      }
                    } else if (cat.equipable) {
                      if (isEquipped) {
                        const slotKey = Object.keys(this.equippedItems).find(
                          key => this.equippedItems[key] && this.equippedItems[key].name === name,
                        );
                        actionButton = `<button class="item-unequip-btn" data-slot-id="equip-${slotKey}">å¸ä¸‹</button>`;
                      } else {
                        actionButton = `<button class="item-equip-btn">è£…å¤‡</button>`;
                      }
                    } else if (cat.title === 'ä¸¹è¯' || cat.title === 'æ‚ç‰©') {
                      if (displayQuantity <= 0) {
                          actionButton = `<button class="item-use-btn" disabled>å·²ç”¨å®Œ</button>`;
                      } else {
                          actionButton = `<button class="item-use-btn">ä½¿ç”¨</button>`;
                      }
                    }

                    if (cat.title === 'ä¸¹è¯' || cat.title === 'æ‚ç‰©') {
                      actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">ä¸¢å¼ƒ</button>`;
                    } else {
                      actionButton += `<button class="item-discard-btn" style="margin-left: 5px; background: #8b0000; border-color: #ff6b6b;">ä¸¢å¼ƒ</button>`;
                    }

                    let itemDetailsHtml = this.renderItemDetailsForInventory(item);

                    html += `
                                    <div class="inventory-item" data-item-details='${itemJson}' data-category='${cat.title}'>
                                        <div class="item-name" style="${tierStyle}">${name}</div>
                                        <div class="item-header">
                                            <div class="item-meta">
                                                ${tierDisplay}
                                                ${quantityDisplay}
                                            </div>
                                            <div class="item-actions">
                                                ${actionButton}
                                            </div>
                                        </div>
                                        <div class="item-description">${description}</div>
                                        ${itemDetailsHtml ? `<div class="item-details">${itemDetailsHtml}</div>` : ''}
                                    </div>
                                `;
                  } catch (e) {
                    console.error('è§£æèƒŒåŒ…ç‰©å“å¤±è´¥:', item, e);
                    html += `<div class="inventory-item"><p class="item-description">ç‰©å“æ•°æ®æ ¼å¼é”™è¯¯</p></div>`;
                  }
                });
                html += '</div>';
              } else {
                html += '<div class="inventory-item-list"><p class="empty-category-text">ç©ºç©ºå¦‚ä¹Ÿ</p></div>';
              }
              html += `</details>`;
            });

            return html;
          },

          // --- Tooltip and Equip Logic (é‡æ„å) ---
          renderTooltipContent(item) {
            // æ ¹æ®æœ€æ–°çš„å˜é‡ç»“æ„è§£æ
            const tierStyle = this.getItemTierStyle(this.SafeGetValue(item, 'tier'));
            const level = this.SafeGetValue(item, 'level', '');
            const tierDisplay = level
              ? `${this.SafeGetValue(item, 'tier', 'å‡¡å“')} ${level}`
              : this.SafeGetValue(item, 'tier', 'å‡¡å“');

            let attributesHtml = '';
            const attributes = item.attributes_bonus; // ç›´æ¥ä½¿ç”¨æ–°key
            if (typeof attributes === 'object' && attributes !== null && Object.keys(attributes).length > 0) {
              attributesHtml += `<div class="tooltip-section-title">å›ºå®šåŠ æˆ</div>`;
              for (const [key, value] of Object.entries(attributes)) {
                attributesHtml += `<p><strong>${key}:</strong> ${value > 0 ? '+' : ''}${value}</p>`;
              }
            }

            const percentBonuses = item['ç™¾åˆ†æ¯”åŠ æˆ'];
            if (typeof percentBonuses === 'object' && percentBonuses !== null && Object.keys(percentBonuses).length > 0) {
              attributesHtml += `<div class="tooltip-section-title" style="margin-top: 5px;">ç™¾åˆ†æ¯”åŠ æˆ</div>`;
              for (const [key, value] of Object.entries(percentBonuses)) {
                 attributesHtml += `<p><strong>${key}:</strong> +${value}</p>`;
              }
            }

            let effectsHtml = '';
            const effects = item.special_effects; // ç›´æ¥ä½¿ç”¨æ–°key
            if (Array.isArray(effects) && effects.length > 0) {
              effectsHtml += `<div class="tooltip-section-title">ç‰¹æ®Šè¯æ¡</div>`;
              effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>${eff}</p>`).join('');
            }

            return `
                    <div class="tooltip-title" style="${tierStyle}">${this.SafeGetValue(item, 'name')}</div>
                    <p><strong>å“é˜¶:</strong> ${tierDisplay}</p>
                    <p><i>${this.SafeGetValue(item, 'description', 'æ— æè¿°')}</i></p>
                    ${
                      attributesHtml
                        ? `<div class="tooltip-section tooltip-attributes">${attributesHtml}</div>`
                        : ''
                    }
                    ${effectsHtml ? `<div class="tooltip-section">${effectsHtml}</div>` : ''}
                `;
          },

          showEquipmentTooltip(element, event) {
            const tooltip = document.getElementById('equipment-tooltip');
            const itemDataString = element.dataset.itemDetails;
            if (!tooltip || !itemDataString) return;

            try {
              const item = JSON.parse(itemDataString.replace(/'/g, "'"));
              tooltip.innerHTML = this.renderTooltipContent(item);
              tooltip.style.display = 'block';

              // **å…³é”®ä¿®å¤**: è°ƒæ•´Tooltipä½ç½®ä»¥é˜²æ­¢è¶…å‡ºè§†å£
              const tooltipRect = tooltip.getBoundingClientRect();
              const viewportWidth = window.innerWidth;
              const viewportHeight = window.innerHeight;

              let left = event.pageX + 15;
              let top = event.pageY + 15;

              // å¦‚æœTooltipè¶…å‡ºå³è¾¹ç•Œï¼Œåˆ™æ˜¾ç¤ºåœ¨é¼ æ ‡å·¦ä¾§
              if (left + tooltipRect.width > viewportWidth) {
                left = event.pageX - tooltipRect.width - 15;
              }

              // å¦‚æœTooltipè¶…å‡ºä¸‹è¾¹ç•Œï¼Œåˆ™æ˜¾ç¤ºåœ¨é¼ æ ‡ä¸Šä¾§
              if (top + tooltipRect.height > viewportHeight) {
                top = event.pageY - tooltipRect.height - 15;
              }

              tooltip.style.left = `${left}px`;
              tooltip.style.top = `${top}px`;
            } catch (e) {
              console.error('è§£æè£…å¤‡Tooltipæ•°æ®å¤±è´¥:', e);
            }
          },

          hideEquipmentTooltip() {
            const tooltip = document.getElementById('equipment-tooltip');
            if (tooltip) tooltip.style.display = 'none';
          },

          renderItemDetailsForInventory(item) {
            let attributesHtml = '';
            const attributes = item.attributes_bonus;
            if (typeof attributes === 'object' && attributes !== null && Object.keys(attributes).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">å›ºå®šåŠ æˆ</div>';
              for (const [key, value] of Object.entries(attributes)) {
                attributesHtml += `<p><strong>${key}:</strong> ${value > 0 ? '+' : ''}${value}</p>`;
              }
            }

            const percentBonuses = item['ç™¾åˆ†æ¯”åŠ æˆ'];
            if (typeof percentBonuses === 'object' && percentBonuses !== null && Object.keys(percentBonuses).length > 0) {
              attributesHtml += '<div class="tooltip-section-title" style="margin-top: 5px;">ç™¾åˆ†æ¯”åŠ æˆ</div>';
              for (const [key, value] of Object.entries(percentBonuses)) {
                 attributesHtml += `<p><strong>${key}:</strong> +${value}</p>`;
              }
            }

            let effectsHtml = '';
            const effects = item.special_effects;

            if (effects) {
                effectsHtml += `<div class="tooltip-section-title" style="margin-top: 5px;">ç‰¹æ®Šè¯æ¡</div>`;
                if (typeof effects === 'object' && !Array.isArray(effects) && effects !== null) {
                    for (const [key, value] of Object.entries(effects)) {
                        if (key === '$meta') continue;
                        effectsHtml += `<p><strong>${key}:</strong> ${value}</p>`;
                    }
                } else if (Array.isArray(effects)) {
                    effectsHtml += effects.filter(eff => eff !== '$__META_EXTENSIBLE__$').map(eff => `<p>${eff}</p>`).join('');
                } else if (typeof effects === 'string' && effects.trim() !== '') {
                    effectsHtml += effects.split('\n').map(e => e.trim()).filter(e => e).map(eff => `<p>${eff}</p>`).join('');
                }
            }

            return `${attributesHtml}${effectsHtml}`;
          },

          equipItem(item, category, buttonElement, equipType = null) {
            const itemName = this.SafeGetValue(item, 'name');
            if (!itemName || itemName === 'N/A') {
              this.showTemporaryMessage('ç‰©å“æ— åç§°ï¼Œæ— æ³•è£…å¤‡ã€‚');
              return;
            }
            
            // Bugä¿®å¤ï¼šæ£€æŸ¥åŠŸæ³•æ˜¯å¦å·²è¢«è£…å¤‡åœ¨å¦ä¸€ä¸ªæ§½ä½
            if (category === 'åŠŸæ³•') {
              const isEquippedAsMain = this.equippedItems.zhuxiuGongfa && this.equippedItems.zhuxiuGongfa.name === itemName;
              const isEquippedAsAux = this.equippedItems.fuxiuXinfa && this.equippedItems.fuxiuXinfa.name === itemName;

              if (
                (equipType === 'fuxiuXinfa' && isEquippedAsMain) ||
                (equipType === 'zhuxiuGongfa' && isEquippedAsAux)
              ) {
                this.showTemporaryMessage('è¯¥åŠŸæ³•å·²è¢«è£…å¤‡åœ¨å¦ä¸€æ§½ä½ã€‚');
                return;
              }
            }

            const categoryMap = { æ­¦å™¨: 'wuqi', é˜²å…·: 'fangju', é¥°å“: 'shipin', æ³•å®: 'fabao1', åŠŸæ³•: equipType };
            const slotKey = categoryMap[category];

            if (!slotKey) {
              this.showTemporaryMessage('é”™è¯¯çš„è£…å¤‡åˆ†ç±»æˆ–ç±»å‹ã€‚');
              return;
            }
            
            // **å…³é”®ä¿®å¤**: æ£€æŸ¥ç‰©å“æ˜¯å¦å·²è£…å¤‡åœ¨å…¶ä»–æ§½ä½ï¼Œå¦‚æœæ˜¯ï¼Œåˆ™å…ˆå¸è½½
            const currentlyEquippedSlot = Object.keys(this.equippedItems).find(
              key => this.equippedItems[key] && this.equippedItems[key].name === itemName,
            );
            if (currentlyEquippedSlot && currentlyEquippedSlot !== slotKey) {
              const oldSlotElement = document.getElementById(`equip-${currentlyEquippedSlot}`);
              if (oldSlotElement) {
                this.unequipItem(`equip-${currentlyEquippedSlot}`, oldSlotElement, false); // é™é»˜å¸è½½
              }
            }

            const slotElement = document.getElementById(`equip-${slotKey}`);
            if (!slotElement) return;

            // å¦‚æœè¯¥æ§½ä½å·²æœ‰è£…å¤‡ï¼Œå…ˆæ‰§è¡Œå¸è½½æ“ä½œ
            const oldItem = this.equippedItems[slotKey];
            if (oldItem) {
              this.unequipItem(`equip-${slotKey}`, slotElement, false);
            }

            // æ›´æ–°å‰ç«¯çŠ¶æ€å’ŒUIï¼ˆä¹è§‚æ›´æ–°ï¼‰
            this.equippedItems[slotKey] = item; // **é€»è¾‘ä¿®æ­£**: å­˜å‚¨å®Œæ•´å¯¹è±¡
            const tier = this.SafeGetValue(item, 'tier', 'å‡¡å“');
            const tierStyle = this.getItemTierStyle(tier);
            slotElement.textContent = this.SafeGetValue(item, 'name');
            slotElement.setAttribute('style', tierStyle);
            slotElement.classList.add('equipped');
            slotElement.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");

            // æ›´æ–°èƒŒåŒ…UIï¼Œä½¿å…¶èƒ½åæ˜ æœ€æ–°çŠ¶æ€
            if (buttonElement.closest('#inventory-modal')) {
              this.showInventory();
            }

            // æ·»åŠ åˆ°æŒ‡ä»¤é˜Ÿåˆ—ï¼ˆä¼˜åŒ–ï¼šå…ˆç§»é™¤æ—§æŒ‡ä»¤ï¼Œå†æ·»åŠ æ–°æŒ‡ä»¤ï¼‰
            const defaultTextMap = {
              wuqi: 'æ­¦å™¨',
              fangju: 'é˜²å…·',
              shipin: 'é¥°å“',
              fabao1: 'æ³•å®',
              zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
              fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
            };
            const slotFriendlyName = defaultTextMap[slotKey] || category;
            this.pendingActions = this.pendingActions.filter(action => action.itemName !== itemName);
            this.pendingActions.push({
              action: 'equip',
              itemName: itemName,
              category: slotFriendlyName,
            });

            this.showTemporaryMessage(`å·²è£…å¤‡ ${this.SafeGetValue(item, 'name')}`);
            this.updateDisplayedAttributes();
            this.saveEquipmentState(); // ä¿å­˜çŠ¶æ€
            this.savePendingActions(); // ä¿å­˜æŒ‡ä»¤çŠ¶æ€
          },

          unequipItem(slotId, slotElement, showMessage = true, refreshInventoryUI = true) {
            const slotKey = slotId.replace('equip-', '');
            const defaultTextMap = {
              wuqi: 'æ­¦å™¨',
              fangju: 'é˜²å…·',
              shipin: 'é¥°å“',
              fabao1: 'æ³•å®',
              zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
              fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
            };

            const itemDataString = slotElement.dataset.itemDetails;
            if (!itemDataString) return; // å¦‚æœæ²¡æœ‰ç‰©å“ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ

            let itemName = 'ä¸€ä»¶è£…å¤‡';
            try {
              const item = JSON.parse(itemDataString.replace(/'/g, "'"));
              itemName = this.SafeGetValue(item, 'name');
            } catch (e) {
              console.error('å¸è½½æ—¶è§£æç‰©å“æ•°æ®å¤±è´¥', e);
            }

            // æ¸…ç†å‰ç«¯çŠ¶æ€å’ŒUI
            this.equippedItems[slotKey] = null;
            slotElement.textContent = defaultTextMap[slotKey] || 'ç©º';
            slotElement.classList.remove('equipped');
            slotElement.removeAttribute('style');
            delete slotElement.dataset.itemDetails;

            // **å…³é”®ä¿®å¤**: ä¸å†è¿›è¡Œå¤æ‚çš„å±€éƒ¨DOMæ›´æ–°ï¼Œè€Œæ˜¯ç›´æ¥é‡æ–°æ¸²æŸ“æ•´ä¸ªèƒŒåŒ…ä»¥ç¡®ä¿UIåŒæ­¥
            if (refreshInventoryUI) {
              this.showInventory();
            }

            // æ·»åŠ åˆ°æŒ‡ä»¤é˜Ÿåˆ—ï¼ˆä¼˜åŒ–ï¼šå…ˆç§»é™¤æ—§æŒ‡ä»¤ï¼Œå†æ·»åŠ æ–°æŒ‡ä»¤ï¼‰
            this.pendingActions = this.pendingActions.filter(action => action.itemName !== itemName);
            this.pendingActions.push({
              action: 'unequip',
              itemName: itemName,
              category: defaultTextMap[slotKey],
            });

            if (showMessage) {
              this.showTemporaryMessage(`å·²å¸ä¸‹ ${itemName}`);
            }
            this.updateDisplayedAttributes();
            this.saveEquipmentState(); // ä¿å­˜çŠ¶æ€
            this.savePendingActions(); // ä¿å­˜æŒ‡ä»¤çŠ¶æ€
            // æ³¨æ„ï¼šshowInventory() å·²ç»åŒ…å«äº†å…³é—­æ¨¡æ€æ¡†å†æ‰“å¼€çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥UIä¼šåˆ·æ–°
          },

          loadEquipmentFromMVU(data) {
            const equipmentMap = {
              æ­¦å™¨: 'wuqi',
              ä¸»ä¿®åŠŸæ³•: 'zhuxiuGongfa',
              è¾…ä¿®å¿ƒæ³•: 'fuxiuXinfa',
              é˜²å…·: 'fangju',
              é¥°å“: 'shipin',
              æ³•å®æ 1: 'fabao1',
            };
            const defaultTextMap = {
              wuqi: 'æ­¦å™¨',
              fangju: 'é˜²å…·',
              shipin: 'é¥°å“',
              fabao1: 'æ³•å®',
              zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
              fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
            };

            for (const [mvuKey, slotKey] of Object.entries(equipmentMap)) {
              const slot = document.getElementById(`equip-${slotKey}`);
              if (!slot) continue;

              // mvuä¸­çš„è£…å¤‡æ•°æ®é€šå¸¸æ˜¯ [ { item_object } ] çš„å½¢å¼
              // **å±€éƒ¨ä¿®å¤**: ç›´æ¥ä½¿ç”¨ _.get è·å–è£…å¤‡æ•°ç»„ï¼Œé¿å… SafeGetValue å°†å…¶é”™è¯¯åœ°è½¬ä¸ºå­—ç¬¦ä¸²
              const itemArray = _.get(data, mvuKey, null);
              const item = Array.isArray(itemArray) && itemArray.length > 0 ? itemArray[0] : null;

              if (item && typeof item === 'object') {
                const tier = this.SafeGetValue(item, 'tier', 'å‡¡å“');
                const tierStyle = this.getItemTierStyle(tier);
                // **é€»è¾‘ä¿®æ­£**: æ­¤å¤„ä¸å†ä¸»åŠ¨ä¿®æ”¹ this.equippedItems
                // this.equippedItems çš„çŠ¶æ€ç”± localStorage å’Œ equip/unequip åŠ¨ä½œç®¡ç†
                // this.equippedItems[slotKey] = item;
                slot.textContent = this.SafeGetValue(item, 'name');
                slot.setAttribute('style', tierStyle);
                slot.classList.add('equipped');
                slot.dataset.itemDetails = JSON.stringify(item).replace(/'/g, "'");
              } else {
                // this.equippedItems[slotKey] = null; // **å…³é”®ä¿®å¤**: æ­¤å‡½æ•°ä¸åº”ä¿®æ”¹æ ¸å¿ƒçŠ¶æ€ï¼Œåªæ¸²æŸ“ä»mvuå¾—åˆ°çš„æ•°æ®
                slot.textContent = defaultTextMap[slotKey];
                slot.classList.remove('equipped');
                slot.removeAttribute('style');
                delete slot.dataset.itemDetails;
              }
            }
          },

          updateDisplayedAttributes() {
            // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
            // V2 Refactor: Optimistic update based on MVU max values + equipment bonuses only.
            if (!this.currentMvuState || !this.currentMvuState.stat_data) {
              console.warn('æ— æ³•æ›´æ–°å±æ€§ï¼šmvuçŠ¶æ€ä¸å¯ç”¨ï¼Œä½¿ç”¨é»˜è®¤æ˜¾ç¤ºã€‚');
              // å½“æ•°æ®ä¸å¯ç”¨æ—¶ï¼Œæ˜¾ç¤ºé»˜è®¤çš„"..."è€Œä¸æ˜¯"0 / 0"
              document.getElementById('attr-xueliang').innerText = '...';
              document.getElementById('attr-fali').innerText = '...';
              document.getElementById('attr-shenhai').innerText = '...';
              document.getElementById('attr-daoxin').innerText = '...';
              document.getElementById('attr-kongsu').innerText = '...';
              document.getElementById('attr-qiyun').innerText = '...';
              document.getElementById('attr-wuxing').innerText = '...';
              document.getElementById('attr-meili').innerText = '...';
              return;
            }

            const stat_data = this.currentMvuState.stat_data;
            
            // 1. åŸºç¡€æ˜¾ç¤ºï¼šç›´æ¥ä½¿ç”¨mvuå˜é‡ä¸­çš„ä¸Šé™å±æ€§ä½œä¸ºåŸºç¡€å€¼
            // ä¿®å¤ï¼šä½¿ç”¨æ›´åˆç†çš„é»˜è®¤å€¼ï¼Œé¿å…æ˜¾ç¤º0/0
            const mvuMaxAttrs = {
              fali: parseInt(this.SafeGetValue(stat_data, 'æ³•åŠ›', 100), 10) || 100,
              shenhai: parseInt(this.SafeGetValue(stat_data, 'ç¥æµ·', 50), 10) || 50,
              daoxin: parseInt(this.SafeGetValue(stat_data, 'é“å¿ƒ', 10), 10) || 10,
              kongsu: parseInt(this.SafeGetValue(stat_data, 'ç©ºé€Ÿ', 5), 10) || 5,
              qiyun: parseInt(this.SafeGetValue(stat_data, 'æ°”è¿', 10), 10) || 10,
              wuxing: parseInt(this.SafeGetValue(stat_data, 'æ‚Ÿæ€§', 10), 10) || 10,
              meili: parseInt(this.SafeGetValue(stat_data, 'é­…åŠ›', 10), 10) || 10,
            };

            // 2. å‰ç«¯ä¹è§‚æ›´æ–°ï¼šåªè®¡ç®—æ–°è£…å¤‡çš„æ­¦å™¨ç­‰ç‰©å“çš„åŠ æˆ
            const equipmentFlatBonuses = { fali: 0, shenhai: 0, daoxin: 0, kongsu: 0, qiyun: 0, wuxing: 0, meili: 0 };
            const equipmentPercentBonuses = { fali: 0, shenhai: 0, daoxin: 0, kongsu: 0, qiyun: 0, wuxing: 0, meili: 0 };
            const attributeMapping = { æ³•åŠ›: 'fali', ç¥æµ·: 'shenhai', é“å¿ƒ: 'daoxin', ç©ºé€Ÿ: 'kongsu', æ°”è¿: 'qiyun', æ‚Ÿæ€§: 'wuxing', é­…åŠ›: 'meili' };

            const processEquipmentBonuses = (item) => {
              if (!item || typeof item !== 'object') return;
              
              const flatBonuses = item.attributes_bonus;
              if (flatBonuses && typeof flatBonuses === 'object') {
                for (const [attrName, bonusValue] of Object.entries(flatBonuses)) {
                  const attrKey = attributeMapping[attrName];
                  if (attrKey) {
                    equipmentFlatBonuses[attrKey] += parseInt(bonusValue, 10) || 0;
                  }
                }
              }
              
              const percentBonuses = item['ç™¾åˆ†æ¯”åŠ æˆ'];
              if (percentBonuses && typeof percentBonuses === 'object') {
                 for (const [attrName, bonusValue] of Object.entries(percentBonuses)) {
                    const attrKey = attributeMapping[attrName];
                    if (attrKey) {
                        equipmentPercentBonuses[attrKey] += parseFloat(String(bonusValue).replace('%','')) / 100 || 0;
                    }
                }
              }
            };

            // åªéå† this.equippedItems
            Object.values(this.equippedItems).forEach(processEquipmentBonuses);

            // è®¡ç®—æœ€ç»ˆä¹è§‚æ›´æ–°åçš„ä¸Šé™
            const finalMaxAttrs = {
              fali: Math.floor((mvuMaxAttrs.fali + equipmentFlatBonuses.fali) * (1 + equipmentPercentBonuses.fali)),
              shenhai: Math.floor((mvuMaxAttrs.shenhai + equipmentFlatBonuses.shenhai) * (1 + equipmentPercentBonuses.shenhai)),
              daoxin: Math.floor((mvuMaxAttrs.daoxin + equipmentFlatBonuses.daoxin) * (1 + equipmentPercentBonuses.daoxin)),
              kongsu: Math.floor((mvuMaxAttrs.kongsu + equipmentFlatBonuses.kongsu) * (1 + equipmentPercentBonuses.kongsu)),
              qiyun: Math.floor((mvuMaxAttrs.qiyun + equipmentFlatBonuses.qiyun) * (1 + equipmentPercentBonuses.qiyun)),
              wuxing: Math.floor((mvuMaxAttrs.wuxing + equipmentFlatBonuses.wuxing) * (1 + equipmentPercentBonuses.wuxing)),
              meili: Math.floor((mvuMaxAttrs.meili + equipmentFlatBonuses.meili) * (1 + equipmentPercentBonuses.meili)),
            };
             // è¡€é‡ä¸Šé™æ ¹æ®æœ€ç»ˆå››ç»´è®¡ç®—
            finalMaxAttrs.xueliang = Math.floor((finalMaxAttrs.fali * 0.2) + (finalMaxAttrs.daoxin * 0.5) + (finalMaxAttrs.shenhai * 0.3) + (finalMaxAttrs.kongsu * 0.1));

            this.calculatedMaxAttributes = finalMaxAttrs; // ç¼“å­˜è®¡ç®—ç»“æœ

            // 3. å»é™¤å½“å‰å€¼ä¸èƒ½è¶…å‡ºä¸Šé™çš„bugï¼Œç›´æ¥è¯»å–å˜é‡æ•°æ®
            // ä¿®å¤ï¼šä½¿ç”¨ä¸ä¸Šé™å±æ€§å¯¹åº”çš„é»˜è®¤å€¼ï¼Œç¡®ä¿å½“å‰å€¼ä¸ä¼šæ˜¾ç¤ºä¸º0
            const currentAttrs = {
                fali: parseInt(this.SafeGetValue(stat_data, 'å½“å‰æ³•åŠ›', mvuMaxAttrs.fali), 10) || mvuMaxAttrs.fali,
                shenhai: parseInt(this.SafeGetValue(stat_data, 'å½“å‰ç¥æµ·', mvuMaxAttrs.shenhai), 10) || mvuMaxAttrs.shenhai,
                daoxin: parseInt(this.SafeGetValue(stat_data, 'å½“å‰é“å¿ƒ', mvuMaxAttrs.daoxin), 10) || mvuMaxAttrs.daoxin,
                kongsu: parseInt(this.SafeGetValue(stat_data, 'å½“å‰ç©ºé€Ÿ', mvuMaxAttrs.kongsu), 10) || mvuMaxAttrs.kongsu,
                xueliang: parseInt(this.SafeGetValue(stat_data, 'å½“å‰è¡€é‡', finalMaxAttrs.xueliang), 10) || finalMaxAttrs.xueliang,
            };

            // 4. æ›´æ–°UI - ç›´æ¥æ˜¾ç¤ºæ•°å€¼ï¼Œå…è®¸è´Ÿå€¼å’Œä»»ä½•æ•°å€¼
            const updateAttr = (elementId, current, max) => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerText = `${current} / ${max}`;
                }
            };
             const updateSingleAttr = (elementId, value) => {
                const element = document.getElementById(elementId);
                if (element) {
                    element.innerText = value;
                }
            };

            updateAttr('attr-xueliang', currentAttrs.xueliang, finalMaxAttrs.xueliang);
            updateAttr('attr-fali', currentAttrs.fali, finalMaxAttrs.fali);
            updateAttr('attr-shenhai', currentAttrs.shenhai, finalMaxAttrs.shenhai);
            updateAttr('attr-daoxin', currentAttrs.daoxin, finalMaxAttrs.daoxin);
            updateAttr('attr-kongsu', currentAttrs.kongsu, finalMaxAttrs.kongsu);
            
            // æ°”è¿ã€æ‚Ÿæ€§ã€é­…åŠ›åªæ˜¾ç¤ºæœ€å¤§å€¼
            updateSingleAttr('attr-qiyun', finalMaxAttrs.qiyun);
            updateSingleAttr('attr-wuxing', finalMaxAttrs.wuxing);
            updateSingleAttr('attr-meili', finalMaxAttrs.meili);
            
            // å¹´é¾„ç›¸å…³å±æ€§å·²ä»ä¸»ç•Œé¢ç§»é™¤ï¼Œä»…åœ¨å½’å¢Ÿç³»ç»Ÿä¸­æ˜¾ç¤º
            
            // ä¿®ä¸ºè¿›åº¦ç›¸å…³å±æ€§æ›´æ–°
            const xiuxingjindu = this.SafeGetValue(stat_data, 'ä¿®ä¸ºè¿›åº¦', '0');
            const xiuxingpingjing = this.SafeGetValue(stat_data, 'ä¿®ä¸ºç“¶é¢ˆ', 'æ— ');
            const jingjieYingshe = this.SafeGetValue(stat_data, 'å¢ƒç•Œæ˜ å°„', '1');
            document.getElementById('attr-xiuxing-jindu').innerText = `${xiuxingjindu}%`;
            document.getElementById('attr-xiuxing-pingjing').innerText = xiuxingpingjing;
            document.getElementById('attr-jingjie-yingshe').innerText = jingjieYingshe;
            
            // æ›´æ–°ä¿®ä¸ºè¿›åº¦æ¡
            const progressBar = document.getElementById('progress-xiuxing');
            if (progressBar) {
              progressBar.style.width = `${xiuxingjindu}%`;
            }

            this.updateSpecialAttributes(stat_data);
          },

          updateSpecialAttributes(stat_data) {
            // ä¿®æ”¹ï¼šç›®æ ‡å®¹å™¨å˜ä¸ºä¿®ä¸ºè¯¦æƒ…åˆ—è¡¨
            const container = document.getElementById('xiuwei-details-list');
            // æ¸…ç©ºæ—§çš„ç‰¹æ®Šå±æ€§å†…å®¹ï¼Œä¿ç•™åŸæœ‰çš„å¢ƒç•Œã€è¿›åº¦ç­‰
            const oldSpecialAttrs = container.querySelectorAll('.details-container');
            oldSpecialAttrs.forEach(el => el.remove());

            const specialAttrs = {
              'çœŸæ°”': 'zhenqi',
              'ç­‘åŸºå¥‡ç‰©': 'zhujiqiwu',
              'æ´å¤©': 'dongtian',
              'ç¥å¦™': 'shenmiao',
              'æœ¬å‘½ç¥å¦™': 'benmingshenmiao'
            };

            // å¤„ç†ä»™çµä¹‹æ°”
            const xianlingzhiqi = this.SafeGetValue(stat_data, 'ä»™çµä¹‹æ°”', null);
            // ç¡®ä¿åœ¨å¤„ç†å…¶ä»–å±æ€§ *ä¹‹å* å†å¤„ç†ä»™çµä¹‹æ°”ï¼Œä»¥ä¿è¯å…¶åœ¨æœ€ä¸‹æ–¹
            const finalHtmlProcessing = () => {
              const existingEl = document.getElementById('xianlingzhiqi-dynamic-item');
              if(existingEl) existingEl.remove();

              if (xianlingzhiqi !== null && xianlingzhiqi > 0) {
                const detailsContainer = document.getElementById('xiuwei-details-list');
                if(detailsContainer){
                  const xianlingzhiqiHtml = `
                    <div class="attribute-item" id="xianlingzhiqi-dynamic-item">
                      <span class="attribute-name xianlingzhiqi-special">ä»™çµä¹‹æ°”</span>
                      <span id="attr-xianlingzhiqi" class="attribute-value xianlingzhiqi-special">${xianlingzhiqi}</span>
                    </div>
                  `;
                  detailsContainer.insertAdjacentHTML('beforeend', xianlingzhiqiHtml);
                }
              }
            };

            let finalHtml = '';
            for (const [name, idPrefix] of Object.entries(specialAttrs)) {
                const data = this.SafeGetValue(stat_data, name, null);
                if (!data || typeof data !== 'object') continue;

                const entries = Object.entries(data).filter(([key]) => key !== '$meta');
                if (entries.length === 0) continue;

                let sectionHtml = '';
                // ç»Ÿä¸€å¤„ç†æ‰€æœ‰ç‰¹æ®Šå±æ€§
                let itemsHtml = '';
                entries.forEach(([itemName, itemDetails]) => {
                        const tier = this.SafeGetValue(itemDetails, 'å“é˜¶', 'å‡¡å“');
                        const tierStyle = this.getItemTierStyle(tier);
                        const itemDetailsHtml = this.renderRecursiveDetails(itemDetails, ['å“é˜¶']);
                        itemsHtml += `
                           <details class="details-container">
                               <summary>
                                   <span class="attribute-name">${name}</span>
                                   <span class="attribute-value" style="${tierStyle}">${tier ? `ã€${tier}ã€‘ ` : ''}${itemName}</span>
                               </summary>
                               <div class="details-content">${itemDetailsHtml}</div>
                           </details>
                        `;
                    });
                    // ä¿®æ”¹ï¼šä¸å†åˆ›å»ºç‹¬ç«‹çš„sectionï¼Œç›´æ¥ä½¿ç”¨itemsHtml
                    if (itemsHtml) {
                        sectionHtml = itemsHtml;
                    }
                 if(sectionHtml) {
                    finalHtml += sectionHtml;
                }
            }
            // ä¿®æ”¹ï¼šä½¿ç”¨appendChildè¿½åŠ å†…å®¹ï¼Œè€Œä¸æ˜¯innerHTMLè¦†ç›–
            container.insertAdjacentHTML('beforeend', finalHtml);
            
            // æœ€åå¤„ç†ä»™çµä¹‹æ°”
            finalHtmlProcessing();
          },

          renderRecursiveDetails(obj, excludeKeys = []) {
            if (!obj || typeof obj !== 'object') return '';

            let mainContentHtml = '';
            let descriptionHtml = '';
            let citiaoHtml = '';
            let bonusHtml = '';
            let percentBonusHtml = '';
            let nestedCollectionHtml = '';
            let historyHtml = '';

            const tempObj = { ...obj };

            // æå–å¹¶åˆ†ç¦»å„ç±»æ•°æ®
            const description = tempObj['æè¿°'] || '';
            if(description) delete tempObj['æè¿°'];

            const citiaoData = tempObj['è¯æ¡'] || null;
            if(citiaoData) {
                citiaoHtml = this.renderCitiaoBlock(citiaoData);
                delete tempObj['è¯æ¡'];
            }
            
            const bonusData = tempObj['attributes_bonus'] || null;
            if(bonusData) {
                bonusHtml = this.renderBonusBlock('å›ºå®šåŠ æˆ', bonusData);
                delete tempObj['attributes_bonus'];
            }

            const percentBonusData = tempObj['ç™¾åˆ†æ¯”åŠ æˆ'] || null;
            if(percentBonusData) {
                percentBonusHtml = this.renderBonusBlock('ç™¾åˆ†æ¯”åŠ æˆ', percentBonusData, true);
                delete tempObj['ç™¾åˆ†æ¯”åŠ æˆ'];
            }
            
            const timeKeys = ['è·å–æ—¶é—´', 'å¼€è¾Ÿæ—¶é—´', 'å‡ç»ƒæ—¶é—´', 'ç‚¼å°±æ—¶é—´'];
            let timeStr = '';
            timeKeys.forEach(key => {
                if (tempObj[key]) {
                    timeStr = tempObj[key];
                    delete tempObj[key];
                }
            });
            let historyStr = tempObj['ç»å†'] || '';
            if(historyStr) delete tempObj['ç»å†'];

            if (timeStr || historyStr) {
                 let combinedGossip = '';
                if (timeStr) combinedGossip += timeStr;
                if (historyStr) combinedGossip += (timeStr ? 'ï¼Œ' : '') + historyStr;
                historyHtml = `
                    <details class="details-container">
                        <summary>
                            <span class="attribute-name">è·å–ç»å†</span>
                            <span class="attribute-value"></span>
                        </summary>
                        <div class="details-content"><p>${combinedGossip}</p></div>
                    </details>
                `;
            }

            // æ¸²æŸ“å‰©ä½™çš„åµŒå¥—é›†åˆ
            for (const [key, value] of Object.entries(tempObj)) {
                 if (key !== '$meta' && typeof value === 'object' && value !== null) {
                    nestedCollectionHtml += this.renderNestedCollection(key, value);
                 }
            }

            // ç»„è£…æœ€ç»ˆHTML
            if(description) mainContentHtml += `<p>${description}</p>`;
            if(citiaoHtml) mainContentHtml += `<div class="item-details">${citiaoHtml}</div>`;
            if(nestedCollectionHtml) mainContentHtml += nestedCollectionHtml;
            if(bonusHtml) mainContentHtml += bonusHtml;
            if(percentBonusHtml) mainContentHtml += percentBonusHtml;
            if(historyHtml) mainContentHtml += historyHtml;

            return mainContentHtml;
          },

          renderCitiaoBlock(citiaoObj) {
            if (!citiaoObj || typeof citiaoObj !== 'object') return '';
            let html = '<p><strong>è¯æ¡</strong></p>';
            for (const [name, description] of Object.entries(citiaoObj)) {
              if (name === '$meta') continue;
              html += `<p><span class="attribute-value">${name}</span>: ${description}</p>`;
            }
            return html;
          },

          renderBonusBlock(title, bonusObj, isPercentage = false) {
            if (!bonusObj || typeof bonusObj !== 'object') return '';
            let html = `<p><strong>${title}</strong></p>`;
            for (const [attr, value] of Object.entries(bonusObj)) {
              if (attr === '$meta') continue;
              const displayValue = isPercentage ? `${value}` : `+${value}`;
              html += `<p><strong style="color: white;">${attr}</strong>: ${displayValue}</p>`;
            }
            return html;
          },

          renderNestedCollection(collectionName, collectionObj) {
            if (!collectionObj || typeof collectionObj !== 'object') return '';
            let html = `<p><strong>${collectionName}</strong></p>`;
            for (const [itemName, itemData] of Object.entries(collectionObj)) {
              if (itemName === '$meta') continue;
              
              const tier = itemData.å“é˜¶ || '';
              const tierStyle = tier ? this.getItemTierStyle(tier) : '';
              const quantity = itemData.æ•°é‡ ? ` x${itemData.æ•°é‡}` : '';
              const subDetails = this.renderRecursiveDetails(itemData, ['å“é˜¶', 'æ•°é‡']);
              
              html += `
                <details class="details-container">
                  <summary>
                    <span class="attribute-name">${itemName}${quantity}</span>
                    <span class="attribute-value" ${tierStyle ? `style="${tierStyle}"` : ''}>${tier ? `ã€${tier}ã€‘` : ''}</span>
                  </summary>
                  <div class="details-content">
                    ${subDetails}
                  </div>
                </details>
              `;
            }
            return html;
          },

          // ä¸´æ—¶æ¶ˆæ¯æç¤º (v2 - æ”¯æŒç±»å‹å’Œé¢œè‰²)
          showTemporaryMessage(message, type = 'info', duration = 3000) {
              const existingMsg = document.querySelector('.temp-message-popup');
              if (existingMsg) existingMsg.remove();

              const colors = {
                  info: { bg: 'rgba(45, 27, 61, 0.9)', text: '#c9aa71' },
                  success: { bg: 'rgba(40, 167, 69, 0.9)', text: '#ffffff' },
                  warning: { bg: 'rgba(255, 193, 7, 0.9)', text: '#000000' },
                  error: { bg: 'rgba(220, 53, 69, 0.9)', text: '#ffffff' }
              };
              const selectedColor = colors[type] || colors.info;

              const msgElement = document.createElement('div');
              msgElement.className = 'temp-message-popup';
              msgElement.textContent = message;
              msgElement.style.cssText = `
                      position: absolute;
                      top: 20px;
                      left: 50%;
                      transform: translateX(-50%);
                      background: ${selectedColor.bg};
                      color: ${selectedColor.text};
                      padding: 10px 20px;
                      border-radius: 5px;
                      z-index: 2000;
                      font-size: 14px;
                      box-shadow: 0 2px 10px rgba(0,0,0,0.5);
                      text-align: center;
                      transition: opacity 0.5s ease-out;
                      max-width: 90%;
                  `;
              document.querySelector('.guixu-root-container').appendChild(msgElement);

              setTimeout(() => {
                  msgElement.style.opacity = '0';
                  setTimeout(() => msgElement.remove(), 500);
              }, duration - 500);
          },

          showCommandCenter() {
              this.openModal('command-center-modal');
              const body = document.querySelector('#command-center-modal .modal-body');
              if (!body) return;
              
              if (this.pendingActions.length === 0) {
                  body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æš‚æ— å¾…æ‰§è¡Œçš„æŒ‡ä»¤ã€‚</p>';
                  return;
              }
              
              let html = '<ul class="command-center-actions">';
              this.pendingActions.forEach(cmd => {
                  // æ ¸å¿ƒä¿®å¤ï¼šè°ƒç”¨æˆ‘ä»¬ç»Ÿä¸€çš„æ ¼å¼åŒ–å‡½æ•°
                  const actionText = this._formatActionText(cmd);
                  if (actionText) {
                      html += `<li class="command-center-action-item">${actionText}</li>`;
                  }
              });
              html += '</ul>';
              body.innerHTML = html;
          },

          clearPendingActions() {
              // æ ¸å¿ƒä¿®å¤ï¼šç§»é™¤æ‰€æœ‰çŠ¶æ€å›æ»šé€»è¾‘ï¼Œç°åœ¨åªéœ€æ¸…ç©ºæŒ‡ä»¤é˜Ÿåˆ—
              this.pendingActions = [];
              this.savePendingActions();
              this.showTemporaryMessage('æŒ‡ä»¤å·²æ¸…ç©º');

              // åˆ·æ–°æ‰€æœ‰å¯èƒ½æ‰“å¼€çš„ç›¸å…³ç•Œé¢
              if (document.getElementById('command-center-modal').style.display === 'flex') {
                  this.showCommandCenter();
              }
              if (document.getElementById('gacha-settings-popup').style.display === 'flex') {
                  this._renderGachaSettingsTab('command_center');
              }
              if (document.getElementById('gacha-gallery-popup').style.display === 'flex') {
                  this.showGachaGalleryPopup();
              }
          },

          refreshLocalStorage() {
            this.showCustomConfirm('è¿™æ˜¯ä¸ºäº†åˆ·æ–°ä¸Šä¸€ä¸ªèŠå¤©ç¼“å­˜æ•°æ®ï¼Œå¦‚æœä¸æ˜¯æ‰“å¼€æ–°èŠå¤©ï¼Œè¯·ä¸è¦ç‚¹å‡»', () => {
              try {
                localStorage.removeItem('guixu_equipped_items');
                localStorage.removeItem('guixu_pending_actions');
                localStorage.removeItem('guixu_auto_write_enabled');
                this.showTemporaryMessage('ç¼“å­˜å·²æ¸…é™¤ï¼Œé¡µé¢å³å°†åˆ·æ–°...');
                setTimeout(() => {
                  window.location.reload();
                }, 1500);
              } catch (e) {
                console.error('æ¸…é™¤æœ¬åœ°å­˜å‚¨å¤±è´¥:', e);
                this.showTemporaryMessage('æ¸…é™¤ç¼“å­˜å¤±è´¥ï¼');
              }
            });
          },

          async executePendingActions() {
            // æŒ‡ä»¤ä¸­å¿ƒçš„æ‰§è¡ŒæŒ‰é’®ç°åœ¨æ€»æ˜¯ç›´æ¥å‘é€
            await this.handleAction();
          },

          useItem(item, buttonElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('ç‰©å“ä¿¡æ¯é”™è¯¯ï¼Œæ— æ³•ä½¿ç”¨ã€‚');
              return;
            }

            // **BUGä¿®å¤**: ä¸å†æ‰‹åŠ¨æ“ä½œDOMï¼Œè€Œæ˜¯é€šè¿‡åˆ·æ–°èƒŒåŒ…æ¥æ›´æ–°UI
            // æ£€æŸ¥å¾…å®šé˜Ÿåˆ—ä¸­çš„æ•°é‡ï¼Œä»¥é˜²æ­¢ç”¨æˆ·è¶…é¢ä½¿ç”¨
            const originalQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
            const pendingUses = this.pendingActions
              .filter(action => action.action === 'use' && action.itemName === itemName)
              .reduce((total, action) => total + action.quantity, 0);

            if (originalQuantity - pendingUses <= 0) {
              this.showTemporaryMessage(`${itemName} å·²ç”¨å®Œæˆ–å·²åœ¨æŒ‡ä»¤é˜Ÿåˆ—ä¸­ã€‚`);
              return;
            }

            // æ›´æ–°æŒ‡ä»¤é˜Ÿåˆ—
            const existingAction = this.pendingActions.find(
              action => action.action === 'use' && action.itemName === itemName,
            );

            if (existingAction) {
              existingAction.quantity++;
            } else {
              this.pendingActions.push({
                action: 'use',
                itemName: itemName,
                quantity: 1,
              });
            }

            this.showTemporaryMessage(`å·²å°† [ä½¿ç”¨ ${itemName}] åŠ å…¥æŒ‡ä»¤é˜Ÿåˆ—`);
            this.savePendingActions();

            // é€šè¿‡é‡æ–°æ¸²æŸ“æ•´ä¸ªèƒŒåŒ…æ¥ä¿è¯UIä¸€è‡´æ€§
            this.showInventory();
          },

          discardItem(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            if (itemName === 'N/A') {
              this.showTemporaryMessage('ç‰©å“ä¿¡æ¯é”™è¯¯ï¼Œæ— æ³•ä¸¢å¼ƒã€‚');
              return;
            }

            const hasQuantity = item.hasOwnProperty('quantity');
            
            if (hasQuantity && (category === 'ä¸¹è¯' || category === 'æ‚ç‰©')) {
              // æœ‰æ•°é‡çš„ç‰©å“ï¼Œéœ€è¦è¾“å…¥ä¸¢å¼ƒæ•°é‡
              this.promptDiscardQuantity(item, category, itemElement);
            } else {
              // è£…å¤‡ç±»ç‰©å“ï¼Œç›´æ¥ç¡®è®¤ä¸¢å¼ƒ
              this.confirmDiscardItem(item, category, itemElement, 1);
            }
          },

          async promptDiscardQuantity(item, category, itemElement) {
            const itemName = this.SafeGetValue(item, 'name');
            const currentQuantity = parseInt(this.SafeGetValue(item, 'quantity', 0), 10);
            
            // è®¡ç®—å¯ä¸¢å¼ƒçš„æ•°é‡ï¼ˆå‡å»å¾…å¤„ç†é˜Ÿåˆ—ä¸­çš„ä½¿ç”¨å’Œä¸¢å¼ƒæ•°é‡ï¼‰
            const pendingUses = this.pendingActions
              .filter(action => action.action === 'use' && action.itemName === itemName)
              .reduce((total, action) => total + action.quantity, 0);
            const pendingDiscards = this.pendingActions
              .filter(action => action.action === 'discard' && action.itemName === itemName)
              .reduce((total, action) => total + action.quantity, 0);
            const availableQuantity = currentQuantity - pendingUses - pendingDiscards;

            if (availableQuantity <= 0) {
              this.showTemporaryMessage(`${itemName} æ²¡æœ‰å¯ä¸¢å¼ƒçš„æ•°é‡ã€‚`);
              return;
            }

            return new Promise((resolve) => {
              // åˆ›å»ºæ•°é‡è¾“å…¥æ¨¡æ€æ¡†
              const modal = document.createElement('div');
              modal.className = 'modal-overlay';
              modal.style.display = 'flex';
              modal.style.zIndex = '2000';
              modal.innerHTML = `
                <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                  <div class="modal-header">
                    <h2 class="modal-title">ä¸¢å¼ƒç‰©å“</h2>
                  </div>
                  <div class="modal-body" style="padding: 20px;">
                    <p style="margin-bottom: 15px; color: #c9aa71;">è¯·è¾“å…¥è¦ä¸¢å¼ƒçš„ <strong>${itemName}</strong> æ•°é‡ï¼š</p>
                    <p style="font-size: 12px; color: #8b7355; margin-bottom: 10px;">å½“å‰å¯ä¸¢å¼ƒæ•°é‡ï¼š${availableQuantity}</p>
                    <input type="number" id="discard-quantity-input" min="1" max="${availableQuantity}" value="1"
                           style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                  color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 20px;">
                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                      <button id="discard-quantity-cancel" class="interaction-btn">å–æ¶ˆ</button>
                      <button id="discard-quantity-confirm" class="interaction-btn" style="background: #8b0000; border-color: #ff6b6b;">ç¡®è®¤ä¸¢å¼ƒ</button>
                    </div>
                  </div>
                </div>
              `;

              const container = document.querySelector('.guixu-root-container');
              container.appendChild(modal);

              const input = modal.querySelector('#discard-quantity-input');
              const confirmBtn = modal.querySelector('#discard-quantity-confirm');
              const cancelBtn = modal.querySelector('#discard-quantity-cancel');

              confirmBtn.addEventListener('click', () => {
                const quantity = parseInt(input.value, 10);
                if (isNaN(quantity) || quantity <= 0 || quantity > availableQuantity) {
                  this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¸¢å¼ƒæ•°é‡');
                  return;
                }
                modal.remove();
                this.confirmDiscardItem(item, category, itemElement, quantity);
                resolve();
              });

              cancelBtn.addEventListener('click', () => {
                modal.remove();
                resolve();
              });

              // è‡ªåŠ¨èšç„¦
              setTimeout(() => input.focus(), 100);
            });
          },

          confirmDiscardItem(item, category, itemElement, quantity = 1) {
            const itemName = this.SafeGetValue(item, 'name');
            const hasQuantity = item.hasOwnProperty('quantity');
            
            let confirmMessage;
            if (hasQuantity) {
              confirmMessage = `ç¡®å®šè¦ä¸¢å¼ƒ ${quantity} ä¸ª ${itemName} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`;
            } else {
              confirmMessage = `ç¡®å®šè¦ä¸¢å¼ƒ ${itemName} å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`;
            }

            this.showCustomConfirm(confirmMessage, () => {
              // æ·»åŠ åˆ°æŒ‡ä»¤é˜Ÿåˆ—
              this.pendingActions.push({
                action: 'discard',
                itemName: itemName,
                category: category,
                quantity: quantity
              });

              this.savePendingActions();
              
              // å‰ç«¯ä¹è§‚æ˜¾ç¤ºï¼šåˆ·æ–°èƒŒåŒ…ä»¥åæ˜ å˜åŒ–
              this.showInventory();
              
              if (hasQuantity) {
                this.showTemporaryMessage(`å·²å°† [ä¸¢å¼ƒ ${quantity} ä¸ª ${itemName}] åŠ å…¥æŒ‡ä»¤é˜Ÿåˆ—`);
              } else {
                this.showTemporaryMessage(`å·²å°† [ä¸¢å¼ƒ ${itemName}] åŠ å…¥æŒ‡ä»¤é˜Ÿåˆ—`);
              }
            });
          },

          showExtractedContent() {
            this.openModal('extracted-content-modal');
            const journeyEl = document.getElementById('extracted-journey');
            const pastLivesEl = document.getElementById('extracted-past-lives');
            const mapCommandsEl = document.getElementById('extracted-map-commands');
            const variablesEl = document.getElementById('extracted-variable-changes');
            const sentPromptEl = document.getElementById('sent-prompt-display');
            const currentMvuEl = document.getElementById('current-mvu-variables');

            if (currentMvuEl) {
              if (this.currentMvuState) {
                currentMvuEl.textContent = JSON.stringify(this.currentMvuState, null, 2);
              } else {
                currentMvuEl.textContent = 'MVU çŠ¶æ€å°šæœªåŠ è½½ã€‚';
              }
            }

            if (sentPromptEl) {
              sentPromptEl.textContent = this.lastSentPrompt || 'å°šæœªå‘é€ä»»ä½•å†…å®¹';
            }
            if (journeyEl) {
              journeyEl.textContent = this.lastExtractedJourney || 'æœªæå–åˆ°å†…å®¹';
            }
            if (pastLivesEl) {
              pastLivesEl.textContent = this.lastExtractedPastLives || 'æœªæå–åˆ°å†…å®¹';
            }
            if (mapCommandsEl) {
               mapCommandsEl.textContent = this.lastExtractedMapCommands || 'æœªæå–åˆ°åœ°å›¾æŒ‡ä»¤ã€‚';
            }
            if (variablesEl) {
              variablesEl.textContent = this.lastExtractedVariables || 'æœ¬æ¬¡æ— å˜é‡æ”¹å˜';
            }
            const novelModeEl = document.getElementById('extracted-novel-mode');
            const novelModeBtn = document.getElementById('btn-write-novel-mode');
            if (novelModeEl && novelModeBtn) {
              // æ–°é€»è¾‘ï¼šå§‹ç»ˆæ˜¾ç¤ºæå–åˆ°çš„å†…å®¹ã€‚æŒ‰é’®å¯ç”¨æ€§ä»…å–å†³äºå†…å®¹æ˜¯å¦å­˜åœ¨ã€‚
              novelModeEl.textContent = this.lastExtractedNovelText || 'å½“å‰AIå›å¤ä¸­æœªæå–åˆ°æ­£æ–‡å†…å®¹ã€‚';
              novelModeBtn.disabled = !this.lastExtractedNovelText;

              // æ›´æ–°æ ‡ç­¾æ–‡æœ¬ä»¥æä¾›å…³äºè‡ªåŠ¨å†™å…¥çŠ¶æ€çš„å³æ—¶åé¦ˆ
              const label = document.querySelector('label[for="novel-mode-enabled-checkbox"]');
              if (label) {
                const statusText = this.isNovelModeEnabled ? 'å¼€å¯' : 'å…³é—­';
                label.title = `ç‚¹å‡»åˆ‡æ¢è‡ªåŠ¨å†™å…¥çŠ¶æ€ï¼Œå½“å‰ä¸ºï¼š${statusText}`;
              }
            }

            // æ–°å¢ï¼šå¤„ç†æå–çš„è§’è‰²å¡
            const characterCardEl = document.getElementById('extracted-character-card');
            const characterCardBtn = document.getElementById('btn-write-character-card');
            if (characterCardEl && characterCardBtn) {
              characterCardEl.textContent = this.lastExtractedCharacterCard || 'æœªæå–åˆ°è§’è‰²å¡å†…å®¹ã€‚';
              characterCardBtn.disabled = !this.lastExtractedCharacterCard;
            }
          },

          async showJourney() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); // ç¡®ä¿è¾“å…¥æ¡†æ˜¾ç¤ºæ­£ç¡®çš„åºå·
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = 'æœ¬ä¸–å†ç¨‹';

            // æ–°å¢ï¼šå‘æ¨¡æ€æ¡†å¤´éƒ¨æ³¨å…¥ä¿®å‰ªç›¸å…³çš„UIå…ƒç´ 
            const headerControls = document.querySelector('#history-modal .modal-header > div');
            if (headerControls) {
                 headerControls.innerHTML = ``; // æ¸…ç©ºæ—§çš„ä¿®å‰ªæŒ‰é’®
            }
             // æ˜¾ç¤ºä¿®å‰ªæ§åˆ¶å°å¹¶åŠ è½½çŠ¶æ€
            const trimConsole = document.getElementById('trim-console');
            if (trimConsole) {
                trimConsole.style.display = 'block';
                this.loadTrimFieldsState(); // ç¡®ä¿æ¯æ¬¡æ‰“å¼€éƒ½åŠ è½½æœ€æ–°çš„çŠ¶æ€
            }

            const body = document.getElementById('history-modal-body');
            if (!body) return;

            // ä¿®å¤BUGï¼šä¸å†å®Œå…¨è¦†ç›–innerHTMLï¼Œè€Œæ˜¯åªæ›´æ–°æ—¶é—´çº¿éƒ¨åˆ†
            const timelinePlaceholder = document.createElement('div');
            timelinePlaceholder.id = 'timeline-placeholder';
            timelinePlaceholder.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨è¯»å–å‘½è¿ä¹‹å·...</p>';
            
            // æ¸…ç†æ—§çš„æ—¶é—´çº¿å¹¶æ’å…¥å ä½ç¬¦
            const existingTimeline = body.querySelector('.timeline-container');
            if (existingTimeline) {
                existingTimeline.remove();
            }
            body.appendChild(timelinePlaceholder);

            try {
              const bookName = '1å½’å¢Ÿ';
              const index = this.unifiedIndex;
              const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

              if (!journeyEntry) {
                console.warn(`åœ¨ä¸–ç•Œä¹¦ "${bookName}" ä¸­æœªæ‰¾åˆ°æ ‡é¢˜ä¸º "${journeyKey}" çš„æ¡ç›®ã€‚`);
              }
              // å°†æ¸²æŸ“å¥½çš„æ—¶é—´çº¿å†…å®¹æ›¿æ¢æ‰å ä½ç¬¦
              timelinePlaceholder.innerHTML = this.renderJourneyFromContent(journeyEntry);
              // ç»‘å®šç‚¹å‡»äº‹ä»¶ç›‘å¬å™¨
              this.bindJourneyListeners();

              // æ–°å¢ï¼šä¸ºåŠ¨æ€æ·»åŠ çš„ä¿®å‰ªUIç»‘å®šäº‹ä»¶
              document.querySelectorAll('.trim-field-checkbox').forEach(checkbox => {
                  checkbox.addEventListener('change', () => this.saveTrimFieldsState());
              });
              document.getElementById('btn-precise-trim')?.addEventListener('click', () => this.handlePreciseTrim());
              document.getElementById('btn-auto-trim')?.addEventListener('click', () => this.handleAutoTrim());
              document.getElementById('btn-full-trim')?.addEventListener('click', () => this.handleFullTrim());

            } catch (error) {
              console.error('è¯»å–"æœ¬ä¸–å†ç¨‹"æ—¶å‡ºé”™:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯»å–è®°å¿†æ—¶å‡ºç°é”™è¯¯ï¼š${error.message}</p>`;
            }
          },

          async showPastLives() {
            this.openModal('history-modal');
            this.loadUnifiedIndex(); // ç¡®ä¿è¾“å…¥æ¡†æ˜¾ç¤ºæ­£ç¡®çš„åºå·
            const titleEl = document.getElementById('history-modal-title');
            if (titleEl) titleEl.textContent = 'å¾€ä¸–æ¶Ÿæ¼ª';

            const body = document.getElementById('history-modal-body');
            if (!body) return;

            body.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨å›æº¯æ—¶å…‰é•¿æ²³...</p>';
            try {
              const bookName = '1å½’å¢Ÿ';
              const index = this.unifiedIndex;
              const pastLivesKey = index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);

              if (!pastLivesEntry) {
                console.warn(`åœ¨ä¸–ç•Œä¹¦ "${bookName}" ä¸­æœªæ‰¾åˆ°æ ‡é¢˜ä¸º "${pastLivesKey}" çš„æ¡ç›®ã€‚`);
              }

              body.innerHTML = this.renderPastLives(pastLivesEntry);
            } catch (error) {
              console.error('è¯»å–â€œå¾€ä¸–æ¶Ÿæ¼ªâ€æ—¶å‡ºé”™:', error);
              body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">å›æº¯æ—¶å…‰é•¿æ²³æ—¶å‡ºç°é”™è¯¯ï¼š${error.message}</p>`;
            }
          },

         async showNovelMode() {
          this.openModal('novel-mode-modal');
          this.loadUnifiedIndex(); // ä¿®å¤ï¼šä½¿ç”¨ç»Ÿä¸€åºå·è€Œä¸æ˜¯ç‹¬ç«‹åºå·
          // ç¡®ä¿å°è¯´æ¨¡å¼ç•Œé¢çš„åºå·è¾“å…¥æ¡†æ˜¾ç¤ºç»Ÿä¸€åºå·
          const input = document.getElementById('novel-mode-index-input');
          if (input) {
            input.value = this.unifiedIndex;
          }
          const titleEl = document.getElementById('novel-mode-modal-title');
          if (titleEl) titleEl.textContent = 'å°è¯´æ¨¡å¼';

          const body = document.getElementById('novel-mode-modal-body');
          const chapterNav = document.getElementById('novel-chapter-nav');
          if (!body) return;

          body.innerHTML = '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨åŠ è½½å°è¯´å†…å®¹...</p>';
          
          try {
            const bookName = '1å½’å¢Ÿ';
            const index = this.unifiedIndex; // ä¿®å¤ï¼šä½¿ç”¨ç»Ÿä¸€çš„ä¸–ç•Œä¹¦å†™å…¥åºå·
            const novelModeKey = index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼';
            const allEntries = await TavernHelper.getLorebookEntries(bookName);
            const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey);

            if (novelModeEntry && novelModeEntry.content) {
                // è§£æç« èŠ‚
                this.novelChapters = this.parseNovelChapters(novelModeEntry.content);
                this.loadNovelBookmarks(); // åŠ è½½ä¹¦ç­¾
                this.loadNovelDisplayMode(); // åŠ è½½æ˜¾ç¤ºæ¨¡å¼
                this.loadNovelBackgroundSettings(); // åŠ è½½èƒŒæ™¯è®¾ç½®
                
                if (this.novelChapters.length > 1) {
                    // æ˜¾ç¤ºç« èŠ‚å¯¼èˆª
                    if (chapterNav) chapterNav.style.display = 'block';
                    
                    // æ›´æ–°ç« èŠ‚é€‰æ‹©å™¨
                    const chapterSelect = document.getElementById('chapter-select');
                    if (chapterSelect) {
                        chapterSelect.innerHTML = '<option value="">é€‰æ‹©ç« èŠ‚...</option>';
                        this.novelChapters.forEach((chapter, index) => {
                            const option = document.createElement('option');
                            option.value = index;
                            option.textContent = chapter.title;
                            chapterSelect.appendChild(option);
                        });
                    }
                    
                    // æ›´æ–°ä¹¦ç­¾é€‰æ‹©å™¨
                    this.updateBookmarkSelect();
                    
                    // æ ¹æ®æ˜¾ç¤ºæ¨¡å¼æ˜¾ç¤ºå†…å®¹
                    if (this.novelDisplayMode === 'continuous') {
                        this.showAllChaptersContinuous();
                    } else {
                        this.showNovelChapter(0);
                    }
                } else {
                    // æ²¡æœ‰ç« èŠ‚ï¼Œéšè—å¯¼èˆªï¼Œæ˜¾ç¤ºå…¨éƒ¨å†…å®¹
                    if (chapterNav) chapterNav.style.display = 'none';
                    body.innerHTML = `<div class="game-text-container" style="white-space: pre-wrap; padding: 10px;">${this.formatMessageContent(novelModeEntry.content)}</div>`;
                }
                
                // åº”ç”¨èƒŒæ™¯è®¾ç½®
                this.applyNovelBackground();
            } else {
                if (chapterNav) chapterNav.style.display = 'none';
                body.innerHTML = '<p style="text-align:center; color:#8b7355; font-size:12px; padding-top: 20px;">è¯¥åºå·ä¸‹æ²¡æœ‰å°è¯´å†…å®¹ã€‚</p>';
            }

          } catch (error) {
            console.error('è¯»å–"å°è¯´æ¨¡å¼"æ—¶å‡ºé”™:', error);
            if (chapterNav) chapterNav.style.display = 'none';
            body.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯»å–å°è¯´æ—¶å‡ºç°é”™è¯¯ï¼š${error.message}</p>`;
          }
        },


          // --- Rendering Logic for Dynamic Content (Lorebooks) ---
          parseJourneyEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return [];
            try {
              const events = [];
              const eventBlocks = contentString
                .trim()
                .split(/åºå·\|/g)
                .slice(1);

              eventBlocks.forEach(block => {
                const fullBlock = `åºå·|${block}`.trim();
                const event = {};
                
                // å®šä¹‰å­—æ®µé¡ºåºï¼Œç”¨äºæ­£ç¡®è§£æå¤šè¡Œå†…å®¹
                const fieldOrder = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'åœ°ç‚¹', 'äººç‰©', 'æè¿°', 'äººç‰©å…³ç³»', 'æ ‡ç­¾', 'é‡è¦ä¿¡æ¯', 'æš—çº¿ä¸ä¼ç¬”', 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];
                
                let currentFieldIndex = 0;
                let currentKey = '';
                let currentValue = '';
                
                const lines = fullBlock.split('\n');
                
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i];
                  let foundField = false;
                  
                  // æ£€æŸ¥æ˜¯å¦æ˜¯æ–°å­—æ®µçš„å¼€å§‹
                  for (let j = currentFieldIndex; j < fieldOrder.length; j++) {
                    const field = fieldOrder[j];
                    if (line.startsWith(field + '|')) {
                      // ä¿å­˜å‰ä¸€ä¸ªå­—æ®µçš„å€¼
                      if (currentKey && currentValue.trim()) {
                        event[currentKey] = currentValue.trim();
                      }
                      
                      // å¼€å§‹æ–°å­—æ®µ
                      currentKey = field;
                      currentValue = line.substring(field.length + 1);
                      currentFieldIndex = j;
                      foundField = true;
                      break;
                    }
                  }
                  
                  // å¦‚æœä¸æ˜¯æ–°å­—æ®µï¼Œåˆ™è¿½åŠ åˆ°å½“å‰å­—æ®µå€¼
                  if (!foundField && currentKey) {
                    currentValue += '\n' + line;
                  }
                }
                
                // ä¿å­˜æœ€åä¸€ä¸ªå­—æ®µ
                if (currentKey && currentValue.trim()) {
                  event[currentKey] = currentValue.trim();
                }
                
                if (event['åºå·']) {
                  events.push(event);
                }
              });
              return events;
            } catch (e) {
              console.error('è§£ææœ¬ä¸–å†ç¨‹æ¡ç›®å¤±è´¥:', e);
              return [];
            }
          },

          parsePastLifeEntry(contentString) {
            if (!contentString || typeof contentString !== 'string') return {};
            try {
                const data = {};
                // é€šè¿‡å‰ç»æ–­è¨€ (?=...) æŒ‰æ¯ä¸ªå­—æ®µçš„èµ·å§‹æ ‡å¿—è¿›è¡Œåˆ†å‰²ï¼ŒåŒæ—¶ä¿ç•™åˆ†éš”ç¬¦
                const parts = contentString.trim().split(/\n(?=^(?:ç¬¬\d+ä¸–|äº‹ä»¶è„‰ç»œ|æœ¬ä¸–æ¦‚è¿°|æœ¬ä¸–æˆå°±|æœ¬ä¸–è·å¾—ç‰©å“|æœ¬ä¸–äººç‰©å…³ç³»ç½‘|æ­»äº¡åŸå› |æœ¬ä¸–æ€»ç»“|æœ¬ä¸–è¯„ä»·)\|)/m);

                for (const part of parts) {
                    if (!part.trim()) continue;
                    
                    const separatorIndex = part.indexOf('|');
                    if (separatorIndex > 0) {
                        const key = part.substring(0, separatorIndex).trim();
                        const value = part.substring(separatorIndex + 1).trim();
                        data[key] = value;
                    }
                }
                return data;
            } catch (e) {
              console.error('è§£æå¾€ä¸–æ¶Ÿæ¼ªæ¡ç›®å¤±è´¥:', e);
              return {};
            }
          },

          renderJourneyFromContent(entry) {
            if (!entry || !entry.content)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">æ­¤ç”Ÿå°šæœªç•™ä¸‹ä»»ä½•å°è®°ã€‚</p>';

            const events = this.parseJourneyEntry(entry.content);
            if (events.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">å†…å®¹æ ¼å¼æœ‰è¯¯ï¼Œæ— æ³•è§£æäº‹ä»¶ã€‚</p>';

            events.sort((a, b) => (parseInt(a.åºå·, 10) || 0) - (parseInt(b.åºå·, 10) || 0));

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            events.forEach((eventData, index) => {
              const eventId = `event-${entry.uid}-${index}`;
              const date = eventData['æ—¥æœŸ'] || 'æœªçŸ¥æ—¶é—´';
              const sequence = eventData['åºå·'] || '?';
              const title = eventData['æ ‡é¢˜'] || 'æ— æ ‡é¢˜';
              const displayTitle = `ç¬¬${sequence}ç«  ${title}`;
              const location = eventData['åœ°ç‚¹'] || 'æœªçŸ¥åœ°ç‚¹';
              const description = eventData['æè¿°'] || 'æ— è¯¦ç»†æè¿°ã€‚';
              const characters = eventData['äººç‰©'] || '';
              const relationships = eventData['äººç‰©å…³ç³»'] || '';
              const importantInfo = eventData['é‡è¦ä¿¡æ¯'] || '';
              const hiddenPlot = eventData['æš—çº¿ä¸ä¼ç¬”'] || '';
              const autoSystem = eventData['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'] || '';

              const tagsHtml = (eventData['æ ‡ç­¾'] || '')
                .split('|')
                .map(tag => tag.trim())
                .filter(tag => tag)
                .map(tag => `<span class="tag-item">${tag}</span>`)
                .join('');

              // åŸºæœ¬ä¿¡æ¯ï¼ˆé»˜è®¤æ˜¾ç¤ºï¼‰ - è°ƒæ•´äº†HTMLç»“æ„ä»¥é€‚åº”æ–°çš„å¤é€‰æ¡†ä½ç½®
              const basicInfo = `
                <div style="display: flex; align-items: baseline; gap: 8px; margin-bottom: 8px;">
                    <div class="timeline-date">${date}</div>
                    <input type="checkbox" class="journey-trim-checkbox" data-sequence-id="${eventData['åºå·']}" style="cursor: pointer;">
                </div>
                <div class="timeline-tags">${tagsHtml}</div>
                <div class="timeline-title">${displayTitle}</div>
                <div class="timeline-location" style="font-size: 12px; color: #8b7355; margin: 5px 0;">åœ°ç‚¹ï¼š${location}</div>
                <div class="timeline-description">${description}</div>
              `;

              // è¯¦ç»†ä¿¡æ¯ï¼ˆéœ€è¦ç‚¹å‡»3æ¬¡æ‰æ˜¾ç¤ºï¼‰
              const detailedInfo = `
                <div class="timeline-detailed-info" id="detailed-${eventId}" style="display: none; margin-top: 15px; padding-top: 15px; border-top: 1px solid rgba(201, 170, 113, 0.3);">
                  ${characters ? `<div class="detail-section"><strong>äººç‰©ï¼š</strong>${characters}</div>` : ''}
                  ${relationships ? `<div class="detail-section"><strong>äººç‰©å…³ç³»ï¼š</strong>${relationships}</div>` : ''}
                  ${importantInfo ? `<div class="detail-section"><strong>é‡è¦ä¿¡æ¯ï¼š</strong>${importantInfo}</div>` : ''}
                  ${hiddenPlot ? `<div class="detail-section"><strong>æš—çº¿ä¸ä¼ç¬”ï¼š</strong>${hiddenPlot}</div>` : ''}
                  ${autoSystem ? `<div class="detail-section"><strong>è‡ªåŠ¨åŒ–ç³»ç»Ÿï¼š</strong><pre style="white-space: pre-wrap; font-size: 11px; color: #a09c91;">${autoSystem}</pre></div>` : ''}
                </div>
              `;

              html += `
                <div class="timeline-event" data-event-id="${eventId}" data-click-count="0" style="cursor: pointer;">
                  <div class="timeline-content">
                    ${basicInfo}
                    ${detailedInfo}
                  </div>
                </div>`;
            });
            html += '</div>';
            return html;
          },

          renderPastLives(entry) {
            if (!entry || !entry.content || !entry.content.trim())
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">æœªå‘ç°ä»»ä½•å¾€ä¸–çš„ç—•è¿¹ã€‚</p>';

            // ä½¿ç”¨å‰ç»æ–­è¨€æ¥åˆ†å‰²ï¼Œè¿™æ ·ä¸ä¼šæ¶ˆè€—åˆ†éš”ç¬¦ï¼Œå¯ä»¥æ­£ç¡®å¤„ç†æ¯ä¸€ä¸–çš„è®°å½•
            const pastLifeBlocks = entry.content.trim().split(/\n\n?(?=ç¬¬\d+ä¸–\|)/);
            
            if (pastLifeBlocks.length === 0)
              return '<p style="text-align:center; color:#8b7355; font-size:12px;">å†…å®¹æ ¼å¼æœ‰è¯¯ï¼Œæ— æ³•è§£æå¾€ä¸–è®°å½•ã€‚</p>';

            let html = '<div class="timeline-container"><div class="timeline-line"></div>';
            pastLifeBlocks.forEach(block => {
              if (!block.trim()) return; // è·³è¿‡å¯èƒ½äº§ç”Ÿçš„ç©ºå—
              const data = this.parsePastLifeEntry(block);
              
              const titleKey = Object.keys(data).find(k => k.startsWith('ç¬¬') && k.endsWith('ä¸–'));
              let title;
              // ä¿®å¤ï¼šæ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ¨ï¼Œè€Œä¸æ˜¯å€¼çš„çœŸå‡ï¼Œå¹¶ä¸ºæ— é¢˜çš„æƒ…å†µæä¾›å›é€€
              if (titleKey && data.hasOwnProperty(titleKey)) {
                  const titleValue = data[titleKey] || 'æ— é¢˜';
                  title = `${titleKey} | ${titleValue}`;
              } else {
                  // å¦‚æœè§£æå¤±è´¥ï¼Œåˆ™å°†å—çš„ç¬¬ä¸€è¡Œä½œä¸ºæ ‡é¢˜
                  title = block.split('\n')[0].trim();
              }

              let detailsHtml = '';
              const fieldOrder = ['äº‹ä»¶è„‰ç»œ', 'æœ¬ä¸–æ¦‚è¿°', 'æœ¬ä¸–æˆå°±', 'æœ¬ä¸–è·å¾—ç‰©å“', 'æœ¬ä¸–äººç‰©å…³ç³»ç½‘', 'æ­»äº¡åŸå› ', 'æœ¬ä¸–æ€»ç»“', 'æœ¬ä¸–è¯„ä»·'];
              fieldOrder.forEach(field => {
                  if (data[field]) {
                      // ä½¿ç”¨<pre>æ ‡ç­¾æ¥ä¿ç•™å¤šè¡Œæ–‡æœ¬çš„æ¢è¡Œå’Œæ ¼å¼
                      const fieldClassMap = {
                        'æ­»äº¡åŸå› ': 'death-reason',
                        'æœ¬ä¸–æˆå°±': 'achievement',
                        'æœ¬ä¸–è·å¾—ç‰©å“': 'items-obtained',
                        'æœ¬ä¸–æ€»ç»“': 'summary-evaluation',
                        'æœ¬ä¸–è¯„ä»·': 'summary-evaluation'
                      };
                      const specificClass = fieldClassMap[field] || '';
                      const itemClass = `detail-item ${specificClass}`.trim();
                      detailsHtml += `<div class="${itemClass}"><strong>${field}:</strong> <pre style="white-space: pre-wrap; font-family: inherit; margin: 0;">${data[field]}</pre></div>`;
                  }
              });

              html += `
                        <div class="timeline-event">
                            <div class="timeline-content">
                                <div class="timeline-title">${title}</div>
                                <div class="past-life-details">
                                    ${detailsHtml || '<div class="detail-item">å†…å®¹ä¸è¯¦</div>'}
                                </div>
                            </div>
                        </div>`;
            });
            html += '</div>';
            return html;
          },

          async renderPastLifeDetails(bookName) {
            const detailsContainer = document.getElementById('past-life-details');
            if (!detailsContainer) return;
            detailsContainer.style.display = 'block';
            detailsContainer.innerHTML =
              '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æ­£åœ¨è¯»å–æ­¤ä¸–è®°å¿†...</p>';
            try {
              const entries = await TavernHelper.getLorebookEntries(bookName, 'summary');
              if (entries && entries.length > 0) {
                const summaryData = JSON.parse(entries[0].content);
                detailsContainer.innerHTML = `
                            <h4>${bookName} - ç»“å±€æ€»è§ˆ</h4>
                            <p><strong>æœ€ç»ˆå¢ƒç•Œ:</strong> ${summaryData.finalStats.å¢ƒç•Œ}</p>
                            <p><strong>å­˜æ´»æ—¶é—´:</strong> ${summaryData.finalStats.å­˜æ´»æ—¶é—´}</p>
                            <p><strong>ä¸»è¦æˆå°±:</strong> ${summaryData.achievements.join('ã€ ')}</p>
                            <p><strong>æœ€ç»ˆæ‚”æ†¾:</strong> ${summaryData.regrets}</p>
                            <p><strong>å…³é”®äº‹ä»¶:</strong></p>
                            <ul style="padding-left: 20px;">${summaryData.keyEvents
                              .map(e => `<li>${e}</li>`)
                              .join('')}</ul>`;
              } else {
                detailsContainer.innerHTML =
                  '<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">æœªèƒ½æ‰¾åˆ°æ­¤ä¸–çš„ç»“å±€æ€»è§ˆã€‚</p>';
              }
            } catch (error) {
              console.error(`Error fetching details for ${bookName}:`, error);
              detailsContainer.innerHTML = `<p class="modal-placeholder" style="text-align:center; color:#8b7355; font-size:12px;">è¯»å–æ­¤ä¸–è®°å¿†æ—¶å‡ºé”™ï¼š${error.message}</p>`;
            }
          },

          // --- Dynamic Event Listeners for Lorebook content ---
          bindJourneyListeners() {
            // ä¸ºæœ¬ä¸–å†ç¨‹äº‹ä»¶ç»‘å®šç‚¹å‡»ç›‘å¬å™¨
            const timelineContainer = document.querySelector('.timeline-container');
            if (timelineContainer) {
              timelineContainer.addEventListener('click', (e) => {
                const timelineEvent = e.target.closest('.timeline-event');
                if (timelineEvent) {
                  this.handleJourneyEventClick(timelineEvent);
                }
              });
            }
          },

          handleJourneyEventClick(eventElement) {
            const detailedInfo = eventElement.querySelector('.timeline-detailed-info');
            
            // æ£€æŸ¥è¯¦ç»†ä¿¡æ¯æ˜¯å¦å·²ç»æ˜¾ç¤º
            if (detailedInfo && detailedInfo.style.display === 'block') {
              // å¦‚æœå·²æ˜¾ç¤ºï¼Œåˆ™éšè—
              detailedInfo.style.display = 'none';
              eventElement.style.cursor = 'pointer';
              // é‡ç½®ç‚¹å‡»è®¡æ•°ï¼Œå…è®¸é‡æ–°å¼€å§‹3æ¬¡ç‚¹å‡»
              eventElement.dataset.clickCount = '0';
            } else {
              // å¦‚æœæœªæ˜¾ç¤ºï¼Œç»§ç»­åŸæœ‰çš„3æ¬¡ç‚¹å‡»é€»è¾‘
              const currentCount = parseInt(eventElement.dataset.clickCount || '0', 10);
              const newCount = currentCount + 1;
              eventElement.dataset.clickCount = newCount;

              // å½“ç‚¹å‡»3æ¬¡æ—¶æ˜¾ç¤ºè¯¦ç»†ä¿¡æ¯
              if (newCount >= 3) {
                if (detailedInfo) {
                  detailedInfo.style.display = 'block';
                }
                
                // ä¿æŒç‚¹å‡»æ ·å¼ï¼Œå…è®¸å†æ¬¡ç‚¹å‡»éšè—
                eventElement.style.cursor = 'pointer';
              }
            }
          },

          async handleRewind(eventId, eventTitle) {
            // â€œå›æº¯â€æŒ‰é’®ç›¸å…³é€»è¾‘å·²ç§»é™¤
          },

          // æ­¤å‡½æ•°ä¸å†éœ€è¦ï¼Œæå–é€»è¾‘å·²åˆå¹¶åˆ° loadAndDisplayCurrentScene
          processAIResponse() {
            // ç©ºå‡½æ•°æˆ–å¯ç›´æ¥åˆ é™¤
          },

          // --- æ–°å¢ï¼šå†™å…¥ä¸–ç•Œä¹¦çš„æ ¸å¿ƒé€»è¾‘ ---
          // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
          async writeJourneyToLorebook(silent = false) {
            const content = this.lastExtractedJourney;
            await this.writeToLorebook('æœ¬ä¸–å†ç¨‹', content, silent);
          },

          async writePastLivesToLorebook(silent = false) {
            const content = this.lastExtractedPastLives;
            await this.writeToLorebook('å¾€ä¸–æ¶Ÿæ¼ª', content, silent);
          },

          async writeNovelModeToLorebook(silent = false) {
            const novelText = this.lastExtractedNovelText;
            // å¦‚æœæ²¡æœ‰æ­£æ–‡å†…å®¹ï¼Œåˆ™ä¸æ‰§è¡Œä»»ä½•æ“ä½œ
            if (!novelText || novelText.trim() === '') {
              if (!silent) this.showTemporaryMessage('æ²¡æœ‰å¯å†™å…¥çš„å°è¯´æ­£æ–‡ã€‚');
              return;
            }

            const journeyText = this.lastExtractedJourney;
            let chapterHeader = '';

            // å°è¯•ä»æœ¬ä¸–å†ç¨‹ä¸­æå–ç« èŠ‚ä¿¡æ¯
            if (journeyText) {
              try {
                const events = this.parseJourneyEntry(journeyText);
                if (events.length > 0) {
                  // å‡è®¾æ•°ç»„ä¸­æœ€åä¸€ä¸ªäº‹ä»¶æ˜¯æœ€æ–°çš„
                  const latestEvent = events[events.length - 1];
                  const sequence = this.SafeGetValue(latestEvent, 'åºå·', null);
                  const title = this.SafeGetValue(latestEvent, 'æ ‡é¢˜', null);

                  if (sequence && title) {
                    chapterHeader = `ç¬¬${sequence}ç«  ${title}\n\n`;
                  }
                }
              } catch (e) {
                console.error('ä¸ºå°è¯´æ¨¡å¼è§£æç« èŠ‚æ ‡é¢˜æ—¶å‡ºé”™:', e);
              }
            }

            const finalContent = chapterHeader + novelText;
            await this.writeToLorebook('å°è¯´æ¨¡å¼', finalContent, silent);
          },

          // æœ€ç»ˆç‰ˆï¼šé‡æ„å†™å…¥é€»è¾‘ï¼Œæ”¯æŒåŠ¨æ€ç´¢å¼•å’Œæ¡ç›®åˆ›å»º
          async writeToLorebook(baseEntryKey, contentToWrite, silent = false) {
            if (!contentToWrite || contentToWrite.trim() === '') {
              if (!silent) this.showTemporaryMessage('æ²¡æœ‰å¯å†™å…¥çš„å†…å®¹ã€‚');
              return;
            }

            // 1. æ ¹æ®åºå·ç”Ÿæˆæœ€ç»ˆçš„æ¡ç›®åç§° - ä¿®å¤ï¼šå°è¯´æ¨¡å¼ä¹Ÿä½¿ç”¨ç»Ÿä¸€åºå·
            const index = this.unifiedIndex; // æ‰€æœ‰ç±»å‹éƒ½ä½¿ç”¨ç»Ÿä¸€çš„ä¸–ç•Œä¹¦å†™å…¥åºå·
            const finalEntryKey = index > 1 ? `${baseEntryKey}(${index})` : baseEntryKey;
            const bookName = '1å½’å¢Ÿ';

            let reformattedContent = contentToWrite.trim();
            let buttonId;

            // 2. å†…å®¹æ ¼å¼åŒ– (é€»è¾‘ä¿æŒä¸å˜)
            if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') {
                const parsePastLivesRobust = (text) => {
                    const data = {};
                    const lines = text.trim().split('\n');
                    let currentKey = null;
                    let tempValue = [];
                    const keyRegex = /^(ç¬¬\d+ä¸–|äº‹ä»¶è„‰ç»œ|æœ¬ä¸–æ¦‚è¿°|æœ¬ä¸–æˆå°±|æœ¬ä¸–è·å¾—ç‰©å“|æœ¬ä¸–äººç‰©å…³ç³»ç½‘|æ­»äº¡åŸå› |æœ¬ä¸–æ€»ç»“|æœ¬ä¸–è¯„ä»·)\|/;

                    for (const line of lines) {
                        const match = line.match(keyRegex);
                        if (match) {
                            if (currentKey) {
                                data[currentKey] = tempValue.join('\n').trim();
                            }
                            currentKey = match[1];
                            tempValue = [line.substring(match[0].length)];
                        } else if (currentKey) {
                            tempValue.push(line);
                        }
                    }
                    if (currentKey) {
                        data[currentKey] = tempValue.join('\n').trim();
                    }
                    return data;
                };

                const parsedData = parsePastLivesRobust(contentToWrite);
                if (Object.keys(parsedData).length === 0) {
                    if (!silent) this.showTemporaryMessage(`æ— æ³•è§£æâ€œ${baseEntryKey}â€çš„å†…å®¹ï¼Œå†™å…¥æ“ä½œå·²å–æ¶ˆã€‚`);
                    return;
                }
                
                const dynamicKey = Object.keys(parsedData).find(k => k.startsWith('ç¬¬') && k.endsWith('ä¸–'));
                const fields = [
                    dynamicKey, 'äº‹ä»¶è„‰ç»œ', 'æœ¬ä¸–æ¦‚è¿°', 'æœ¬ä¸–æˆå°±', 'æœ¬ä¸–è·å¾—ç‰©å“',
                    'æœ¬ä¸–äººç‰©å…³ç³»ç½‘', 'æ­»äº¡åŸå› ', 'æœ¬ä¸–æ€»ç»“', 'æœ¬ä¸–è¯„ä»·',
                ].filter(Boolean);

                reformattedContent = fields
                    .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                    .filter(Boolean)
                    .join('\n');
                
                buttonId = 'btn-write-past-lives';

            } else if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') {
                const journeyFields = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'æè¿°', 'æ ‡ç­¾'];
                const parseContent = (text, fieldList) => {
                  const data = {};
                  let tempText = text.replace(/\r\n/g, '\n');
                  fieldList.forEach((field, fIndex) => {
                    const nextField = fieldList[fIndex + 1];
                    const startMarker = `${field}|`;
                    const startIndex = tempText.indexOf(startMarker);
                    if (startIndex !== -1) {
                      let endIndex;
                      if (nextField) {
                        const nextMarkerIndex = tempText.indexOf(`${nextField}|`, startIndex);
                        endIndex = nextMarkerIndex !== -1 ? nextMarkerIndex : undefined;
                      }
                      let value = tempText.substring(startIndex + startMarker.length, endIndex);
                      data[field] = value.trim();
                    }
                  });
                  return data;
                };
                const parsedData = parseContent(contentToWrite, journeyFields);
                 if (Object.keys(parsedData).length === 0) {
                    if (!silent) this.showTemporaryMessage(`æ— æ³•è§£æâ€œ${baseEntryKey}â€çš„å†…å®¹ï¼Œå†™å…¥æ“ä½œå·²å–æ¶ˆã€‚`);
                    return;
                }
                reformattedContent = journeyFields
                    .map(key => (parsedData[key] ? `${key}|${parsedData[key]}` : null))
                    .filter(Boolean)
                    .join('\n');
                buttonId = 'btn-write-journey';
            } else if (baseEntryKey === 'å°è¯´æ¨¡å¼') {
              buttonId = 'btn-write-novel-mode';
            }

            const button = document.getElementById(buttonId);
            if (button && !silent) button.textContent = 'å†™å…¥ä¸­...';

            try {
              // 3. æ£€æŸ¥æ¡ç›®æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              let targetEntry = allEntries.find(entry => entry.comment === finalEntryKey);

              if (!targetEntry) {
                if (!silent) this.showTemporaryMessage(`æ¡ç›® "${finalEntryKey}" ä¸å­˜åœ¨ï¼Œæ­£åœ¨åˆ›å»º...`);
                
                let finalContentToWrite = reformattedContent;
                // æ–°å¢ï¼šå¦‚æœæ˜¯æœ¬ä¸–å†ç¨‹ä¸”å¼€å¯äº†è‡ªåŠ¨ä¿®å‰ªï¼Œåˆ™å¯¹æ–°åˆ›å»ºçš„å†…å®¹ä¹Ÿè¿›è¡Œä¸€æ¬¡æ£€æŸ¥ï¼ˆè™½ç„¶é€šå¸¸æ˜¯ç¬¬ä¸€ä¸ªäº‹ä»¶ï¼Œä½†é€»è¾‘ä¸Šå®Œæ•´ï¼‰
                if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹' && this.isAutoTrimEnabled) {
                    finalContentToWrite = this._getTrimmedJourneyContent(finalContentToWrite);
                }

                const baseEntryTemplate = allEntries.find(entry => entry.comment === baseEntryKey);
                
                // æ„å»ºå®Œæ•´çš„æ¡ç›®æ•°æ®ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€çš„å±æ€§éƒ½å­˜åœ¨
                const newEntryData = {
                  comment: finalEntryKey,
                  content: finalContentToWrite, // ä½¿ç”¨å¯èƒ½è¢«ä¿®å‰ªè¿‡çš„å†…å®¹
                  keys: baseEntryTemplate ? [...baseEntryTemplate.keys, finalEntryKey] : [finalEntryKey],
                  enabled: false,
                  // å¤åˆ¶æ¨¡æ¿çš„æ‰€æœ‰å±æ€§ï¼Œå¦‚æœæ²¡æœ‰æ¨¡æ¿åˆ™ä½¿ç”¨é»˜è®¤å€¼ï¼Œä¼˜å…ˆä½¿ç”¨ä¿å­˜çš„è®¾ç½®
                  type: (() => {
                    if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.type || baseEntryTemplate?.type || 'selective';
                    if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.type || baseEntryTemplate?.type || 'constant';
                    if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.type || baseEntryTemplate?.type || 'constant';
                    if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.type || baseEntryTemplate?.type || 'constant';
                    return baseEntryTemplate?.type || 'selective';
                  })(),
                  position: (() => {
                    if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                    if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                    return baseEntryTemplate?.position || 'before_character_definition';
                  })(),
                  order: (() => {
                    if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.order || baseEntryTemplate?.order || 20;
                    if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.order || baseEntryTemplate?.order || 19;
                    if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.order || baseEntryTemplate?.order || 18;
                    if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.order || baseEntryTemplate?.order || 21;
                    if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.order || baseEntryTemplate?.order || 20;
                    if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.order || baseEntryTemplate?.order || 19;
                    return baseEntryTemplate?.order || 20;
                  })(),
                  filters: baseEntryTemplate?.filters || [],
                  scan_depth: baseEntryTemplate?.scan_depth || 'same_as_global',
                  case_sensitive: baseEntryTemplate?.case_sensitive || 'same_as_global',
                  match_whole_words: baseEntryTemplate?.match_whole_words || 'same_as_global',
                  use_group_scoring: baseEntryTemplate?.use_group_scoring || 'same_as_global',
                  probability: baseEntryTemplate?.probability !== undefined ? baseEntryTemplate.probability : 100,
                  exclude_recursion: baseEntryTemplate?.exclude_recursion || false,
                  prevent_recursion: baseEntryTemplate?.prevent_recursion || false,
                  delay_until_recursion: baseEntryTemplate?.delay_until_recursion || false,
                  depth: (() => {
                    const position = (() => {
                      if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                      if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.position || baseEntryTemplate?.position || 'before_character_definition';
                      return baseEntryTemplate?.position || 'before_character_definition';
                    })();
                    
                    if (position.startsWith('at_depth')) {
                      if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') return this.worldbookSettings?.journey?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') return this.worldbookSettings?.pastLives?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å°è¯´æ¨¡å¼') return this.worldbookSettings?.novel?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'åˆ†æ®µæ­£æ–‡') return this.worldbookSettings?.segmented?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å°æ€»ç»“') return this.worldbookSettings?.smallSummary?.depth || baseEntryTemplate?.depth || 1;
                      if (baseEntryKey === 'å¤§æ€»ç»“') return this.worldbookSettings?.largeSummary?.depth || baseEntryTemplate?.depth || 1;
                      return baseEntryTemplate?.depth || 1;
                    }
                    return null;
                  })(),
                  automation_id: baseEntryTemplate?.automation_id || null,
                  group: baseEntryTemplate?.group || '',
                  group_prioritized: baseEntryTemplate?.group_prioritized || false,
                  group_weight: baseEntryTemplate?.group_weight || 100,
                  sticky: baseEntryTemplate?.sticky || null,
                  cooldown: baseEntryTemplate?.cooldown || null,
                  delay: baseEntryTemplate?.delay || null
                };

                await TavernHelper.createLorebookEntries(bookName, [newEntryData]);
                if (!silent) this.showTemporaryMessage(`å·²æˆåŠŸåˆ›å»ºå¹¶å†™å…¥åˆ°â€œ${finalEntryKey}â€ã€‚`);
                
                if (this.isAutoToggleLorebookEnabled) {
                    this.updateAutoToggledEntries();
                }

              } else {
                // 4. å¦‚æœæ¡ç›®å­˜åœ¨ï¼Œåˆ™æ ¹æ®ç±»å‹å†³å®šæ˜¯è¿½åŠ è¿˜æ˜¯è¦†ç›–
                let updatedContent;

                if (baseEntryKey === 'å°è¯´æ¨¡å¼') {
                    // å¯¹äºå°è¯´æ¨¡å¼ï¼Œæ£€æŸ¥é‡å¤åè¿½åŠ å†…å®¹
                    const existingContent = targetEntry.content || '';
                    if (existingContent.includes(reformattedContent.trim())) {
                        if (!silent) this.showTemporaryMessage(`å†…å®¹å·²å­˜åœ¨ï¼Œè·³è¿‡å†™å…¥ã€‚`);
                        console.log(`[å½’å¢Ÿ] å†…å®¹é‡å¤ (å°è¯´æ¨¡å¼)ï¼Œè·³è¿‡å†™å…¥: ${finalEntryKey}`);
                        if (button && !silent) {
                            button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                        }
                        return;
                    }
                    updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                    if (!silent) this.showTemporaryMessage(`å·²æˆåŠŸè¿½åŠ å†…å®¹åˆ°â€œ${finalEntryKey}â€`);
                } else {
                    // å¯¹äºå…¶ä»–ç±»å‹ï¼ˆå¦‚æœ¬ä¸–å†ç¨‹ï¼‰ï¼Œæ£€æŸ¥é‡å¤åè¿½åŠ å†…å®¹
                    const existingContent = targetEntry.content || '';

                    // æ–°å¢ï¼šåŸºäºåºå·çš„æ›´å¯é çš„é‡å¤æ£€æŸ¥ï¼Œä»¥è§£å†³ä¿®å‰ªå†²çª
                    const getSeq = (text) => {
                        if (!text) return null;
                        // Match 'åºå·|' at the very beginning of the block
                        const match = text.match(/^åºå·\|(\d+)/);
                        return match ? match[1] : null;
                    };

                    const newEventSeq = getSeq(reformattedContent.trim());
                    let isDuplicate = false;

                    if (newEventSeq && baseEntryKey === 'æœ¬ä¸–å†ç¨‹') {
                        const existingSequences = (existingContent)
                            .split('\n\n') // Events are separated by double newlines
                            .map(block => getSeq(block.trim()))
                            .filter(seq => seq !== null);
                        
                        if (existingSequences.includes(newEventSeq)) {
                            isDuplicate = true;
                        }
                    } else {
                        // å¦‚æœæ–°å†…å®¹æ²¡æœ‰åºå·ï¼Œæˆ–ä¸æ˜¯â€œæœ¬ä¸–å†ç¨‹â€ï¼Œåˆ™é€€å›æ—§çš„åŸºäºå†…å®¹çš„æ£€æŸ¥
                        isDuplicate = existingContent.includes(reformattedContent.trim());
                    }

                    if (isDuplicate) {
                        const message = newEventSeq ? `äº‹ä»¶ (åºå· ${newEventSeq}) å·²å­˜åœ¨` : 'å†…å®¹å·²å­˜åœ¨';
                        if (!silent) this.showTemporaryMessage(`${message}ï¼Œè·³è¿‡å†™å…¥ã€‚`);
                        console.log(`[å½’å¢Ÿ] å†…å®¹é‡å¤ (${message})ï¼Œè·³è¿‡å†™å…¥: ${finalEntryKey}`);

                        if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹') this.lastWrittenJourney = this.lastExtractedJourney;
                        if (baseEntryKey === 'å¾€ä¸–æ¶Ÿæ¼ª') this.lastWrittenPastLives = this.lastExtractedPastLives;

                        if (button && !silent) {
                            button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                        }
                        return; // æå‰é€€å‡ºå‡½æ•°
                    }

                    updatedContent = existingContent + (existingContent ? '\n\n' : '') + reformattedContent;
                    if (!silent) this.showTemporaryMessage(`å·²æˆåŠŸè¿½åŠ å†…å®¹åˆ°â€œ${finalEntryKey}â€`);
                }
                
                // æ ¸å¿ƒä¿®å¤ï¼šåœ¨åˆå¹¶å†…å®¹åã€å†™å…¥ä¹‹å‰æ‰§è¡Œä¿®å‰ª
                if (baseEntryKey === 'æœ¬ä¸–å†ç¨‹' && this.isAutoTrimEnabled) {
                    console.log('[å½’å¢Ÿ] è‡ªåŠ¨ä¿®å‰ªå·²å¼€å¯ï¼Œæ­£åœ¨å¤„ç†åˆå¹¶åçš„å†…å®¹...');
                    updatedContent = this._getTrimmedJourneyContent(updatedContent);
                }

                await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: updatedContent }]);
              }

              if (button && !silent) {
                button.textContent = 'å†™å…¥æˆåŠŸ';
                setTimeout(() => { button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦'; }, 2000);
              }

            } catch (error) {
              console.error(`å†™å…¥ä¸–ç•Œä¹¦ "${finalEntryKey}" æ—¶å‡ºé”™:`, error);
              if (!silent) {
                this.showTemporaryMessage(`å†™å…¥å¤±è´¥: ${error.message}`);
                if (button) button.textContent = 'å†™å…¥å¤±è´¥';
              }
            } finally {
                if (button && !silent && button.textContent === 'å†™å…¥ä¸­...') {
                    button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                }
            }
          },

          async writeCharacterCardToLorebook() {
            const content = this.lastExtractedCharacterCard;
            if (!content) {
              this.showTemporaryMessage('æ²¡æœ‰å¯å†™å…¥çš„è§’è‰²å†…å®¹ã€‚');
              return;
            }

            const button = document.getElementById('btn-write-character-card');
            if (button) button.textContent = 'å†™å…¥ä¸­...';

            try {
              const lines = content.trim().split('\n');
              const characterData = {};
              lines.forEach(line => {
                const parts = line.split('|');
                if (parts.length >= 2) {
                  const key = parts[0].trim();
                  const value = parts.slice(1).join('|').trim();
                  characterData[key] = value;
                }
              });

              const characterName = characterData['å§“å'];
              if (!characterName) {
                throw new Error('æ— æ³•ä»æå–å†…å®¹ä¸­æ‰¾åˆ°è§’è‰²â€œå§“åâ€ã€‚');
              }

              const bookName = '1å½’å¢Ÿ';
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const existingEntry = allEntries.find(entry => entry.comment === characterName);

              if (existingEntry) {
                this.showTemporaryMessage(`è§’è‰²â€œ${characterName}â€å·²å­˜åœ¨ï¼Œè¯·æ‰‹åŠ¨ä¿®æ”¹ã€‚`);
                if (button) button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
                return;
              }

              await TavernHelper.createLorebookEntries(bookName, [
                {
                  comment: characterName,
                  keys: [characterName],
                  content: content.trim(),
                  enabled: true,
                },
              ]);

              this.showTemporaryMessage(`å·²æˆåŠŸåˆ›å»ºè§’è‰²â€œ${characterName}â€ã€‚`);
              if (button) button.textContent = 'å†™å…¥æˆåŠŸ';
              setTimeout(() => {
                if (button) button.textContent = 'å†™å…¥ä¸–ç•Œä¹¦';
              }, 2000);
            } catch (error) {
              console.error('å†™å…¥è§’è‰²å¡åˆ°ä¸–ç•Œä¹¦æ—¶å‡ºé”™:', error);
              this.showTemporaryMessage(`å†™å…¥å¤±è´¥: ${error.message}`);
              if (button) button.textContent = 'å†™å…¥å¤±è´¥';
            }
          },

          async updateCurrentSceneLorebook(sceneContent) {
            // å¢åŠ å¥å£®æ€§æ£€æŸ¥ï¼Œé˜²æ­¢å†™å…¥ç©ºå†…å®¹
            if (!sceneContent || sceneContent.trim() === '') {
              console.warn('[å½’å¢Ÿ] å°è¯•å‘â€œå½“å‰åœºæ™¯â€å†™å…¥ç©ºå†…å®¹ï¼Œæ“ä½œå·²å–æ¶ˆã€‚');
              return;
            }
            const bookName = '1å½’å¢Ÿ';
            const sceneKey = 'å½“å‰åœºæ™¯';
            try {
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              const sceneEntry = allEntries.find(entry => entry.comment === sceneKey);

              if (!sceneEntry) {
                console.warn(
                  `[å½’å¢Ÿ] æœªæ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›® "${sceneKey}"ï¼Œæ— æ³•æ›´æ–°åœºæ™¯æ­£æ–‡ã€‚è¯·åœ¨'${bookName}'ä¸–ç•Œä¹¦ä¸­åˆ›å»ºå®ƒã€‚`,
                );
                // å¦‚æœæ¡ç›®ä¸å­˜åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥é€‰æ‹©åˆ›å»ºä¸€ä¸ª
                await TavernHelper.createLorebookEntries(bookName, [
                  {
                    comment: sceneKey,
                    content: sceneContent,
                    keys: [],
                  },
                ]);
                console.log(`[å½’å¢Ÿ] å·²åˆ›å»ºå¹¶æ›´æ–° "${sceneKey}" å†…å®¹ã€‚`);
                return;
              }

              // ä½¿ç”¨è¦†ç›–å¼æ›´æ–°
              await TavernHelper.setLorebookEntries(bookName, [{ uid: sceneEntry.uid, content: sceneContent }]);
              console.log(`[å½’å¢Ÿ] æˆåŠŸæ›´æ–° "${sceneKey}" å†…å®¹ã€‚`);
            } catch (error) {
              console.error(`[å½’å¢Ÿ] æ›´æ–° "${sceneKey}" æ—¶å‡ºé”™:`, error);
            }
          },

          async loadAndDisplayCurrentScene(messageContent = null) {
            const gameTextDisplay = document.getElementById('game-text-display');
            if (!gameTextDisplay) return;

            try {
              let contentToParse = messageContent;

              // å¦‚æœæ²¡æœ‰ç›´æ¥æä¾›å†…å®¹ï¼Œåˆ™ä»èŠå¤©è®°å½•ä¸­è·å–
              if (contentToParse === null) {
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) return;
                const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant');
                if (lastAiMessage) {
                  contentToParse = lastAiMessage.message;
                }
              }

              if (contentToParse) {
                // --- è¯Šæ–­æŠ¥å‘Šæ³¨å…¥ç‚¹ ---
                console.groupCollapsed('[å½’å¢ŸæŸ“è‰²è¯Šæ–­æŠ¥å‘Š]');
                console.log('1. [åŸå§‹åŠ è½½å†…å®¹]', contentToParse);

                // 1. æ›´æ–°ä¸»ç•Œé¢æ­£æ–‡ (ä½¿ç”¨æ–°çš„å¥å£®çš„æå–å‡½æ•°)
                const displayText = this._getDisplayText(contentToParse);
                console.log('2. [æå–åç”¨äºæ˜¾ç¤º]', displayText);

                const finalHTML = this.formatMessageContent(displayText);
                console.log('3. [æœ€ç»ˆæ¸²æŸ“HTML]', finalHTML);
                
                gameTextDisplay.innerHTML = finalHTML;
                this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
                console.groupEnd();
                // --- è¯Šæ–­æŠ¥å‘Šç»“æŸ ---

                // 2. åŒæ­¥æå–æ‰€æœ‰æ ‡ç­¾å†…å®¹åˆ°å˜é‡ï¼Œç”¨äºâ€œæŸ¥çœ‹æå–å†…å®¹â€æ¨¡æ€æ¡†
                this.lastExtractedNovelText = this._extractLastTagContent('gametxt', contentToParse);
                this.lastExtractedJourney = this._extractLastTagContent('æœ¬ä¸–å†ç¨‹', contentToParse);
                this.lastExtractedPastLives = this._extractLastTagContent('å¾€ä¸–æ¶Ÿæ¼ª', contentToParse);
                this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', contentToParse, true); // ignore case
                this.lastExtractedCharacterCard = this._extractLastTagContent('è§’è‰²æå–', contentToParse);
                this.lastExtractedMapCommands = this._extractLastTagContent('åœ°å›¾', contentToParse);

                // æ–°å¢ï¼šæ›´æ–°å˜é‡æ”¹å˜æé†’
                this.updateVariableChangesReminder();

                // 3. æ–°å¢ï¼šæå–å¹¶æ¸²æŸ“è¡ŒåŠ¨é€‰é¡¹
                let actionOptionsContent = this._extractLastTagContent('è¡ŒåŠ¨é€‰é¡¹', contentToParse);
                if (!actionOptionsContent) {
                   actionOptionsContent = this._extractLastTagContent('action', contentToParse);
                }
                this.renderActionOptions(actionOptionsContent);
              }
            } catch (error) {
              console.error(`[å½’å¢Ÿ] åŠ è½½å¹¶æ˜¾ç¤ºå½“å‰åœºæ™¯æ—¶å‡ºé”™:`, error);
              gameTextDisplay.innerHTML = `<gametxt>åŠ è½½åœºæ™¯æ—¶å‡ºé”™ã€‚</gametxt>`;
              this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
            }
          },

          // --- æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹æ¸²æŸ“å‡½æ•° ---
          renderActionOptions(content) {
            const container = document.getElementById('action-options-container');
            if (!container) return;

            container.innerHTML = ''; // æ¸…ç©ºæ—§é€‰é¡¹

            const hasContent = content && typeof content === 'string' && content.trim() !== '';

            // å¦‚æœå¼€å…³å…³é—­æˆ–æ²¡æœ‰æœ‰æ•ˆå†…å®¹ï¼Œåˆ™éšè—å®¹å™¨å¹¶è¿”å›
            if (!this.isActionOptionsEnabled || !hasContent) {
                container.style.display = 'none';
                return;
            }

            // æœ‰å†…å®¹åˆ™æ˜¾ç¤ºå®¹å™¨
            container.style.display = 'block';

            const lines = content.trim().split('\n');
            lines.forEach(line => {
                line = line.trim();
                const match = line.match(/^(?:\d+\.\s*)?(.+)/);
                if (match) {
                    const optionText = match[1].trim();
                    if (optionText) {
                        const btn = document.createElement('button');
                        btn.className = 'action-option-btn';
                        btn.textContent = optionText;
                        btn.dataset.actionText = optionText; // å°†é€‰é¡¹æ–‡æœ¬å­˜å…¥dataå±æ€§
                        btn.style.display = 'block';
                        btn.style.width = '100%';
                        container.appendChild(btn);
                    }
                }
            });

            // å¦‚æœè§£æåæ²¡æœ‰ç”Ÿæˆä»»ä½•æŒ‰é’®ï¼Œä¹Ÿéšè—å®¹å™¨
            if (container.childElementCount === 0) {
                container.style.display = 'none';
            }
          },

          // --- æ–°å¢ï¼šçŠ¶æ€ä¿å­˜ä¸è‡ªåŠ¨å†™å…¥é€»è¾‘ ---
          saveAutoWriteState(state) {
            try {
              localStorage.setItem('guixu_auto_write_enabled', state);
            } catch (e) {
              console.error('ä¿å­˜è‡ªåŠ¨å†™å…¥çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadAutoWriteState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_write_enabled');
              // å¦‚æœlocalStorageä¸­æ²¡æœ‰ä¿å­˜è¿‡çŠ¶æ€ï¼Œåˆ™é»˜è®¤ä¸ºtrue (å¼€å¯)
              this.isAutoWriteEnabled = savedState === null ? true : savedState === 'true';
              const checkbox = document.getElementById('auto-write-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoWriteEnabled;
              }
              // æ ¹æ®åŠ è½½çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨è½®è¯¢
              if (this.isAutoWriteEnabled) {
                this.startAutoWritePolling();
              }
            } catch (e) {
              console.error('åŠ è½½è‡ªåŠ¨å†™å…¥çŠ¶æ€å¤±è´¥:', e);
              this.isAutoWriteEnabled = false;
            }
          },

          saveNovelModeState(state) {
            try {
              localStorage.setItem('guixu_novel_mode_enabled', state);
            } catch (e) {
              console.error('ä¿å­˜å°è¯´æ¨¡å¼çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadNovelModeState() {
            try {
              const savedState = localStorage.getItem('guixu_novel_mode_enabled');
              // å°è¯´æ¨¡å¼é»˜è®¤ä¸º false (å…³é—­)
              this.isNovelModeEnabled = savedState === 'true';
              const checkbox = document.getElementById('novel-mode-enabled-checkbox');
              if (checkbox) {
                checkbox.checked = this.isNovelModeEnabled;
              }
              // æ ¹æ®åŠ è½½çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨å°è¯´æ¨¡å¼çš„è½®è¯¢
              if (this.isNovelModeEnabled) {
                this.startNovelModeAutoWritePolling();
              }
            } catch (e) {
              console.error('åŠ è½½å°è¯´æ¨¡å¼çŠ¶æ€å¤±è´¥:', e);
              this.isNovelModeEnabled = false;
            }
          },

          startAutoWritePolling() {
            this.stopAutoWritePolling();
            console.log('[å½’å¢Ÿ] å¯åŠ¨è‡ªåŠ¨å†™å…¥è½®è¯¢ (setTimeoutæ¨¡å¼)...');
            const poll = async () => {
                if (!this.isAutoWriteEnabled) return;

                // Check for new Journey content
                if (this.lastExtractedJourney && this.lastExtractedJourney !== this.lastWrittenJourney) {
                    await this.writeJourneyToLorebook(true);
                    this.lastWrittenJourney = this.lastExtractedJourney; // Mark as written
                }

                // Check for new Past Lives content
                if (this.lastExtractedPastLives && this.lastExtractedPastLives !== this.lastWrittenPastLives) {
                    await this.writePastLivesToLorebook(true);
                    this.lastWrittenPastLives = this.lastExtractedPastLives; // Mark as written
                }

                // Schedule next poll
                if (this.isAutoWriteEnabled) {
                    this.autoWriteIntervalId = setTimeout(poll, 2000);
                }
            };
            this.autoWriteIntervalId = setTimeout(poll, 2000);
          },

          stopAutoWritePolling() {
            if (this.autoWriteIntervalId) {
              console.log('[å½’å¢Ÿ] åœæ­¢è‡ªåŠ¨å†™å…¥è½®è¯¢ã€‚');
              clearTimeout(this.autoWriteIntervalId); // æ”¹ä¸º clearTimeout
              this.autoWriteIntervalId = null;
            }
          },

          // --- æ–°å¢ï¼šå°è¯´æ¨¡å¼è‡ªåŠ¨å†™å…¥è½®è¯¢ ---
          startNovelModeAutoWritePolling() {
            this.stopNovelModeAutoWritePolling();
            console.log('[å½’å¢Ÿ] å¯åŠ¨å°è¯´æ¨¡å¼è‡ªåŠ¨å†™å…¥è½®è¯¢ (setTimeoutæ¨¡å¼)...');
            const poll = async () => {
                if (!this.isNovelModeEnabled) return;

                // Check for new Novel Mode content
                if (this.lastExtractedNovelText && this.lastExtractedNovelText !== this.lastWrittenNovelText) {
                    await this.writeNovelModeToLorebook(true);
                    this.lastWrittenNovelText = this.lastExtractedNovelText; // Mark as written
                }

                if (this.isNovelModeEnabled) {
                    this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000);
                }
            };
            this.novelModeAutoWriteIntervalId = setTimeout(poll, 2000);
          },

          stopNovelModeAutoWritePolling() {
            if (this.novelModeAutoWriteIntervalId) {
              console.log('[å½’å¢Ÿ] åœæ­¢å°è¯´æ¨¡å¼è‡ªåŠ¨å†™å…¥è½®è¯¢ã€‚');
              clearTimeout(this.novelModeAutoWriteIntervalId); // æ”¹ä¸º clearTimeout
              this.novelModeAutoWriteIntervalId = null;
            }
          },

          // --- æ–°å¢ï¼šè£…å¤‡çŠ¶æ€ä¿å­˜ä¸åŠ è½½ ---
          startMapUpdatePolling() {
            this.stopMapUpdatePolling();
            console.log('[å½’å¢Ÿ] å¯åŠ¨åœ°å›¾æŒ‡ä»¤è‡ªåŠ¨è§£æè½®è¯¢ (setTimeoutæ¨¡å¼)...');
            const poll = async () => {
                if (this.lastExtractedMapCommands) {
                    await this.handleMapUpdateCommand(this.lastExtractedMapCommands);
                    this.lastExtractedMapCommands = null;
                }
                // åœ°å›¾è½®è¯¢åº”è¯¥æŒç»­è¿›è¡Œï¼Œæ‰€ä»¥ä¸éœ€è¦æ£€æŸ¥ç‰¹å®šå¼€å…³
                this.mapUpdateIntervalId = setTimeout(poll, 2500);
            };
            this.mapUpdateIntervalId = setTimeout(poll, 2500);
          },

          stopMapUpdatePolling() {
            if (this.mapUpdateIntervalId) {
              console.log('[å½’å¢Ÿ] åœæ­¢åœ°å›¾æŒ‡ä»¤è‡ªåŠ¨è§£æè½®è¯¢ã€‚');
              clearTimeout(this.mapUpdateIntervalId); // æ”¹ä¸º clearTimeout
              this.mapUpdateIntervalId = null;
            }
          },
          
          saveEquipmentState() {
            try {
              localStorage.setItem('guixu_equipped_items', JSON.stringify(this.equippedItems));
            } catch (e) {
              console.error('ä¿å­˜è£…å¤‡çŠ¶æ€å¤±è´¥:', e);
            }
          },

          // **é€»è¾‘é‡æ„**: å½»åº•ç®€åŒ–çš„åŠ è½½å‡½æ•°
          loadEquipmentState() {
            try {
              const savedState = localStorage.getItem('guixu_equipped_items');
              if (savedState) {
                const loadedItems = JSON.parse(savedState);
                if (!loadedItems) return;

                this.equippedItems = loadedItems;

                const defaultTextMap = {
                  wuqi: 'æ­¦å™¨',
                  fangju: 'é˜²å…·',
                  shipin: 'é¥°å“',
                  fabao1: 'æ³•å®',
                  zhuxiuGongfa: 'ä¸»ä¿®åŠŸæ³•',
                  fuxiuXinfa: 'è¾…ä¿®å¿ƒæ³•',
                };

                // ç›´æ¥ç”¨ localStorage çš„æ•°æ®æ¸²æŸ“UI
                for (const slotKey in defaultTextMap) {
                  const slotElement = document.getElementById(`equip-${slotKey}`);
                  if (!slotElement) continue;

                  const itemData = this.equippedItems[slotKey];

                  if (itemData && typeof itemData === 'object') {
                    const tier = this.SafeGetValue(itemData, 'tier', 'å‡¡å“');
                    const tierStyle = this.getItemTierStyle(tier);
                    slotElement.textContent = this.SafeGetValue(itemData, 'name');
                    slotElement.setAttribute('style', tierStyle);
                    slotElement.classList.add('equipped');
                    slotElement.dataset.itemDetails = JSON.stringify(itemData).replace(/'/g, "'");
                  } else {
                    slotElement.textContent = defaultTextMap[slotKey];
                    slotElement.classList.remove('equipped');
                    slotElement.removeAttribute('style');
                    delete slotElement.dataset.itemDetails;
                  }
                }
                this.updateDisplayedAttributes();
              }
            } catch (e) {
              console.error('åŠ è½½è£…å¤‡çŠ¶æ€å¤±è´¥:', e);
              localStorage.removeItem('guixu_equipped_items');
            }
          },

          savePendingActions() {
            try {
              localStorage.setItem('guixu_pending_actions', JSON.stringify(this.pendingActions));
            } catch (e) {
              console.error('ä¿å­˜æŒ‡ä»¤é˜Ÿåˆ—çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadPendingActions() {
            try {
              const savedActions = localStorage.getItem('guixu_pending_actions');
              if (savedActions) {
                this.pendingActions = JSON.parse(savedActions) || [];
              }
            } catch (e) {
              console.error('åŠ è½½æŒ‡ä»¤é˜Ÿåˆ—çŠ¶æ€å¤±è´¥:', e);
              this.pendingActions = [];
              localStorage.removeItem('guixu_pending_actions');
            }
          },
 
          // --- æ–°å¢ï¼šç»Ÿä¸€è¯»å†™åºå·å­˜å– ---
          saveUnifiedIndex() {
            try {
              localStorage.setItem('guixu_unified_index', this.unifiedIndex);
            } catch (e) {
              console.error('ä¿å­˜ç»Ÿä¸€è¯»å†™åºå·å¤±è´¥:', e);
            }
          },
 
          loadUnifiedIndex() {
            try {
              const savedIndex = localStorage.getItem('guixu_unified_index');
              if (savedIndex) {
                this.unifiedIndex = parseInt(savedIndex, 10) || 1;
              }
              const input = document.getElementById('unified-index-input');
              if (input) {
                input.value = this.unifiedIndex;
              }
            } catch (e) {
              console.error('åŠ è½½ç»Ÿä¸€è¯»å†™åºå·å¤±è´¥:', e);
              this.unifiedIndex = 1; // å‡ºé”™æ—¶é‡ç½®ä¸º1
            }
          },

          // --- æ–°å¢ï¼šå°è¯´æ¨¡å¼ç‹¬ç«‹è¯»å†™åºå·å­˜å– ---
          saveNovelModeIndex() {
           try {
             localStorage.setItem('guixu_novel_mode_index', this.novelModeIndex);
           } catch (e) {
             console.error('ä¿å­˜å°è¯´æ¨¡å¼è¯»å†™åºå·å¤±è´¥:', e);
           }
          },

          loadNovelModeIndex() {
           try {
             const savedIndex = localStorage.getItem('guixu_novel_mode_index');
             if (savedIndex) {
               this.novelModeIndex = parseInt(savedIndex, 10) || 1;
             }
             const input = document.getElementById('novel-mode-index-input');
             if (input) {
               input.value = this.novelModeIndex;
             }
           } catch (e) {
             console.error('åŠ è½½å°è¯´æ¨¡å¼è¯»å†™åºå·å¤±è´¥:', e);
             this.novelModeIndex = 1; // å‡ºé”™æ—¶é‡ç½®ä¸º1
           }
          },

          // --- æ–°å¢ï¼šå°è¯´æ¨¡å¼ç« èŠ‚å’Œä¹¦ç­¾åŠŸèƒ½ ---
          novelChapters: [], // å­˜å‚¨è§£æå‡ºçš„ç« èŠ‚ä¿¡æ¯
          novelBookmarks: [], // å­˜å‚¨ä¹¦ç­¾ä¿¡æ¯
          currentChapterIndex: 0, // å½“å‰ç« èŠ‚ç´¢å¼•
          novelDisplayMode: 'single', // æ˜¾ç¤ºæ¨¡å¼ï¼šsingle(å•ç« èŠ‚) æˆ– continuous(è¿è´¯æ˜¾ç¤º)
          novelBackgroundEnabled: false, // å°è¯´æ¨¡å¼èƒŒæ™¯å›¾å¼€å…³
          novelBackgroundOpacity: 0.3, // å°è¯´æ¨¡å¼èƒŒæ™¯é€æ˜åº¦
          novelBackgroundImage: '', // å°è¯´æ¨¡å¼èƒŒæ™¯å›¾ç‰‡URL

          // è§£æå°è¯´å†…å®¹ä¸­çš„ç« èŠ‚
          parseNovelChapters(content) {
            if (!content) return [];
            
            const chapters = [];
            const lines = content.split('\n');
            let currentChapter = null;
            let chapterContent = [];
            let lineIndex = 0;

            for (const line of lines) {
              // åŒ¹é…ç« èŠ‚æ ‡é¢˜ï¼šç¬¬xç«  æˆ– ç¬¬xå› ç­‰æ ¼å¼
              const chapterMatch = line.match(/^\s*(ç¬¬\s*[é›¶ä¸€äºŒä¸‰å››äº”å…­ä¸ƒå…«ä¹åç™¾åƒä¸‡\d]+\s*[ç« å›èŠ‚éƒ¨å·ç¯‡].*?)$/);
              
              if (chapterMatch) {
                // ä¿å­˜ä¸Šä¸€ç« èŠ‚
                if (currentChapter) {
                  currentChapter.content = chapterContent.join('\n');
                  currentChapter.endLine = lineIndex - 1;
                  chapters.push(currentChapter);
                }
                
                // å¼€å§‹æ–°ç« èŠ‚
                currentChapter = {
                  title: chapterMatch[1].trim(),
                  startLine: lineIndex,
                  endLine: -1,
                  content: ''
                };
                chapterContent = [line];
              } else if (currentChapter) {
                chapterContent.push(line);
              } else {
                // æ²¡æœ‰ç« èŠ‚æ ‡é¢˜çš„å†…å®¹ï¼Œå½’å…¥"åºç« "
                if (chapters.length === 0) {
                  chapters.push({
                    title: 'åºç« ',
                    startLine: 0,
                    endLine: -1,
                    content: ''
                  });
                  currentChapter = chapters[0];
                  chapterContent = [];
                }
                chapterContent.push(line);
              }
              lineIndex++;
            }

            // ä¿å­˜æœ€åä¸€ç« 
            if (currentChapter) {
              currentChapter.content = chapterContent.join('\n');
              currentChapter.endLine = lineIndex - 1;
              if (!chapters.includes(currentChapter)) {
                chapters.push(currentChapter);
              }
            }

            return chapters;
          },

          // ä¿å­˜ä¹¦ç­¾
          saveNovelBookmarks() {
            try {
              const key = `guixu_novel_bookmarks_${this.unifiedIndex}`;
              localStorage.setItem(key, JSON.stringify(this.novelBookmarks));
            } catch (e) {
              console.error('ä¿å­˜å°è¯´ä¹¦ç­¾å¤±è´¥:', e);
            }
          },

          // åŠ è½½ä¹¦ç­¾
          loadNovelBookmarks() {
            try {
              const key = `guixu_novel_bookmarks_${this.unifiedIndex}`;
              const saved = localStorage.getItem(key);
              this.novelBookmarks = saved ? JSON.parse(saved) : [];
            } catch (e) {
              console.error('åŠ è½½å°è¯´ä¹¦ç­¾å¤±è´¥:', e);
              this.novelBookmarks = [];
            }
          },

          // æ·»åŠ ä¹¦ç­¾
          addNovelBookmark() {
            const chapterSelect = document.getElementById('chapter-select');
            const currentChapter = chapterSelect.value;
            
            if (!currentChapter) {
              this.showTemporaryMessage('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç« èŠ‚', 'error');
              return;
            }

            const chapterTitle = chapterSelect.options[chapterSelect.selectedIndex].text;
            const timestamp = new Date().toLocaleString('zh-CN');
            
            const bookmark = {
              id: Date.now(),
              chapterIndex: parseInt(currentChapter),
              chapterTitle: chapterTitle,
              timestamp: timestamp,
              note: `${chapterTitle} - ${timestamp}`
            };

            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨ç›¸åŒç« èŠ‚çš„ä¹¦ç­¾
            const existingIndex = this.novelBookmarks.findIndex(b => b.chapterIndex === bookmark.chapterIndex);
            if (existingIndex >= 0) {
              this.novelBookmarks[existingIndex] = bookmark;
              this.showTemporaryMessage('ä¹¦ç­¾å·²æ›´æ–°');
            } else {
              this.novelBookmarks.push(bookmark);
              this.showTemporaryMessage('ä¹¦ç­¾å·²æ·»åŠ ');
            }

            this.saveNovelBookmarks();
            this.updateBookmarkSelect();
          },

          // æ›´æ–°ä¹¦ç­¾é€‰æ‹©å™¨
          updateBookmarkSelect() {
            const select = document.getElementById('bookmark-select');
            if (!select) return;

            select.innerHTML = '<option value="">é€‰æ‹©ä¹¦ç­¾...</option>';
            
            this.novelBookmarks.forEach(bookmark => {
              const option = document.createElement('option');
              option.value = bookmark.chapterIndex;
              option.textContent = bookmark.note;
              select.appendChild(option);
            });
          },

          // è·³è½¬åˆ°ä¹¦ç­¾
          gotoBookmark() {
            const bookmarkSelect = document.getElementById('bookmark-select');
            const chapterIndex = parseInt(bookmarkSelect.value);
            
            if (isNaN(chapterIndex)) {
              this.showTemporaryMessage('è¯·é€‰æ‹©ä¸€ä¸ªä¹¦ç­¾', 'error');
              return;
            }

            this.showNovelChapter(chapterIndex);
            this.showTemporaryMessage('å·²è·³è½¬åˆ°ä¹¦ç­¾ä½ç½®');
          },

          // åˆ é™¤ä¹¦ç­¾
          deleteBookmark() {
            const bookmarkSelect = document.getElementById('bookmark-select');
            const chapterIndex = parseInt(bookmarkSelect.value);
            
            if (isNaN(chapterIndex)) {
              this.showTemporaryMessage('è¯·é€‰æ‹©è¦åˆ é™¤çš„ä¹¦ç­¾', 'error');
              return;
            }

            const bookmarkIndex = this.novelBookmarks.findIndex(b => b.chapterIndex === chapterIndex);
            if (bookmarkIndex >= 0) {
              this.novelBookmarks.splice(bookmarkIndex, 1);
              this.saveNovelBookmarks();
              this.updateBookmarkSelect();
              this.showTemporaryMessage('ä¹¦ç­¾å·²åˆ é™¤');
            }
          },

          // æ˜¾ç¤ºæŒ‡å®šç« èŠ‚
          showNovelChapter(chapterIndex) {
            if (!this.novelChapters || chapterIndex >= this.novelChapters.length) return;

            const chapter = this.novelChapters[chapterIndex];
            const body = document.getElementById('novel-mode-modal-body');
            
            if (body && chapter) {
              // ä½¿ç”¨æ ¼å¼åŒ–å†…å®¹æ˜¾ç¤ºç« èŠ‚
              const formattedContent = this.formatMessageContent(chapter.content);
              
              // åˆ›å»ºç« èŠ‚å†…å®¹å®¹å™¨
              const chapterContainer = document.createElement('div');
              chapterContainer.className = 'single-chapter-container';
              chapterContainer.style.cssText = 'position: relative; min-height: 100%;';
              
              // æ·»åŠ ç« èŠ‚å†…å®¹
              chapterContainer.innerHTML = `
                <div class="game-text-container" style="white-space: pre-wrap; padding: 10px; padding-bottom: 80px;">
                  ${formattedContent}
                </div>
              `;
              
              // æ·»åŠ åº•éƒ¨å¯¼èˆªï¼ˆä»…åœ¨å•ç« èŠ‚æ¨¡å¼ä¸‹ï¼‰
              if (this.novelDisplayMode === 'single' && this.novelChapters.length > 1) {
                const bottomNav = this.createBottomChapterNav(chapterIndex);
                chapterContainer.appendChild(bottomNav);
              }
              
              body.innerHTML = '';
              body.appendChild(chapterContainer);
              
              // æ›´æ–°ç« èŠ‚é€‰æ‹©å™¨
              const chapterSelect = document.getElementById('chapter-select');
              if (chapterSelect) {
                chapterSelect.value = chapterIndex;
              }
              
              this.currentChapterIndex = chapterIndex;
              this.updateChapterNavButtons();
            }
          },

          // åˆ›å»ºåº•éƒ¨ç« èŠ‚å¯¼èˆª
          createBottomChapterNav(currentIndex) {
            const nav = document.createElement('div');
            nav.className = 'bottom-chapter-nav';
            nav.style.cssText = `
              position: absolute;
              bottom: 0;
              left: 0;
              right: 0;
              background: rgba(15, 15, 35, 0.7);
              backdrop-filter: blur(5px);
              border-top: 1px solid rgba(139, 115, 85, 0.3);
              padding: 10px 20px;
              display: flex;
              justify-content: space-between;
              align-items: center;
              opacity: 0.8;
              transition: opacity 0.3s ease;
            `;
            
            // é¼ æ ‡æ‚¬åœæ—¶å¢åŠ ä¸é€æ˜åº¦
            nav.addEventListener('mouseenter', () => {
              nav.style.opacity = '1';
            });
            nav.addEventListener('mouseleave', () => {
              nav.style.opacity = '0.8';
            });
            
            // ä¸Šä¸€ç« æŒ‰é’®
            const prevBtn = document.createElement('button');
            prevBtn.innerHTML = 'â† ä¸Šä¸€ç« ';
            prevBtn.style.cssText = `
              background: rgba(139, 115, 85, 0.8);
              color: #c9aa71;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background 0.3s ease;
            `;
            
            if (currentIndex <= 0) {
              prevBtn.disabled = true;
              prevBtn.style.opacity = '0.5';
              prevBtn.style.cursor = 'not-allowed';
            } else {
              prevBtn.addEventListener('click', () => this.prevChapter());
              prevBtn.addEventListener('mouseenter', () => {
                prevBtn.style.background = 'rgba(139, 115, 85, 1)';
              });
              prevBtn.addEventListener('mouseleave', () => {
                prevBtn.style.background = 'rgba(139, 115, 85, 0.8)';
              });
            }
            
            // ç« èŠ‚ä¿¡æ¯
            const chapterInfo = document.createElement('span');
            chapterInfo.textContent = `${currentIndex + 1} / ${this.novelChapters.length}`;
            chapterInfo.style.cssText = `
              color: #8b7355;
              font-size: 11px;
              user-select: none;
            `;
            
            // ä¸‹ä¸€ç« æŒ‰é’®
            const nextBtn = document.createElement('button');
            nextBtn.innerHTML = 'ä¸‹ä¸€ç«  â†’';
            nextBtn.style.cssText = `
              background: rgba(139, 115, 85, 0.8);
              color: #c9aa71;
              border: none;
              padding: 8px 16px;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              transition: background 0.3s ease;
            `;
            
            if (currentIndex >= this.novelChapters.length - 1) {
              nextBtn.disabled = true;
              nextBtn.style.opacity = '0.5';
              nextBtn.style.cursor = 'not-allowed';
            } else {
              nextBtn.addEventListener('click', () => this.nextChapter());
              nextBtn.addEventListener('mouseenter', () => {
                nextBtn.style.background = 'rgba(139, 115, 85, 1)';
              });
              nextBtn.addEventListener('mouseleave', () => {
                nextBtn.style.background = 'rgba(139, 115, 85, 0.8)';
              });
            }
            
            nav.appendChild(prevBtn);
            nav.appendChild(chapterInfo);
            nav.appendChild(nextBtn);
            
            return nav;
          },

          // æ›´æ–°ç« èŠ‚å¯¼èˆªæŒ‰é’®çŠ¶æ€
          updateChapterNavButtons() {
            const prevBtn = document.getElementById('prev-chapter-btn');
            const nextBtn = document.getElementById('next-chapter-btn');
            
            if (prevBtn) {
              prevBtn.disabled = this.currentChapterIndex <= 0;
              prevBtn.style.opacity = prevBtn.disabled ? '0.5' : '1';
            }
            
            if (nextBtn) {
              nextBtn.disabled = this.currentChapterIndex >= this.novelChapters.length - 1;
              nextBtn.style.opacity = nextBtn.disabled ? '0.5' : '1';
            }
          },

          // ä¸Šä¸€ç« 
          prevChapter() {
            if (this.currentChapterIndex > 0) {
              this.showNovelChapter(this.currentChapterIndex - 1);
            }
          },

          // ä¸‹ä¸€ç« 
          nextChapter() {
            if (this.currentChapterIndex < this.novelChapters.length - 1) {
              this.showNovelChapter(this.currentChapterIndex + 1);
            }
          },

          // åˆ‡æ¢æ˜¾ç¤ºæ¨¡å¼
          switchNovelDisplayMode(mode) {
            this.novelDisplayMode = mode;
            this.saveNovelDisplayMode();
            
            // æ›´æ–°å¯¼èˆªæ§ä»¶çš„æ˜¾ç¤ºçŠ¶æ€
            this.updateNovelNavControls(mode);
            
            if (mode === 'continuous') {
              this.showAllChaptersContinuous();
            } else {
              this.showNovelChapter(this.currentChapterIndex);
            }
          },

          // æ›´æ–°å°è¯´å¯¼èˆªæ§ä»¶çŠ¶æ€
          updateNovelNavControls(mode) {
            const chapterSelect = document.getElementById('chapter-select');
            const prevBtn = document.getElementById('prev-chapter-btn');
            const nextBtn = document.getElementById('next-chapter-btn');
            
            if (mode === 'continuous') {
              // è¿è´¯æ¨¡å¼ï¼šç¦ç”¨ç« èŠ‚å¯¼èˆªæ§ä»¶
              if (chapterSelect) chapterSelect.disabled = true;
              if (prevBtn) {
                prevBtn.disabled = true;
                prevBtn.style.opacity = '0.5';
              }
              if (nextBtn) {
                nextBtn.disabled = true;
                nextBtn.style.opacity = '0.5';
              }
            } else {
              // å•ç« èŠ‚æ¨¡å¼ï¼šå¯ç”¨ç« èŠ‚å¯¼èˆªæ§ä»¶
              if (chapterSelect) chapterSelect.disabled = false;
              this.updateChapterNavButtons(); // æ ¹æ®å½“å‰ç« èŠ‚æ›´æ–°æŒ‰é’®çŠ¶æ€
            }
          },

          // è¿è´¯æ˜¾ç¤ºæ‰€æœ‰ç« èŠ‚
          showAllChaptersContinuous() {
            const body = document.getElementById('novel-mode-modal-body');
            if (!body || !this.novelChapters.length) return;

            let allContent = '';
            this.novelChapters.forEach((chapter, index) => {
              // æ·»åŠ ç« èŠ‚æ ‡é¢˜é”šç‚¹ï¼Œç”¨äºä¹¦ç­¾è·³è½¬
              allContent += `<div id="chapter-anchor-${index}" class="chapter-section">`;
              
              // åœ¨è¿è´¯æ¨¡å¼ä¸‹å§‹ç»ˆæ˜¾ç¤ºç« èŠ‚æ ‡é¢˜ï¼ˆé™¤äº†åºç« ï¼‰
              if (chapter.title && chapter.title !== 'åºç« ') {
                allContent += `<h3 class="novel-chapter-title" style="
                  margin-top: ${index > 0 ? '3em' : '1em'};
                  margin-bottom: 1.5em;
                  border-bottom: 2px solid #8b7355;
                  padding-bottom: 0.8em;
                  color: #c9aa71;
                  font-weight: bold;
                  font-size: 18px;
                  text-align: center;
                  position: relative;
                ">${chapter.title}</h3>`;
              } else if (chapter.title === 'åºç« ') {
                // åºç« ä¹Ÿæ˜¾ç¤ºæ ‡é¢˜ï¼Œä½†æ ·å¼ç¨æœ‰ä¸åŒ
                allContent += `<h3 class="novel-chapter-title" style="
                  margin-top: ${index > 0 ? '2em' : '0.5em'};
                  margin-bottom: 1em;
                  border-bottom: 1px solid #8b7355;
                  padding-bottom: 0.5em;
                  color: #a0926d;
                  font-weight: normal;
                  font-size: 16px;
                  text-align: center;
                  font-style: italic;
                ">${chapter.title}</h3>`;
              }
              
              // æ£€æŸ¥å†…å®¹ç¬¬ä¸€è¡Œæ˜¯å¦é‡å¤äº†æ ‡é¢˜
              const contentLines = chapter.content.split('\n');
              const firstLine = contentLines[0]?.trim();
              const hasTitle = firstLine && chapter.title && firstLine.includes(chapter.title);
              
              // å¦‚æœå†…å®¹ç¬¬ä¸€è¡Œé‡å¤äº†æ ‡é¢˜ï¼Œåˆ™è·³è¿‡ç¬¬ä¸€è¡Œ
              const contentToShow = hasTitle ? contentLines.slice(1).join('\n') : chapter.content;
              
              // æ·»åŠ ç« èŠ‚å†…å®¹ï¼Œå¹¶åœ¨ç« èŠ‚é—´å¢åŠ é€‚å½“é—´è·
              allContent += `<div class="chapter-content" style="
                line-height: 1.8;
                margin-bottom: ${index < this.novelChapters.length - 1 ? '4em' : '2em'};
                text-indent: 2em;
              ">`;
              allContent += this.formatMessageContent(contentToShow);
              allContent += '</div>';
              allContent += '</div>';
            });

            body.innerHTML = `<div class="game-text-container continuous-reading" style="
              white-space: pre-wrap;
              padding: 20px;
              max-width: 800px;
              margin: 0 auto;
              font-size: 14px;
              line-height: 1.6;
            ">${allContent}</div>`;
            
            // æ›´æ–°å¯¼èˆªæ§ä»¶çŠ¶æ€
            this.updateNovelNavControls('continuous');
          },

          // ä¿å­˜æ˜¾ç¤ºæ¨¡å¼
          saveNovelDisplayMode() {
            try {
              localStorage.setItem('guixu_novel_display_mode', this.novelDisplayMode);
            } catch (e) {
              console.error('ä¿å­˜å°è¯´æ˜¾ç¤ºæ¨¡å¼å¤±è´¥:', e);
            }
          },

          // åŠ è½½æ˜¾ç¤ºæ¨¡å¼
          loadNovelDisplayMode() {
            try {
              const saved = localStorage.getItem('guixu_novel_display_mode');
              this.novelDisplayMode = saved || 'single';
              
              // æ›´æ–°UI
              const radios = document.querySelectorAll('input[name="novel-display-mode"]');
              radios.forEach(radio => {
                radio.checked = radio.value === this.novelDisplayMode;
              });
            } catch (e) {
              console.error('åŠ è½½å°è¯´æ˜¾ç¤ºæ¨¡å¼å¤±è´¥:', e);
              this.novelDisplayMode = 'single';
            }
          },

          // å°è¯´æ¨¡å¼èƒŒæ™¯è®¾ç½®
          showNovelBackgroundSettings() {
            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] æ‰“å¼€èƒŒæ™¯è®¾ç½®é¢æ¿');
            
            // å…ˆåŠ è½½å½“å‰è®¾ç½®
            this.loadNovelBackgroundSettings();
            
            // åˆ›å»ºå°è¯´æ¨¡å¼ä¸“ç”¨çš„èƒŒæ™¯é€‰æ‹©é¢æ¿
            const existingPanel = document.getElementById('novel-background-panel');
            if (existingPanel) {
              existingPanel.remove();
            }

            const panel = document.createElement('div');
            panel.id = 'novel-background-panel';
            panel.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background: rgba(15, 15, 35, 0.95);
              border: 2px solid #8b7355;
              border-radius: 8px;
              padding: 20px;
              z-index: 10001;
              min-width: 500px;
              max-width: 700px;
              max-height: 80vh;
              overflow-y: auto;
              box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
              backdrop-filter: blur(5px);
            `;

            panel.innerHTML = `
              <div style="color: #c9aa71; font-size: 16px; font-weight: bold; margin-bottom: 15px; text-align: center;">
                å°è¯´æ¨¡å¼èƒŒæ™¯è®¾ç½®
              </div>
              
              <!-- èƒŒæ™¯å¼€å…³ -->
              <div style="margin-bottom: 15px;">
                <label style="display: flex; align-items: center; gap: 8px; color: #c9aa71; font-size: 14px;">
                  <input type="checkbox" id="novel-bg-enabled" ${this.novelBackgroundEnabled ? 'checked' : ''}>
                  å¯ç”¨å°è¯´æ¨¡å¼èƒŒæ™¯å›¾
                </label>
              </div>
              
              <!-- é€æ˜åº¦è®¾ç½® -->
              <div style="margin-bottom: 15px;">
                <label style="color: #c9aa71; font-size: 12px; display: block; margin-bottom: 5px;">
                  èƒŒæ™¯é€æ˜åº¦: <span id="novel-bg-opacity-value">${this.novelBackgroundOpacity || 0.3}</span>
                </label>
                <input type="range" id="novel-bg-opacity" min="0.0" max="1.0" step="0.05" value="${this.novelBackgroundOpacity || 0.3}"
                       style="width: 100%; accent-color: #8b7355;">
              </div>
              
              <!-- èƒŒæ™¯å›¾é€‰æ‹©åŒºåŸŸ -->
              <div style="margin-bottom: 15px;">
                <label style="color: #c9aa71; font-size: 12px; display: block; margin-bottom: 10px;">é€‰æ‹©èƒŒæ™¯å›¾:</label>
                <div id="novel-bg-grid" style="
                  display: grid;
                  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
                  gap: 10px;
                  max-height: 300px;
                  overflow-y: auto;
                  border: 1px solid #8b7355;
                  border-radius: 4px;
                  padding: 10px;
                ">
                  <!-- èƒŒæ™¯å›¾ç½‘æ ¼å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                </div>
              </div>
              
              <!-- æŒ‰é’®ç»„ -->
              <div style="display: flex; gap: 10px; justify-content: center;">
                <button id="novel-bg-cancel" style="
                  padding: 8px 16px;
                  background: #8b7355;
                  color: #fff;
                  border: none;
                  border-radius: 4px;
                  cursor: pointer;
                  font-size: 12px;
                ">å…³é—­</button>
              </div>
            `;

            document.body.appendChild(panel);
            
            // åŠ è½½å¹¶æ˜¾ç¤ºå¯ç”¨èƒŒæ™¯å›¾
            this.loadNovelBackgroundGrid();
            
            // ç»‘å®šäº‹ä»¶
            this.bindNovelBackgroundPanelEvents(panel);
          },

          // åŠ è½½å°è¯´æ¨¡å¼èƒŒæ™¯å›¾ç½‘æ ¼
          loadNovelBackgroundGrid() {
            const grid = document.getElementById('novel-bg-grid');
            if (!grid) return;

            // å…ˆåŠ è½½èƒŒæ™¯å›¾æ•°æ®
            this.loadBackgroundSettings();

            // æ¸…ç©ºç½‘æ ¼
            grid.innerHTML = '';

            // æ·»åŠ "æ— èƒŒæ™¯"é€‰é¡¹
            const noneOption = document.createElement('div');
            noneOption.className = 'novel-bg-option';
            noneOption.dataset.bgId = '';
            noneOption.style.cssText = `
              width: 100%;
              height: 80px;
              border: 2px solid ${this.novelBackgroundImage === '' ? '#c9aa71' : '#8b7355'};
              border-radius: 4px;
              display: flex;
              align-items: center;
              justify-content: center;
              cursor: pointer;
              background: rgba(26, 26, 46, 0.8);
              color: #8b7355;
              font-size: 11px;
              transition: border-color 0.3s ease;
            `;
            noneOption.textContent = 'æ— èƒŒæ™¯';
            noneOption.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              this.selectNovelBackground('');
            });
            grid.appendChild(noneOption);

            // æ·»åŠ ç°æœ‰èƒŒæ™¯å›¾
            if (this.backgroundImages && this.backgroundImages.length > 0) {
              this.backgroundImages.forEach(bg => {
                const option = document.createElement('div');
                option.className = 'novel-bg-option';
                option.dataset.bgId = bg.id;
                option.dataset.bgUrl = bg.dataUrl || bg.url;
                option.style.cssText = `
                  width: 100%;
                  height: 80px;
                  border: 2px solid ${this.novelBackgroundImage === (bg.dataUrl || bg.url) ? '#c9aa71' : '#8b7355'};
                  border-radius: 4px;
                  background-image: url("${bg.dataUrl || bg.url}");
                  background-size: cover;
                  background-position: center;
                  cursor: pointer;
                  position: relative;
                  transition: border-color 0.3s ease;
                `;
                
                // æ·»åŠ æ ‡é¢˜è¦†ç›–å±‚
                const overlay = document.createElement('div');
                overlay.style.cssText = `
                  position: absolute;
                  bottom: 0;
                  left: 0;
                  right: 0;
                  background: rgba(0, 0, 0, 0.7);
                  color: #fff;
                  font-size: 10px;
                  padding: 2px 4px;
                  text-align: center;
                  border-radius: 0 0 2px 2px;
                  pointer-events: none;
                `;
                overlay.textContent = bg.name || `èƒŒæ™¯ ${bg.id}`;
                option.appendChild(overlay);
                
                option.addEventListener('click', (e) => {
                  e.preventDefault();
                  e.stopPropagation();
                  this.selectNovelBackground(bg.dataUrl || bg.url);
                });
                grid.appendChild(option);
              });
            }

            // å¦‚æœæ²¡æœ‰èƒŒæ™¯å›¾ï¼Œæ˜¾ç¤ºæç¤º
            if (!this.backgroundImages || this.backgroundImages.length === 0) {
              const emptyTip = document.createElement('div');
              emptyTip.style.cssText = `
                grid-column: 1 / -1;
                text-align: center;
                color: #8b7355;
                font-size: 12px;
                padding: 20px;
              `;
              emptyTip.textContent = 'æš‚æ— å¯ç”¨èƒŒæ™¯å›¾ï¼Œè¯·å…ˆåœ¨èƒŒæ™¯è®¾ç½®ä¸­æ·»åŠ èƒŒæ™¯å›¾';
              grid.appendChild(emptyTip);
            }
          },

          // é€‰æ‹©å°è¯´èƒŒæ™¯
          selectNovelBackground(bgUrl) {
            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] é€‰æ‹©èƒŒæ™¯:', bgUrl);
            this.novelBackgroundImage = bgUrl;
            
            // æ›´æ–°é€‰ä¸­çŠ¶æ€
            const options = document.querySelectorAll('.novel-bg-option');
            options.forEach(option => {
              const isSelected = (bgUrl === '' && option.dataset.bgId === '') ||
                               (bgUrl !== '' && option.dataset.bgUrl === bgUrl);
              option.style.borderColor = isSelected ? '#c9aa71' : '#8b7355';
              option.style.boxShadow = isSelected ? '0 0 10px rgba(201, 170, 113, 0.5)' : '';
            });
            
            // å®æ—¶å“åº”ï¼šç«‹å³ä¿å­˜è®¾ç½®å¹¶åº”ç”¨èƒŒæ™¯
            this.saveNovelBackgroundSettings();
            this.applyNovelBackground();
            
            // æ˜¾ç¤ºé€‰æ‹©åé¦ˆ
            this.showTemporaryMessage(`å·²é€‰æ‹©èƒŒæ™¯: ${bgUrl === '' ? 'æ— èƒŒæ™¯' : 'èƒŒæ™¯å›¾'}`);
            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯é€‰æ‹©å®Œæˆå¹¶å·²å®æ—¶åº”ç”¨');
          },

          // ç»‘å®šå°è¯´èƒŒæ™¯é¢æ¿äº‹ä»¶
          bindNovelBackgroundPanelEvents(panel) {
            const enabledCheckbox = panel.querySelector('#novel-bg-enabled');
            const opacitySlider = panel.querySelector('#novel-bg-opacity');
            const opacityValue = panel.querySelector('#novel-bg-opacity-value');
            const cancelBtn = panel.querySelector('#novel-bg-cancel');

            // å®æ—¶å“åº”ï¼šèƒŒæ™¯å¼€å…³åˆ‡æ¢äº‹ä»¶
            enabledCheckbox?.addEventListener('change', (e) => {
              this.novelBackgroundEnabled = e.target.checked;
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å®æ—¶åˆ‡æ¢èƒŒæ™¯å¼€å…³:', this.novelBackgroundEnabled);
            });

            // å®æ—¶å“åº”ï¼šé€æ˜åº¦æ»‘å—äº‹ä»¶
            opacitySlider?.addEventListener('input', (e) => {
              const value = parseFloat(e.target.value);
              opacityValue.textContent = value.toFixed(2);
              this.novelBackgroundOpacity = value;
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] å®æ—¶è°ƒæ•´é€æ˜åº¦:', value);
            });

            // å…³é—­æŒ‰é’®
            cancelBtn?.addEventListener('click', () => {
              panel.remove();
            });
          },

          // åŠ è½½å°è¯´æ¨¡å¼èƒŒæ™¯é€‰é¡¹
          loadNovelBackgroundOptions() {
            try {
              const settings = JSON.parse(localStorage.getItem('guixu_background_settings') || '{}');
              const novelSettings = JSON.parse(localStorage.getItem('guixu_novel_background_settings') || '{}');
              const select = document.getElementById('novel-bg-select');
              if (!select) return;

              // æ¸…ç©ºç°æœ‰é€‰é¡¹ï¼ˆä¿ç•™é»˜è®¤é€‰é¡¹ï¼‰
              const defaultOptions = select.querySelectorAll('option[value=""], option[value="random"]');
              select.innerHTML = '';
              defaultOptions.forEach(option => select.appendChild(option));

              // æ·»åŠ å¯ç”¨èƒŒæ™¯å›¾
              if (settings.backgrounds && settings.backgrounds.length > 0) {
                settings.backgrounds.forEach((bg, index) => {
                  const option = document.createElement('option');
                  option.value = bg;
                  option.textContent = `èƒŒæ™¯å›¾ ${index + 1}`;
                  select.appendChild(option);
                });
              }

              // è®¾ç½®å½“å‰é€‰ä¸­çš„èƒŒæ™¯
              if (novelSettings.image) {
                select.value = novelSettings.image;
              }
            } catch (e) {
              console.error('åŠ è½½èƒŒæ™¯é€‰é¡¹å¤±è´¥:', e);
            }
          },

          // ç»‘å®šå°è¯´èƒŒæ™¯è®¾ç½®äº‹ä»¶
          bindNovelBackgroundEvents(panel) {
            const enabledCheckbox = panel.querySelector('#novel-bg-enabled');
            const opacitySlider = panel.querySelector('#novel-bg-opacity');
            const opacityValue = panel.querySelector('#novel-bg-opacity-value');
            const bgSelect = panel.querySelector('#novel-bg-select');
            const preview = panel.querySelector('#novel-bg-preview');
            const applyBtn = panel.querySelector('#novel-bg-apply');
            const cancelBtn = panel.querySelector('#novel-bg-cancel');

            // é€æ˜åº¦æ»‘å—äº‹ä»¶
            opacitySlider?.addEventListener('input', (e) => {
              const value = parseFloat(e.target.value);
              opacityValue.textContent = value;
              this.updateNovelBackgroundPreview(preview, bgSelect.value, value);
            });

            // èƒŒæ™¯é€‰æ‹©äº‹ä»¶
            bgSelect?.addEventListener('change', (e) => {
              this.updateNovelBackgroundPreview(preview, e.target.value, parseFloat(opacitySlider.value));
            });

            // åº”ç”¨æŒ‰é’®
            applyBtn?.addEventListener('click', () => {
              this.novelBackgroundEnabled = enabledCheckbox.checked;
              this.novelBackgroundOpacity = parseFloat(opacitySlider.value);
              this.novelBackgroundImage = bgSelect.value;
              
              this.saveNovelBackgroundSettings();
              this.applyNovelBackground();
              
              panel.remove();
              this.showTemporaryMessage('å°è¯´èƒŒæ™¯è®¾ç½®å·²åº”ç”¨');
            });

            // å–æ¶ˆæŒ‰é’®
            cancelBtn?.addEventListener('click', () => {
              panel.remove();
            });

            // åˆå§‹é¢„è§ˆ
            this.updateNovelBackgroundPreview(preview, bgSelect.value, parseFloat(opacitySlider.value));
          },

          // æ›´æ–°èƒŒæ™¯é¢„è§ˆ
          updateNovelBackgroundPreview(preview, bgValue, opacity) {
            if (!preview) return;

            if (!bgValue || bgValue === '') {
              preview.style.backgroundImage = '';
              preview.textContent = 'æ— èƒŒæ™¯';
              return;
            }

            if (bgValue === 'random') {
              preview.style.backgroundImage = '';
              preview.textContent = 'éšæœºèƒŒæ™¯ï¼ˆåº”ç”¨æ—¶éšæœºé€‰æ‹©ï¼‰';
              return;
            }

            preview.style.backgroundImage = `url(${bgValue})`;
            preview.style.opacity = opacity;
            preview.textContent = '';
          },

          // åº”ç”¨å°è¯´æ¨¡å¼èƒŒæ™¯
          applyNovelBackground() {
            const novelModal = document.getElementById('novel-mode-modal');
            if (!novelModal) return;

            console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] åº”ç”¨èƒŒæ™¯è®¾ç½®:', {
              enabled: this.novelBackgroundEnabled,
              image: this.novelBackgroundImage,
              opacity: this.novelBackgroundOpacity
            });

            if (this.novelBackgroundEnabled && this.novelBackgroundImage) {
              // åº”ç”¨èƒŒæ™¯å›¾åˆ°æ¨¡æ€æ¡†
              novelModal.style.backgroundImage = `url(${this.novelBackgroundImage})`;
              novelModal.style.backgroundSize = 'cover';
              novelModal.style.backgroundPosition = 'center';
              novelModal.style.backgroundRepeat = 'no-repeat';
              novelModal.style.backgroundAttachment = 'fixed';
              
              // ä¿®å¤é€æ˜åº¦è®¡ç®— - è®©èƒŒæ™¯å›¾æ›´æ¸…æ™°å¯è§
              const opacity = this.novelBackgroundOpacity || 0.3;
              const modalContent = novelModal.querySelector('.modal-content');
              if (modalContent) {
                // ä½¿ç”¨æ›´åˆç†çš„é€æ˜åº¦è®¡ç®—ï¼Œç¡®ä¿èƒŒæ™¯å›¾å¯è§
                const contentOpacity = Math.max(0.7, 1 - opacity);
                modalContent.style.backgroundColor = `rgba(15, 15, 35, ${contentOpacity})`;
                modalContent.style.backdropFilter = 'blur(1px)';
                console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] è®¾ç½®å†…å®¹é€æ˜åº¦:', contentOpacity);
              }
              
              // ä¸ºæ¨¡æ€æ¡†æ·»åŠ èƒŒæ™¯é®ç½©ä»¥æé«˜å¯è¯»æ€§
              const existingOverlay = novelModal.querySelector('.novel-bg-overlay');
              if (existingOverlay) {
                existingOverlay.remove();
              }
              
              const overlay = document.createElement('div');
              overlay.className = 'novel-bg-overlay';
              overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, ${0.3 - opacity * 0.2});
                pointer-events: none;
                z-index: 1;
              `;
              novelModal.appendChild(overlay);
              
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯å›¾å·²åº”ç”¨');
            } else {
              // ç§»é™¤èƒŒæ™¯
              novelModal.style.backgroundImage = '';
              novelModal.style.backgroundAttachment = '';
              const modalContent = novelModal.querySelector('.modal-content');
              if (modalContent) {
                modalContent.style.backgroundColor = '';
                modalContent.style.backdropFilter = '';
              }
              
              // ç§»é™¤èƒŒæ™¯é®ç½©
              const existingOverlay = novelModal.querySelector('.novel-bg-overlay');
              if (existingOverlay) {
                existingOverlay.remove();
              }
              
              console.log('[å½’å¢Ÿå°è¯´èƒŒæ™¯] èƒŒæ™¯å›¾å·²ç§»é™¤');
            }
          },

          // è·å–éšæœºå°è¯´èƒŒæ™¯
          getRandomNovelBackground() {
            try {
              const settings = JSON.parse(localStorage.getItem('guixu_background_settings') || '{}');
              if (settings.backgrounds && settings.backgrounds.length > 0) {
                const randomIndex = Math.floor(Math.random() * settings.backgrounds.length);
                return settings.backgrounds[randomIndex];
              }
            } catch (e) {
              console.error('è·å–éšæœºèƒŒæ™¯å¤±è´¥:', e);
            }
            return null;
          },

          // ä¿å­˜å°è¯´èƒŒæ™¯è®¾ç½®
          saveNovelBackgroundSettings() {
            try {
              const settings = {
                enabled: this.novelBackgroundEnabled,
                opacity: this.novelBackgroundOpacity || 0.3,
                image: this.novelBackgroundImage || ''
              };
              localStorage.setItem('guixu_novel_background_settings', JSON.stringify(settings));
            } catch (e) {
              console.error('ä¿å­˜å°è¯´èƒŒæ™¯è®¾ç½®å¤±è´¥:', e);
            }
          },

          // åŠ è½½å°è¯´èƒŒæ™¯è®¾ç½®
          loadNovelBackgroundSettings() {
            try {
              const saved = localStorage.getItem('guixu_novel_background_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                this.novelBackgroundEnabled = settings.enabled || false;
                this.novelBackgroundOpacity = settings.opacity || 0.3;
                this.novelBackgroundImage = settings.image || '';
              } else {
                // å…¼å®¹æ—§ç‰ˆæœ¬è®¾ç½®
                const oldSaved = localStorage.getItem('guixu_novel_background_enabled');
                this.novelBackgroundEnabled = oldSaved === 'true';
                this.novelBackgroundOpacity = 0.3;
                this.novelBackgroundImage = '';
              }
            } catch (e) {
              console.error('åŠ è½½å°è¯´èƒŒæ™¯è®¾ç½®å¤±è´¥:', e);
              this.novelBackgroundEnabled = false;
              this.novelBackgroundOpacity = 0.3;
              this.novelBackgroundImage = '';
            }
          },
 
           // --- æ–°å¢ï¼šè‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦çŠ¶æ€å­˜å– ---
           saveAutoToggleState() {
             try {
               localStorage.setItem('guixu_auto_toggle_enabled', this.isAutoToggleLorebookEnabled);
             } catch (e) {
               console.error('ä¿å­˜è‡ªåŠ¨å¼€å…³çŠ¶æ€å¤±è´¥:', e);
             }
           },
 
           loadAutoToggleState() {
             try {
               const savedState = localStorage.getItem('guixu_auto_toggle_enabled');
               this.isAutoToggleLorebookEnabled = savedState === 'true';
               const checkbox = document.getElementById('auto-toggle-lorebook-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isAutoToggleLorebookEnabled;
               }
               // æ ¹æ®åŠ è½½çš„çŠ¶æ€å†³å®šæ˜¯å¦å¯åŠ¨è½®è¯¢
                if (this.isAutoToggleLorebookEnabled) {
                    this.startAutoTogglePolling();
                }
             } catch (e) {
               console.error('åŠ è½½è‡ªåŠ¨å¼€å…³çŠ¶æ€å¤±è´¥:', e);
               this.isAutoToggleLorebookEnabled = false;
             }
           },

           // --- æ–°å¢ï¼šä¸–ç•Œä¹¦é«˜çº§è®¾ç½®å­˜å– ---
           saveWorldbookSettings() {
             try {
               const settings = {
                 journey: {
                   position: document.getElementById('journey-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('journey-order')?.value) || 17,
                   depth: parseInt(document.getElementById('journey-depth')?.value) || 1,
                   type: document.getElementById('journey-type')?.value || 'selective',
                   enabled: document.getElementById('journey-enabled')?.checked || false
                 },
                 pastLives: {
                   position: document.getElementById('past-lives-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('past-lives-order')?.value) || 16,
                   depth: parseInt(document.getElementById('past-lives-depth')?.value) || 1,
                   type: document.getElementById('past-lives-type')?.value || 'selective',
                   enabled: document.getElementById('past-lives-enabled')?.checked || false
                 },
                 novel: {
                   position: document.getElementById('novel-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('novel-order')?.value) || 18,
                   depth: parseInt(document.getElementById('novel-depth')?.value) || 1,
                   type: document.getElementById('novel-type')?.value || 'selective',
                   enabled: document.getElementById('novel-enabled')?.checked || false
                 },
                 segmented: {
                   position: document.getElementById('segmented-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('segmented-order')?.value) || 21,
                   depth: parseInt(document.getElementById('segmented-depth')?.value) || 1,
                   type: document.getElementById('segmented-type')?.value || 'constant',
                   enabled: document.getElementById('segmented-enabled')?.checked || false
                 },
                 largeSummary: {
                   position: document.getElementById('large-summary-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('large-summary-order')?.value) || 19,
                   depth: parseInt(document.getElementById('large-summary-depth')?.value) || 1,
                   type: document.getElementById('large-summary-type')?.value || 'constant',
                   enabled: document.getElementById('large-summary-enabled')?.checked || false
                 },
                 smallSummary: {
                   position: document.getElementById('small-summary-position')?.value || 'before_character_definition',
                   order: parseInt(document.getElementById('small-summary-order')?.value) || 20,
                   depth: parseInt(document.getElementById('small-summary-depth')?.value) || 1,
                   type: document.getElementById('small-summary-type')?.value || 'constant',
                   enabled: document.getElementById('small-summary-enabled')?.checked || false
                 }
               };
               
               localStorage.setItem('guixu_worldbook_settings', JSON.stringify(settings));
               this.worldbookSettings = settings;
             } catch (e) {
               console.error('ä¿å­˜ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', e);
             }
           },

           loadWorldbookSettings() {
             try {
               const savedSettings = localStorage.getItem('guixu_worldbook_settings');
               if (savedSettings) {
                 this.worldbookSettings = JSON.parse(savedSettings);
               } else {
                 // é»˜è®¤è®¾ç½®
                 this.worldbookSettings = {
                   journey: { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false }, // æœ¬ä¸–å†ç¨‹ä½œä¸ºæ•°æ®æºï¼Œé»˜è®¤ç¦ç”¨
                   pastLives: { position: 'before_character_definition', order: 16, depth: 1, type: 'constant', enabled: true },
                   novel: { position: 'before_character_definition', order: 18, depth: 1, type: 'selective', enabled: false },
                   segmented: { position: 'before_character_definition', order: 21, depth: 1, type: 'constant', enabled: true },
                   largeSummary: { position: 'before_character_definition', order: 19, depth: 1, type: 'constant', enabled: true },
                   smallSummary: { position: 'before_character_definition', order: 20, depth: 1, type: 'constant', enabled: true },
                 };
               }
               
               // æ›´æ–°UI
               if (document.getElementById('journey-position')) {
                 document.getElementById('journey-position').value = this.worldbookSettings.journey.position;
                 document.getElementById('journey-order').value = this.worldbookSettings.journey.order;
                 document.getElementById('journey-depth').value = this.worldbookSettings.journey.depth;
                 document.getElementById('journey-type').value = this.worldbookSettings.journey.type;
                 document.getElementById('journey-enabled').checked = this.worldbookSettings.journey.enabled;
                 
                 document.getElementById('past-lives-position').value = this.worldbookSettings.pastLives.position;
                 document.getElementById('past-lives-order').value = this.worldbookSettings.pastLives.order;
                 document.getElementById('past-lives-depth').value = this.worldbookSettings.pastLives.depth;
                 document.getElementById('past-lives-type').value = this.worldbookSettings.pastLives.type;
                 document.getElementById('past-lives-enabled').checked = this.worldbookSettings.pastLives.enabled;
                 
                 document.getElementById('novel-position').value = this.worldbookSettings.novel.position;
                 document.getElementById('novel-order').value = this.worldbookSettings.novel.order;
                 document.getElementById('novel-depth').value = this.worldbookSettings.novel.depth;
                 document.getElementById('novel-type').value = this.worldbookSettings.novel.type;
                 document.getElementById('novel-enabled').checked = this.worldbookSettings.novel.enabled;

                 if(document.getElementById('segmented-position') && this.worldbookSettings.segmented) {
                   document.getElementById('segmented-position').value = this.worldbookSettings.segmented.position;
                   document.getElementById('segmented-order').value = this.worldbookSettings.segmented.order;
                   document.getElementById('segmented-depth').value = this.worldbookSettings.segmented.depth;
                   document.getElementById('segmented-type').value = this.worldbookSettings.segmented.type;
                   document.getElementById('segmented-enabled').checked = this.worldbookSettings.segmented.enabled;
                 }

                 if(document.getElementById('large-summary-position') && this.worldbookSettings.largeSummary) {
                   document.getElementById('large-summary-position').value = this.worldbookSettings.largeSummary.position;
                   document.getElementById('large-summary-order').value = this.worldbookSettings.largeSummary.order;
                   document.getElementById('large-summary-depth').value = this.worldbookSettings.largeSummary.depth;
                   document.getElementById('large-summary-type').value = this.worldbookSettings.largeSummary.type;
                   document.getElementById('large-summary-enabled').checked = this.worldbookSettings.largeSummary.enabled;
                 }

                 if(document.getElementById('small-summary-position') && this.worldbookSettings.smallSummary) {
                   document.getElementById('small-summary-position').value = this.worldbookSettings.smallSummary.position;
                   document.getElementById('small-summary-order').value = this.worldbookSettings.smallSummary.order;
                   document.getElementById('small-summary-depth').value = this.worldbookSettings.smallSummary.depth;
                   document.getElementById('small-summary-type').value = this.worldbookSettings.smallSummary.type;
                   document.getElementById('small-summary-enabled').checked = this.worldbookSettings.smallSummary.enabled;
                 }
                 
                 // æ›´æ–°æ·±åº¦è¾“å…¥æ¡†çš„ç¦ç”¨çŠ¶æ€
                 ['journey', 'past-lives', 'novel', 'segmented', 'large-summary', 'small-summary'].forEach(type => {
                   const positionSelect = document.getElementById(`${type}-position`);
                   const depthInput = document.getElementById(`${type}-depth`);
                   if (positionSelect && depthInput) {
                     depthInput.disabled = !positionSelect.value.startsWith('at_depth');
                   }
                 });
               }
             } catch (e) {
               console.error('åŠ è½½ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', e);
               this.worldbookSettings = {
                 journey: { position: 'before_character_definition', order: 17, depth: 1, logic: 'and_any' },
                 pastLives: { position: 'before_character_definition', order: 16, depth: 1, logic: 'and_any' },
                 novel: { position: 'before_character_definition', order: 18, depth: 1, logic: 'and_any' },
               };
             }
           },

           resetWorldbookSettings() {
             try {
               localStorage.removeItem('guixu_worldbook_settings');
               this.worldbookSettings = {
                 journey: { position: 'before_character_definition', order: 17, depth: 1, type: 'selective' },
                 pastLives: { position: 'before_character_definition', order: 16, depth: 1, type: 'constant' },
                 novel: { position: 'before_character_definition', order: 18, depth: 1, type: 'selective' },
                 segmented: { position: 'before_character_definition', order: 21, depth: 1, type: 'constant' },
                 largeSummary: { position: 'before_character_definition', order: 19, depth: 1, type: 'constant' },
                 smallSummary: { position: 'before_character_definition', order: 20, depth: 1, type: 'constant' },
               };
             } catch (e) {
               console.error('é‡ç½®ä¸–ç•Œä¹¦è®¾ç½®å¤±è´¥:', e);
             }
           },

           // --- æ–°å¢ï¼šè‡ªåŠ¨å¼€å…³ä¸–ç•Œä¹¦è½®è¯¢é€»è¾‘ (V2: å¢åŠ æ¡ç›®è‡ªåŠ¨åˆ›å»º) ---
          async updateAutoToggledEntries(andDisableAll = false) {
            const bookName = '1å½’å¢Ÿ';
            const index = this.unifiedIndex;
            const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
            const pastLivesKey = index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
            const segmentedKey = index > 1 ? `åˆ†æ®µæ­£æ–‡(${index})` : 'åˆ†æ®µæ­£æ–‡';
            const smallSummaryKey = index > 1 ? `å°æ€»ç»“(${index})` : 'å°æ€»ç»“';
            const largeSummaryKey = index > 1 ? `å¤§æ€»ç»“(${index})` : 'å¤§æ€»ç»“';
            try {
                let allEntries = await TavernHelper.getLorebookEntries(bookName);
                const entriesToCreate = [];

                // --- æ ¸å¿ƒä¿®å¤ï¼šæ£€æŸ¥å¹¶åˆ›å»ºç¼ºå¤±çš„æ¡ç›® ---
                const targetJourneyEntry = allEntries.find(e => e.comment === journeyKey);
                if (!targetJourneyEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'æœ¬ä¸–å†ç¨‹');
                    if (baseTemplate) {
                        // æœ€ç»ˆä¿®å¤V4ï¼šå®Œæ•´å¤åˆ¶æ¨¡æ¿å±æ€§ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½å­˜åœ¨
                        const newJourneyEntry = { ...baseTemplate };
                        delete newJourneyEntry.uid;
                        delete newJourneyEntry.display_index;
                        newJourneyEntry.comment = journeyKey;
                        newJourneyEntry.content = '';
                        newJourneyEntry.keys = [...(baseTemplate.keys || []), journeyKey];
                        const journeySettings = this.worldbookSettings?.journey || { position: 'before_character_definition', order: 17, depth: 1, type: 'selective', enabled: false };
                        newJourneyEntry.enabled = journeySettings.enabled;
                        // ç¡®ä¿è®¾ç½®æ‰€æœ‰å¿…éœ€çš„å±æ€§ï¼Œä½¿ç”¨ä¿å­˜çš„è®¾ç½®
                        newJourneyEntry.type = journeySettings.type;
                        newJourneyEntry.position = journeySettings.position;
                        newJourneyEntry.order = journeySettings.order;
                        newJourneyEntry.depth = journeySettings.position.startsWith('at_depth') ? journeySettings.depth : null;
                        newJourneyEntry.scan_depth = baseTemplate.scan_depth || 'same_as_global';
                        newJourneyEntry.case_sensitive = baseTemplate.case_sensitive || 'same_as_global';
                        newJourneyEntry.match_whole_words = baseTemplate.match_whole_words || 'same_as_global';
                        newJourneyEntry.use_group_scoring = baseTemplate.use_group_scoring || 'same_as_global';
                        newJourneyEntry.probability = baseTemplate.probability !== undefined ? baseTemplate.probability : 100;
                        newJourneyEntry.exclude_recursion = baseTemplate.exclude_recursion || false;
                        newJourneyEntry.prevent_recursion = baseTemplate.prevent_recursion || false;
                        newJourneyEntry.delay_until_recursion = baseTemplate.delay_until_recursion || false;
                        entriesToCreate.push(newJourneyEntry);
                    } else {
                        // å¦‚æœæ²¡æœ‰æ¨¡æ¿ï¼Œåˆ›å»ºä¸€ä¸ªå…¨æ–°çš„æ¡ç›®
                        console.warn('[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æœªæ‰¾åˆ°"æœ¬ä¸–å†ç¨‹"åŸºç¡€æ¨¡æ¿ï¼Œå°†åˆ›å»ºé»˜è®¤æ¡ç›®');
                        entriesToCreate.push({
                            comment: journeyKey,
                            content: '',
                            keys: [journeyKey],
                            enabled: this.worldbookSettings?.journey?.enabled || false, // æœ¬ä¸–å†ç¨‹é»˜è®¤å…³é—­
                            type: this.worldbookSettings?.journey?.type || 'selective',
                            position: this.worldbookSettings?.journey?.position || 'before_character_definition',
                            order: this.worldbookSettings?.journey?.order || 17,
                            depth: (this.worldbookSettings?.journey?.position || '').startsWith('at_depth') ? (this.worldbookSettings?.journey?.depth || 1) : null,
                            scan_depth: 'same_as_global',
                            case_sensitive: 'same_as_global',
                            match_whole_words: 'same_as_global',
                            use_group_scoring: 'same_as_global',
                            probability: 100,
                            exclude_recursion: false,
                            prevent_recursion: false,
                            delay_until_recursion: false,
                            filters: [],
                            depth: null,
                            automation_id: null,
                            group: '',
                            group_prioritized: false,
                            group_weight: 100,
                            sticky: null,
                            cooldown: null,
                            delay: null
                        });
                    }
                }

                const targetPastLivesEntry = allEntries.find(e => e.comment === pastLivesKey);
                if (!targetPastLivesEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'å¾€ä¸–æ¶Ÿæ¼ª');
                    if (baseTemplate) {
                        // æœ€ç»ˆä¿®å¤V4ï¼šå®Œæ•´å¤åˆ¶æ¨¡æ¿å±æ€§ï¼Œç¡®ä¿æ‰€æœ‰å¿…éœ€å­—æ®µéƒ½å­˜åœ¨
                        const newPastLivesEntry = { ...baseTemplate };
                        delete newPastLivesEntry.uid;
                        delete newPastLivesEntry.display_index;
                        newPastLivesEntry.comment = pastLivesKey;
                        newPastLivesEntry.content = '';
                        newPastLivesEntry.keys = [...(baseTemplate.keys || []), pastLivesKey];
                        const pastLivesSettings = this.worldbookSettings?.pastLives || { position: 'before_character_definition', order: 16, depth: 1, type: 'selective', enabled: true };
                        newPastLivesEntry.enabled = pastLivesSettings.enabled;
                        // ç¡®ä¿è®¾ç½®æ‰€æœ‰å¿…éœ€çš„å±æ€§ï¼Œä½¿ç”¨ä¿å­˜çš„è®¾ç½®
                        newPastLivesEntry.type = pastLivesSettings.type;
                        newPastLivesEntry.position = pastLivesSettings.position;
                        newPastLivesEntry.order = pastLivesSettings.order;
                        newPastLivesEntry.depth = pastLivesSettings.position.startsWith('at_depth') ? pastLivesSettings.depth : null;
                        newPastLivesEntry.scan_depth = baseTemplate.scan_depth || 'same_as_global';
                        newPastLivesEntry.case_sensitive = baseTemplate.case_sensitive || 'same_as_global';
                        newPastLivesEntry.match_whole_words = baseTemplate.match_whole_words || 'same_as_global';
                        newPastLivesEntry.use_group_scoring = baseTemplate.use_group_scoring || 'same_as_global';
                        newPastLivesEntry.probability = baseTemplate.probability !== undefined ? baseTemplate.probability : 100;
                        newPastLivesEntry.exclude_recursion = baseTemplate.exclude_recursion || false;
                        newPastLivesEntry.prevent_recursion = baseTemplate.prevent_recursion || false;
                        newPastLivesEntry.delay_until_recursion = baseTemplate.delay_until_recursion || false;
                        entriesToCreate.push(newPastLivesEntry);
                    } else {
                        // å¦‚æœæ²¡æœ‰æ¨¡æ¿ï¼Œåˆ›å»ºä¸€ä¸ªå…¨æ–°çš„æ¡ç›®
                        console.warn('[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æœªæ‰¾åˆ°"å¾€ä¸–æ¶Ÿæ¼ª"åŸºç¡€æ¨¡æ¿ï¼Œå°†åˆ›å»ºé»˜è®¤æ¡ç›®');
                        entriesToCreate.push({
                            comment: pastLivesKey,
                            content: '',
                            keys: [pastLivesKey],
                            enabled: this.worldbookSettings?.pastLives?.enabled || true,
                            type: this.worldbookSettings?.pastLives?.type || 'selective',
                            position: this.worldbookSettings?.pastLives?.position || 'before_character_definition',
                            order: this.worldbookSettings?.pastLives?.order || 16,
                            depth: (this.worldbookSettings?.pastLives?.position || '').startsWith('at_depth') ? (this.worldbookSettings?.pastLives?.depth || 1) : null,
                            scan_depth: 'same_as_global',
                            case_sensitive: 'same_as_global',
                            match_whole_words: 'same_as_global',
                            use_group_scoring: 'same_as_global',
                            probability: 100,
                            exclude_recursion: false,
                            prevent_recursion: false,
                            delay_until_recursion: false,
                            filters: [],
                            automation_id: null,
                            group: '',
                            group_prioritized: false,
                            group_weight: 100,
                            sticky: null,
                            cooldown: null,
                            delay: null
                        });
                    }
                }

               const targetSegmentedEntry = allEntries.find(e => e.comment === segmentedKey);
               if (!targetSegmentedEntry) {
                   const baseTemplate = allEntries.find(e => e.comment === 'åˆ†æ®µæ­£æ–‡');
                   const segmentedSettings = this.worldbookSettings?.segmented || { position: 'before_character_definition', order: 21, depth: 1, type: 'constant' };
                   
                   let newEntry;
                   if (baseTemplate) {
                       newEntry = { ...baseTemplate };
                       delete newEntry.uid;
                       delete newEntry.display_index;
                   } else {
                       newEntry = {
                           keys: [],
                           scan_depth: 'same_as_global',
                           case_sensitive: 'same_as_global',
                           match_whole_words: 'same_as_global',
                           use_group_scoring: 'same_as_global',
                           probability: 100,
                           exclude_recursion: false,
                           prevent_recursion: false,
                           delay_until_recursion: false,
                           filters: [],
                           automation_id: null,
                           group: '',
                           group_prioritized: false,
                           group_weight: 100,
                           sticky: null,
                           cooldown: null,
                           delay: null
                       };
                   }

                   Object.assign(newEntry, {
                       comment: segmentedKey,
                       content: 'ç­‰å¾…è‡ªåŠ¨ç”Ÿæˆ...',
                       enabled: segmentedSettings.enabled,
                       type: segmentedSettings.type,
                       position: segmentedSettings.position,
                       order: segmentedSettings.order,
                       depth: segmentedSettings.position.startsWith('at_depth') ? segmentedSettings.depth : null,
                   });

                   entriesToCreate.push(newEntry);
               }

                // æ–°å¢ï¼šæ£€æŸ¥å¹¶åˆ›å»ºå°æ€»ç»“
                const targetSmallSummaryEntry = allEntries.find(e => e.comment === smallSummaryKey);
                if (!targetSmallSummaryEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'å°æ€»ç»“');
                    const smallSummarySettings = this.worldbookSettings?.smallSummary || { position: 'before_character_definition', order: 20, depth: 1, type: 'constant' };
                    let newEntry;
                    if (baseTemplate) {
                        newEntry = { ...baseTemplate };
                        delete newEntry.uid;
                        delete newEntry.display_index;
                    } else {
                        newEntry = { keys: [], scan_depth: 'same_as_global', case_sensitive: 'same_as_global', match_whole_words: 'same_as_global', use_group_scoring: 'same_as_global', probability: 100, exclude_recursion: false, prevent_recursion: false, delay_until_recursion: false, filters: [], automation_id: null, group: '', group_prioritized: false, group_weight: 100, sticky: null, cooldown: null, delay: null };
                    }
                    Object.assign(newEntry, {
                        comment: smallSummaryKey,
                        content: 'ç­‰å¾…è‡ªåŠ¨ç”Ÿæˆ...',
                        enabled: smallSummarySettings.enabled,
                        type: smallSummarySettings.type,
                        position: smallSummarySettings.position,
                        order: smallSummarySettings.order,
                        depth: smallSummarySettings.position.startsWith('at_depth') ? smallSummarySettings.depth : null,
                    });
                    entriesToCreate.push(newEntry);
                }

                // æ–°å¢ï¼šæ£€æŸ¥å¹¶åˆ›å»ºå¤§æ€»ç»“
                const targetLargeSummaryEntry = allEntries.find(e => e.comment === largeSummaryKey);
                if (!targetLargeSummaryEntry) {
                    const baseTemplate = allEntries.find(e => e.comment === 'å¤§æ€»ç»“');
                    const largeSummarySettings = this.worldbookSettings?.largeSummary || { position: 'before_character_definition', order: 19, depth: 1, type: 'constant' };
                    let newEntry;
                    if (baseTemplate) {
                        newEntry = { ...baseTemplate };
                        delete newEntry.uid;
                        delete newEntry.display_index;
                    } else {
                        newEntry = { keys: [], scan_depth: 'same_as_global', case_sensitive: 'same_as_global', match_whole_words: 'same_as_global', use_group_scoring: 'same_as_global', probability: 100, exclude_recursion: false, prevent_recursion: false, delay_until_recursion: false, filters: [], automation_id: null, group: '', group_prioritized: false, group_weight: 100, sticky: null, cooldown: null, delay: null };
                    }
                    Object.assign(newEntry, {
                        comment: largeSummaryKey,
                        content: 'ç­‰å¾…è‡ªåŠ¨ç”Ÿæˆ...',
                        enabled: largeSummarySettings.enabled,
                        type: largeSummarySettings.type,
                        position: largeSummarySettings.position,
                        order: largeSummarySettings.order,
                        depth: largeSummarySettings.position.startsWith('at_depth') ? largeSummarySettings.depth : null,
                    });
                    entriesToCreate.push(newEntry);
                }

                if (entriesToCreate.length > 0) {
                    await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                    console.log(`[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] å·²è‡ªåŠ¨åˆ›å»º ${entriesToCreate.length} ä¸ªæ–°ä¸–ç•Œä¹¦æ¡ç›®ã€‚`);
                    // é‡æ–°è·å–æ‰€æœ‰æ¡ç›®ï¼Œä»¥åŒ…å«æ–°åˆ›å»ºçš„æ¡ç›®
                    allEntries = await TavernHelper.getLorebookEntries(bookName);
                }
                // --- ä¿®å¤ç»“æŸ ---

                const entriesToUpdate = allEntries
                    .filter(entry => entry.comment.startsWith('æœ¬ä¸–å†ç¨‹') || entry.comment.startsWith('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.startsWith('åˆ†æ®µæ­£æ–‡') || entry.comment.startsWith('å°æ€»ç»“') || entry.comment.startsWith('å¤§æ€»ç»“') || entry.comment.startsWith('å°è¯´æ¨¡å¼'))
                    .map(entry => {
                        let shouldBeEnabled;
                        if (andDisableAll) {
                            shouldBeEnabled = false;
                        } else {
                            // æ ¹æ®comment keyä»settingsä¸­æ‰¾åˆ°å¯¹åº”çš„é…ç½®å†³å®šæ˜¯å¦å¯ç”¨
                            if (entry.comment === journeyKey) shouldBeEnabled = this.worldbookSettings.journey.enabled;
                            else if (entry.comment === pastLivesKey) shouldBeEnabled = this.worldbookSettings.pastLives.enabled;
                            else if (entry.comment === segmentedKey) shouldBeEnabled = this.worldbookSettings.segmented.enabled;
                            else if (entry.comment === smallSummaryKey) shouldBeEnabled = this.worldbookSettings.smallSummary.enabled;
                            else if (entry.comment === largeSummaryKey) shouldBeEnabled = this.worldbookSettings.largeSummary.enabled;
                            else if (entry.comment === (index > 1 ? `å°è¯´æ¨¡å¼(${index})` : 'å°è¯´æ¨¡å¼')) shouldBeEnabled = this.worldbookSettings.novel.enabled;
                            else shouldBeEnabled = false; // é»˜è®¤ä¸å¯ç”¨æœªçŸ¥æ¡ç›®
                        }

                        // åªåœ¨çŠ¶æ€éœ€è¦æ”¹å˜æ—¶æ‰åŠ å…¥æ›´æ–°é˜Ÿåˆ—
                        if (entry.enabled !== shouldBeEnabled) {
                            return { uid: entry.uid, enabled: shouldBeEnabled };
                        }
                        return null;
                    }).filter(Boolean); // è¿‡æ»¤æ‰nullçš„é¡¹

                if (entriesToUpdate.length > 0) {
                    await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
                    console.log(`[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æ›´æ–°äº† ${entriesToUpdate.length} ä¸ªä¸–ç•Œä¹¦æ¡ç›®çŠ¶æ€ã€‚`);
                }
            } catch (error) {
                console.error('[å½’å¢Ÿè‡ªåŠ¨å¼€å…³] æ›´æ–°ä¸–ç•Œä¹¦æ¡ç›®çŠ¶æ€æ—¶å‡ºé”™:', error);
            }
          },

          startAutoTogglePolling() {
              this.stopAutoTogglePolling(false); // å…ˆåœæ­¢ä»»ä½•å¯èƒ½å­˜åœ¨çš„æ—§è½®è¯¢, ä½†ä¸ç¦ç”¨æ¡ç›®
              console.log('[å½’å¢Ÿ] å¯åŠ¨ä¸–ç•Œä¹¦è‡ªåŠ¨å¼€å…³è½®è¯¢...');
              this.updateAutoToggledEntries(); // ç«‹å³æ‰§è¡Œä¸€æ¬¡
              this.autoToggleIntervalId = setInterval(() => this.updateAutoToggledEntries(), 5000); // æ¯5ç§’è½®è¯¢ä¸€æ¬¡
          },

          stopAutoTogglePolling(disableEntries = true) {
              if (this.autoToggleIntervalId) {
                  console.log('[å½’å¢Ÿ] åœæ­¢ä¸–ç•Œä¹¦è‡ªåŠ¨å¼€å…³è½®è¯¢ã€‚');
                  clearInterval(this.autoToggleIntervalId);
                  this.autoToggleIntervalId = null;
              }
              if (disableEntries) {
                  // åœæ­¢æ—¶ï¼Œç¡®ä¿æ‰€æœ‰ç›¸å…³æ¡ç›®éƒ½è¢«ç¦ç”¨
                  this.updateAutoToggledEntries(true);
              }
          },

           // --- Misc ---
           applyRandomBackground() {
             const container = document.querySelector('.guixu-root-container');
             if (!container) {
               console.warn('[å½’å¢ŸèƒŒæ™¯] æ‰¾ä¸åˆ°æ ¹å®¹å™¨ï¼Œæ— æ³•åº”ç”¨èƒŒæ™¯å›¾');
               return;
             }

             console.log('[å½’å¢ŸèƒŒæ™¯] åº”ç”¨èƒŒæ™¯å›¾ï¼Œæ¨¡å¼:', this.backgroundMode, 'å›¾ç‰‡æ•°é‡:', this.backgroundImages.length);

             // å¦‚æœç”¨æˆ·æœ‰è‡ªå®šä¹‰èƒŒæ™¯å›¾ï¼Œåˆ™ä½¿ç”¨ç”¨æˆ·çš„è®¾ç½®
             if (this.backgroundImages.length > 0) {
               let backgroundToApply;
               
               if (this.backgroundMode === 'fixed' && this.selectedBackgroundId) {
                 // å›ºå®šæ¨¡å¼ï¼šä½¿ç”¨é€‰ä¸­çš„èƒŒæ™¯å›¾
                 backgroundToApply = this.backgroundImages.find(bg => bg.id === this.selectedBackgroundId);
                 if (!backgroundToApply) {
                   console.warn('[å½’å¢ŸèƒŒæ™¯] æ‰¾ä¸åˆ°é€‰ä¸­çš„èƒŒæ™¯å›¾ï¼ŒID:', this.selectedBackgroundId, 'åˆ‡æ¢åˆ°éšæœºæ¨¡å¼');
                   backgroundToApply = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)];
                 }
               } else if (this.backgroundMode === 'random') {
                 // éšæœºæ¨¡å¼ï¼šä»ç”¨æˆ·èƒŒæ™¯å›¾ä¸­éšæœºé€‰æ‹©
                 backgroundToApply = this.backgroundImages[Math.floor(Math.random() * this.backgroundImages.length)];
               }

               if (backgroundToApply && backgroundToApply.dataUrl) {
                 // æ£€æŸ¥æ˜¯å¦ä¸ºObject URLï¼ˆä»¥blob:å¼€å¤´ï¼‰
                 const isObjectUrl = backgroundToApply.dataUrl.startsWith('blob:');
                 // æ£€æŸ¥æ˜¯å¦ä¸ºå¤–é“¾å›¾ç‰‡
                 const isUrlImage = backgroundToApply.isUrlImage;
                 
                 if (isObjectUrl) {
                   console.log(`[å½’å¢ŸèƒŒæ™¯] ä½¿ç”¨Object URLèƒŒæ™¯: ${backgroundToApply.name}`);
                   // å¯¹äºObject URLï¼Œéœ€è¦éªŒè¯å…¶æœ‰æ•ˆæ€§
                   const img = new Image();
                   img.onload = () => {
                     container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                     console.log(`[å½’å¢ŸèƒŒæ™¯] æˆåŠŸåº”ç”¨Object URLèƒŒæ™¯: ${backgroundToApply.name}`);
                   };
                   img.onerror = () => {
                     console.error(`[å½’å¢ŸèƒŒæ™¯] Object URLèƒŒæ™¯æ— æ•ˆ: ${backgroundToApply.name}`);
                     this.handleInvalidBackground(backgroundToApply);
                   };
                   img.src = backgroundToApply.dataUrl;
                 } else if (isUrlImage) {
                   console.log(`[å½’å¢ŸèƒŒæ™¯] ä½¿ç”¨å¤–é“¾å›¾ç‰‡èƒŒæ™¯: ${backgroundToApply.name}`);
                   // å¯¹äºå¤–é“¾å›¾ç‰‡ï¼Œéœ€è¦éªŒè¯å…¶æœ‰æ•ˆæ€§
                   const img = new Image();
                   img.onload = () => {
                     container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                     console.log(`[å½’å¢ŸèƒŒæ™¯] æˆåŠŸåº”ç”¨å¤–é“¾èƒŒæ™¯: ${backgroundToApply.name}`);
                   };
                   img.onerror = () => {
                     console.error(`[å½’å¢ŸèƒŒæ™¯] å¤–é“¾èƒŒæ™¯æ— æ•ˆæˆ–æ— æ³•è®¿é—®: ${backgroundToApply.name}`);
                     this.handleInvalidBackground(backgroundToApply);
                   };
                   // è®¾ç½®è·¨åŸŸå±æ€§
                   img.crossOrigin = 'anonymous';
                   img.src = backgroundToApply.dataUrl;
                 } else {
                   // æ™®é€šDataURLï¼Œç›´æ¥åº”ç”¨
                   container.style.backgroundImage = `url('${backgroundToApply.dataUrl}')`;
                   console.log(`[å½’å¢ŸèƒŒæ™¯] åº”ç”¨èƒŒæ™¯: ${backgroundToApply.name} (${this.backgroundMode}æ¨¡å¼)`);
                 }
                 return;
               }
             }

             // å¦‚æœæ²¡æœ‰ç”¨æˆ·èƒŒæ™¯å›¾ï¼Œä½¿ç”¨é»˜è®¤èƒŒæ™¯
             console.log('[å½’å¢ŸèƒŒæ™¯] ä½¿ç”¨é»˜è®¤èƒŒæ™¯å›¾');
             const defaultBackgrounds = [
               'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
               'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
             ];
             const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)];
             container.style.backgroundImage = `url('${bgUrl}')`;
           },

           // æ–°å¢ï¼šå¤„ç†æ— æ•ˆèƒŒæ™¯çš„å‡½æ•°
           handleInvalidBackground(invalidBackground) {
             const bgType = invalidBackground.isUrlImage ? 'å¤–é“¾å›¾ç‰‡' :
                           invalidBackground.dataUrl.startsWith('blob:') ? 'Object URLå›¾ç‰‡' : 'æœ¬åœ°å›¾ç‰‡';
             console.warn(`[å½’å¢ŸèƒŒæ™¯] å¤„ç†æ— æ•ˆèƒŒæ™¯: ${invalidBackground.name} (${bgType})`);
             
             // æ˜¾ç¤ºç”¨æˆ·å‹å¥½çš„æç¤ºä¿¡æ¯
             if (invalidBackground.isUrlImage) {
               this.showTemporaryMessage(`å¤–é“¾å›¾ç‰‡"${invalidBackground.name}"æ— æ³•è®¿é—®ï¼Œå·²è‡ªåŠ¨ç§»é™¤`, 4000);
             }
             
             // ä»èƒŒæ™¯åˆ—è¡¨ä¸­ç§»é™¤æ— æ•ˆèƒŒæ™¯
             const index = this.backgroundImages.findIndex(bg => bg.id === invalidBackground.id);
             if (index !== -1) {
               this.backgroundImages.splice(index, 1);
               this.saveBackgroundSettings();
               console.log(`[å½’å¢ŸèƒŒæ™¯] å·²ç§»é™¤æ— æ•ˆèƒŒæ™¯: ${invalidBackground.name}`);
               
               // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„èƒŒæ™¯ï¼Œæ¸…é™¤é€‰æ‹©
               if (this.selectedBackgroundId === invalidBackground.id) {
                 this.selectedBackgroundId = null;
                 this.backgroundMode = 'random'; // åˆ‡æ¢åˆ°éšæœºæ¨¡å¼
                 this.saveBackgroundSettings();
               }
               
               // å¦‚æœè¿˜æœ‰å…¶ä»–èƒŒæ™¯ï¼Œå°è¯•åº”ç”¨ä¸€ä¸ªæ–°çš„
               if (this.backgroundImages.length > 0) {
                 this.applyRandomBackground();
               } else {
                 // æ²¡æœ‰èƒŒæ™¯äº†ï¼Œä½¿ç”¨é»˜è®¤èƒŒæ™¯
                 console.log('[å½’å¢ŸèƒŒæ™¯] æ‰€æœ‰ç”¨æˆ·èƒŒæ™¯å·²æ¸…é™¤ï¼Œä½¿ç”¨é»˜è®¤èƒŒæ™¯');
                 const container = document.querySelector('.guixu-root-container');
                 if (container) {
                   const defaultBackgrounds = [
                     'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
                     'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
                   ];
                   const bgUrl = defaultBackgrounds[Math.floor(Math.random() * defaultBackgrounds.length)];
                   container.style.backgroundImage = `url('${bgUrl}')`;
                 }
               }
               
               // åˆ·æ–°èƒŒæ™¯åˆ—è¡¨æ˜¾ç¤º
               if (document.getElementById('background-settings-modal') &&
                   document.getElementById('background-settings-modal').style.display === 'flex') {
                 this.renderBackgroundList();
                 this.updateBackgroundModeUI(); // æ›´æ–°æ¨¡å¼UI
               }
             }
           },

          // åˆå§‹åŒ–èƒŒæ™¯å›¾ç³»ç»Ÿ
          initBackgroundSystem() {
            console.log('[å½’å¢ŸèƒŒæ™¯] åˆå§‹åŒ–èƒŒæ™¯å›¾ç³»ç»Ÿ...');
            
            // é¦–å…ˆåŠ è½½èƒŒæ™¯å›¾è®¾ç½®
            this.loadBackgroundSettings();
            console.log('[å½’å¢ŸèƒŒæ™¯] å·²åŠ è½½èƒŒæ™¯å›¾è®¾ç½®ï¼Œå½“å‰å›¾ç‰‡æ•°é‡:', this.backgroundImages.length);
            
            // åŠ è½½é€æ˜åº¦è®¾ç½®
            this.loadOpacitySettings();
            console.log('[å½’å¢Ÿé€æ˜åº¦] å·²åŠ è½½é€æ˜åº¦è®¾ç½®ï¼Œå½“å‰é€æ˜åº¦:', this.mainOpacity + '%');

            // æ–‡å­—è®¾ç½®å·²åœ¨ä¸»åˆå§‹åŒ–å‡½æ•°ä¸­åŠ è½½ï¼Œæ­¤å¤„ä¸å†é‡å¤è°ƒç”¨

            // æ¸…ç†è¿‡æœŸçš„å­—ä½“ç¼“å­˜
            this.cleanupExpiredFontCache();
            
            // å¦‚æœæ²¡æœ‰ç”¨æˆ·èƒŒæ™¯å›¾ï¼Œæ·»åŠ é¢„è®¾èƒŒæ™¯å›¾
            if (this.backgroundImages.length === 0) {
              console.log('[å½’å¢ŸèƒŒæ™¯] æ²¡æœ‰ç”¨æˆ·èƒŒæ™¯å›¾ï¼Œæ·»åŠ é¢„è®¾èƒŒæ™¯å›¾');
              this.backgroundImages = [
                {
                  id: 'preset1',
                  name: 'ä»™å¢ƒäº‘æµ·',
                  dataUrl: 'https://i.postimg.cc/ZqvGBxxF/rgthree-compare-temp-hxqke-00004.png',
                  isPreset: true
                },
                {
                  id: 'preset2',
                  name: 'å¤é£å±±æ°´',
                  dataUrl: 'https://i.postimg.cc/fRP4RrmR/rgthree-compare-temp-hxqke-00002.png',
                  isPreset: true
                }
              ];
              this.saveBackgroundSettings();
              console.log('[å½’å¢ŸèƒŒæ™¯] é¢„è®¾èƒŒæ™¯å›¾å·²æ·»åŠ å¹¶ä¿å­˜');
            }
            
            // åº”ç”¨èƒŒæ™¯å›¾
            this.applyRandomBackground();
            
            console.log('[å½’å¢ŸèƒŒæ™¯] èƒŒæ™¯å›¾ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ');
          },

          async executeQuickSend() {
            const input = document.getElementById('quick-send-input');
            if (!input) return;
            const userMessage = input.value.trim();

            if (userMessage) {
                this.saveInputToHistory(userMessage); // å‘é€æ—¶ä¿å­˜åˆ°å†å²
            }

            await this.handleAction(userMessage);
          },

          // æ–°å¢ï¼šå¤„ç†æ‰€æœ‰åŠ¨ä½œçš„æ ¸å¿ƒå‡½æ•°

          async handleAction(userMessage = '') {
  
            this.lastUserMessage = userMessage; // ä¿®å¤ï¼šè®°å½•ç”¨æˆ·è¾“å…¥ä»¥è®¡ç®—æ¢¦å°˜
            const gameTextDisplay = document.getElementById('game-text-display');
              if (gameTextDisplay) {
                  this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
              }
              const thinkingDisplay = document.getElementById('thinking-content-display');
              if (thinkingDisplay) {
                  thinkingDisplay.style.display = 'none';
              }
              this.lastExtractedThinking = null;
              this.saveLastThinking(); // æ¸…é™¤æŒä¹…åŒ–å­˜å‚¨
              this.updateThinkingButtonVisibility();
              document.getElementById('action-options-container').innerHTML = ''; // éšè—è¡ŒåŠ¨é€‰é¡¹
              this.hideVariableChangesReminder(); // éšè—å˜é‡æ”¹å˜æé†’
              this.isStreamingGametxt = false; // é‡ç½®æµå¼çŠ¶æ€
              // 1. æ•´åˆè¾“å…¥
              let commandText = '';
              if (this.pendingActions.length > 0) {
                  // æ–°å¢ï¼šæ•´åˆæ‰€æœ‰å˜é‡æ›´æ–°æŒ‡ä»¤
                  let variableUpdates = [];
                  this.pendingActions.forEach(cmd => {
                      if (cmd.action === 'variable_update') {
                          variableUpdates.push(cmd.command);
                      }
                  });

                  if (variableUpdates.length > 0) {
                      commandText += '<UpdateVariable>\n' + variableUpdates.join('\n') + '\n</UpdateVariable>\n';
                  }

                  commandText += '[æœ¬è½®è¡ŒåŠ¨æŒ‡ä»¤]\n';
                  this.pendingActions.forEach(cmd => {
                     let actionText = '';
                      // ä¿®å¤ï¼šä¼˜å…ˆå¤„ç†æ— actionçš„çº¯å‘½ä»¤æŒ‡ä»¤
                      if (!cmd.action && cmd.command) {
                          actionText = cmd.command;
                      } else {
                        switch (cmd.action) {
                            case 'equip': actionText = `è£…å¤‡ [${cmd.itemName}] åˆ° [${cmd.category}] æ§½ä½ã€‚`; break;
                            case 'unequip': actionText = `å¸ä¸‹ [${cmd.itemName}] ä» [${cmd.category}] æ§½ä½ã€‚`; break;
                            case 'use': actionText = `ä½¿ç”¨ ${cmd.quantity} ä¸ª [${cmd.itemName}]ã€‚`; break;
                            case 'discard':
                              if (cmd.quantity && cmd.quantity > 1) {
                                actionText = `ä¸¢å¼ƒ ${cmd.quantity} ä¸ª [${cmd.itemName}]ã€‚`;
                              } else {
                                actionText = `ä¸¢å¼ƒ [${cmd.itemName}]ã€‚`;
                              }
                              break;
                           case 'send_as_is':
                               actionText = cmd.command;
                               break;
                       case 'join_world':
                         switch (cmd.poolType) {
                             case 'character':
                                  this.pendingCompanionJoin = { id: cmd.itemData.id, name: cmd.itemData.åç§°, rarity: cmd.itemData.ç¨€æœ‰åº¦ };
                                  this.pendingCharacterCardGeneration = cmd.itemData.åç§°;
                                  // ä¸ºè§’è‰²ç”Ÿæˆè¯¦ç»†çš„æ¨¡æ¿æŒ‡ä»¤
                                  actionText = `
[æŒ‡ä»¤]
ä¸€ä½æ–°çš„ä¼™ä¼´å³å°†åˆ°æ¥ã€‚è¯·å®Œæˆä»¥ä¸‹ä»»åŠ¡ï¼š
1.  **ã€å‰§æƒ…æ‰®æ¼”ã€‘**ï¼šåœ¨ <gametxt> æ ‡ç­¾ä¸­ï¼Œè‡ªç„¶åœ°æå†™ç¥‚çš„åˆ°æ¥ï¼Œä»¥åŠä¸â€œæˆ‘â€çš„åˆæ¬¡äº’åŠ¨ã€‚
2.  **ã€è§’è‰²å¡ç”Ÿæˆã€‘**ï¼šä¸ºäº†è®©è¿™ä¸ªè§’è‰²æ›´åŠ ä¸°æ»¡ï¼Œè¯·ä½ åŸºäºç¥‚çš„â€œè§’è‰²åŸºç¡€ä¿¡æ¯â€ï¼Œå¹¶ä¸¥æ ¼ä»¿ç…§ä¸‹æ–¹â€œè§’è‰²å¡æ¨¡æ¿èŒƒä¾‹â€çš„ã€æ·±åº¦ã€ç»†èŠ‚å’Œé£æ ¼ã€‘ï¼Œä¸ºæ–°è§’è‰²åˆ›ä½œä¸€ä»½ç‹¬ç‰¹çš„è§’è‰²è®¾å®šã€‚è¯·å°†å®Œæ•´çš„è§’è‰²å¡åŒ…è£¹åœ¨ <CharacterCard>...</CharacterCard> æ ‡ç­¾å†…ã€‚
---
### **è§’è‰²åŸºç¡€ä¿¡æ¯ (ä¸ºæ–°è§’è‰²åˆ›ä½œçš„ä¾æ®):**
* å§“åï¼š${cmd.itemData.åç§°}
* ç¨€æœ‰åº¦ï¼š${cmd.itemData.ç¨€æœ‰åº¦ || 'æœªçŸ¥'}
* ç³»åˆ—ï¼š${cmd.itemData.ç³»åˆ— || 'æœªçŸ¥'}
* æè¿°ï¼š${cmd.itemData.æè¿° || 'æš‚æ— '}
---
### **è§’è‰²å¡æ¨¡æ¿èŒƒä¾‹ (åˆ›ä½œæ—¶éœ€è¦æ¨¡ä»¿çš„é£æ ¼å’Œç»†èŠ‚):**
<CharacterCard>
{
    "ç§°å‘¼": "${cmd.itemData.åç§°}",
    "tier": "[AIç”Ÿæˆ-ä¾‹å¦‚: é‡‘ä¸¹]",
    "ç­‰çº§": "[AIç”Ÿæˆ-ä¾‹å¦‚: ä¸­æœŸ]",
    "relationship": "[AIç”Ÿæˆ-ä¾‹å¦‚: ç›Ÿå‹]",
    "favorability": "[AIç”Ÿæˆ-ä¾‹å¦‚: 60]",
    "èº«ä»½èƒŒæ™¯": "[AIç”Ÿæˆ-ä¾‹å¦‚: æ¥è‡ªæŸä¸ªéšä¸–å®—é—¨çš„çœŸä¼ å¼Ÿå­ï¼Œä¸ºå†ç»ƒçº¢å°˜ä¸‹å±±ã€‚]",
    "æ€§æ ¼": "[AIç”Ÿæˆ-ä¾‹å¦‚: å¤–è¡¨æ¸…å†·ï¼Œä¸è‹Ÿè¨€è¯­ï¼Œä½†å†…å¿ƒå–„è‰¯ï¼Œæœ‰è‡ªå·±çš„è¡Œäº‹å‡†åˆ™ã€‚]",
    "å¤–è²Œ": "[AIç”Ÿæˆ-ä¾‹å¦‚: ä¸€è¢­ç™½è¡£ï¼Œèº«èƒŒå¤å‰‘ï¼Œé¢å®¹ä¿Šæœ—ï¼Œçœ¼ç¥é”åˆ©å¦‚é¹°ã€‚]",
    "attributes": {"æ³•åŠ›": "[AIç”Ÿæˆ]", "ç¥æµ·": "[AIç”Ÿæˆ]", "é“å¿ƒ": "[AIç”Ÿæˆ]", "ç©ºé€Ÿ": "[AIç”Ÿæˆ]", "æ°”è¿": "[AIç”Ÿæˆ]"},
    "ä¸»ä¿®åŠŸæ³•": {"name": "[AIç”Ÿæˆ]", "tier": "[AIç”Ÿæˆ]", "description": "[AIç”Ÿæˆ]"},
    "event_history": {"åˆè§": "[AIç”Ÿæˆ-ä¾‹å¦‚: åœ¨ä¸‡å¦–å¤æ—ä¸­ï¼Œå› äº‰å¤ºçµè¯ä¸ä¸»è§’ç›¸è¯†ã€‚]"}
}
</CharacterCard>
`;
                                  break;
                              case 'item':
                                  // ä¸ºé“å…·ç”Ÿæˆç®€å•çš„ç³»ç»Ÿæç¤º
                                  actionText = `[ç³»ç»Ÿæç¤º] â€œæˆ‘â€é€šè¿‡è¡æ¢¦å°˜è·å¾—äº†åä¸ºã€${cmd.itemName}ã€‘çš„é“å…·ã€‚æè¿°ï¼š${cmd.itemData.æè¿°}`;
                                  break;
                              case 'talent':
                                  // ä¸ºå¤©èµ‹ç”Ÿæˆç®€å•çš„ç³»ç»Ÿæç¤º
                                  actionText = `[ç³»ç»Ÿæç¤º] â€œæˆ‘â€é€šè¿‡è¡æ¢¦å°˜è·å¾—äº†åä¸ºã€${cmd.itemName}ã€‘çš„å¤©èµ‹ã€‚æè¿°ï¼š${cmd.itemData.æè¿°}`;
                                  break;
               // æ–°å¢çš„case
                    case 'acquire_item_talent':
                        actionText = `[ç³»ç»Ÿæç¤º] â€œæˆ‘â€é€šè¿‡è¡æ¢¦å°˜è·å¾—äº†åä¸ºã€${cmd.itemName}ã€‘çš„${cmd.itemData.ç±»å‹}ã€‚æè¿°ï¼š${cmd.itemData.æè¿°}`;
                        break;
             }
                          break;
                            case 'travel': // æ–°å¢
                               actionText = `å‰å¾€åœ°ç‚¹ï¼š[${cmd.locationName}]`;
                               break;
                            case 'do_action': // æ–°å¢
                               actionText = `é€‰æ‹©è¡ŒåŠ¨ï¼š${cmd.text}`;
                               break;
                        }
                      }
                      if (actionText) {
                        commandText += `- ${actionText}\n`;
                      }
                  });
              }

              if (!userMessage && !commandText) {
                  this.showTemporaryMessage('è¯·è¾“å…¥å›å¤æˆ–æ·»åŠ æŒ‡ä»¤åå‘é€ã€‚');
                  return;
              }

              // 2. æ„å»º GenerateConfig å¯¹è±¡
              const generateConfig = {
                  injects: [],
                  should_stream: this.isStreamingEnabled, // ä¿®æ”¹ï¼šä½¿ç”¨çŠ¶æ€å˜é‡
              };

              // å°†ç”¨æˆ·è¾“å…¥å’ŒæŒ‡ä»¤åˆå¹¶ä¸ºä¸€ä¸ª user-role æ³¨å…¥
              let combinedContent = '';
              if (commandText) {
                  combinedContent += commandText + '\n'; // æŒ‡ä»¤åœ¨å‰
              }
              if (userMessage) {
                  combinedContent += `<è¡ŒåŠ¨é€‰æ‹©>\n${userMessage}\n</è¡ŒåŠ¨é€‰æ‹©>`;
              }

              if (combinedContent) {
                  generateConfig.injects.push({
                      role: 'user',
                      content: combinedContent,
                      position: 'in_chat', // æ’å…¥åˆ°èŠå¤©è®°å½•ä¸­
                      depth: 0,
                      should_scan: true, // å…è®¸æ‰«æå…³é”®å­—
                  });
              }

              this.lastSentPrompt = combinedContent; // æ›´æ–°è°ƒè¯•ä¿¡æ¯
              
              // æ–°å¢ï¼šæ§åˆ¶å°å‘é€å†…å®¹æŠ¥å‘Š
              console.group('ğŸš€ [å½’å¢Ÿ] æœ¬æ¬¡å‘é€å†…å®¹æŠ¥å‘Š');
              console.log('ğŸ“¤ å‘é€æ—¶é—´:', new Date().toLocaleString('zh-CN'));
              console.log('ğŸ¯ æµå¼æ¨¡å¼:', this.isStreamingEnabled ? 'å¼€å¯' : 'å…³é—­');
              
              if (commandText) {
                  console.log('âš¡ æŒ‡ä»¤å†…å®¹:');
                  console.log(commandText);
              }
              
              if (userMessage) {
                  console.log('ğŸ’¬ ç”¨æˆ·è¾“å…¥:');
                  console.log(userMessage);
              }
              
              console.log('ğŸ“‹ å®Œæ•´å‘é€å†…å®¹:');
              console.log(combinedContent);
              
              console.log('ğŸ”§ GenerateConfig:');
              console.log(generateConfig);
              console.groupEnd();
              
              this.showWaitingMessage();

              try {
                  // 3. è°ƒç”¨ generateï¼Œå®ƒç°åœ¨ä¸ä¼šç«‹å³è¿”å›æœ€ç»ˆç»“æœ
                  await TavernHelper.generate(generateConfig);
                  // åç»­å¤„ç†å·²ç§»è‡³ handleStreamEnd
              } catch (error) {
                  console.error('å¤„ç†åŠ¨ä½œæ—¶å‡ºé”™:', error);
                  this.showTemporaryMessage(`å’Œä¼Ÿå¤§æ¢¦æ˜Ÿæ²Ÿé€šå¤±è´¥: ${error.message}`);
                  this.hideWaitingMessage(); // ç¡®ä¿éšè—ç­‰å¾…æ¶ˆæ¯
              }
           },
 
           async handleMapUpdateCommand(commandContent) {
               console.log('[å½’å¢Ÿåœ°å›¾] æ£€æµ‹åˆ°åœ°å›¾æ›´æ–°æŒ‡ä»¤:', commandContent);
               // this.showTemporaryMessage('æ­£åœ¨æ›´æ–°ç„æ˜Šç•Œåœ°å›¾...', 2000); // ç”¨æˆ·è¦æ±‚é™é»˜å¤„ç†
 
               const bookName = '1å½’å¢Ÿ';
               const mapEntryKey = 'åœ°å›¾';
 
               try {
                   // 1. è¯»å–å½“å‰åœ°å›¾æ•°æ®
                   const allEntries = await TavernHelper.getLorebookEntries(bookName);
                   const mapEntry = allEntries.find(entry => entry.comment === mapEntryKey);
                   if (!mapEntry) {
                       throw new Error(`åœ¨ä¸–ç•Œä¹¦ "${bookName}" ä¸­æœªæ‰¾åˆ°åä¸º "${mapEntryKey}" çš„æ¡ç›®ã€‚`);
                   }
                   
                   let currentLocations = this.parseMapData(mapEntry.content || '');
                   let modified = false;

                   // 2. ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼è§£ææ‰€æœ‰æŒ‡ä»¤
                   const updateRegex = /<æ›´æ–°>([\s\S]*?)<\/æ›´æ–°>/g;
                   const addRegex = /<æ–°å¢>([\s\S]*?)<\/æ–°å¢>/g;
                   const deleteRegex = /<åˆ é™¤>([\s\S]*?)<\/åˆ é™¤>/g;
                   let match;

                   // å¤„ç†æ‰€æœ‰åˆ é™¤æŒ‡ä»¤
                   while ((match = deleteRegex.exec(commandContent)) !== null) {
                       const namesToDelete = match[1].trim().replace(/[\[\]]/g, '').split(',').map(name => name.trim());
                       const initialLength = currentLocations.length;
                       currentLocations = currentLocations.filter(loc => !namesToDelete.includes(loc.name));
                       if(currentLocations.length < initialLength) modified = true;
                       console.log('[å½’å¢Ÿåœ°å›¾] å·²åˆ é™¤:', namesToDelete);
                   }
                   
                   // å¤„ç†æ‰€æœ‰æ›´æ–°æŒ‡ä»¤
                   while ((match = updateRegex.exec(commandContent)) !== null) {
                       const updates = this.parseMapData(match[1].trim());
                       updates.forEach(update => {
                           const index = currentLocations.findIndex(loc => loc.name === update.name);
                           if (index !== -1) {
                               Object.assign(currentLocations[index], update);
                               modified = true;
                               console.log('[å½’å¢Ÿåœ°å›¾] å·²æ›´æ–°:', update);
                           }
                       });
                   }

                   // å¤„ç†æ‰€æœ‰æ–°å¢æŒ‡ä»¤
                   while ((match = addRegex.exec(commandContent)) !== null) {
                       const newLocations = this.parseMapData(match[1].trim());
                       newLocations.forEach(newLoc => {
                           if (newLoc.name && !currentLocations.some(loc => loc.name === newLoc.name)) {
                               currentLocations.push(newLoc);
                               modified = true;
                               console.log('[å½’å¢Ÿåœ°å›¾] å·²æ–°å¢:', newLoc);
                           }
                       });
                   }
                   
                   // 3. ä»…å½“æ•°æ®æœ‰å˜åŒ–æ—¶æ‰å†™å›
                   if (modified) {
                       const newContent = currentLocations.map(loc => {
                           const parts = [`${loc.name}`];
                           // ä¿è¯åæ ‡åœ¨å‰
                           if(loc.x !== undefined) parts.push(`x:${loc.x}`);
                           if(loc.y !== undefined) parts.push(`y:${loc.y}`);
                           if(loc.z !== undefined) parts.push(`z:${loc.z}`);
                           for (const [key, value] of Object.entries(loc)) {
                                if (key !== 'name' && key !== 'x' && key !== 'y' && key !== 'z' && value !== undefined) {
                                    parts.push(`${key}:${value}`);
                                }
                           }
                           return `[${parts.join('|')}]`;
                       }).join('\n');
 
                       // 4. å†™å›ä¸–ç•Œä¹¦
                       await TavernHelper.setLorebookEntries(bookName, [{ uid: mapEntry.uid, content: newContent }]);
                       // this.showTemporaryMessage('åœ°å›¾å·²æ›´æ–°ï¼'); // ç”¨æˆ·è¦æ±‚é™é»˜å¤„ç†
 
                       // 5. å¦‚æœåœ°å›¾æ˜¯æ‰“å¼€çš„ï¼Œåˆ™åˆ·æ–°å®ƒ
                       if (document.getElementById('map-modal').style.display === 'flex') {
                           const stat_data = this.currentMvuState?.stat_data;
                           const playerPos = stat_data ? this.SafeGetValue(stat_data, 'å½“å‰ä½ç½®', null) : null;
                           this.renderMap(document.getElementById('map-modal-body'), currentLocations, playerPos);
                       }
                   } else {
                       console.log('[å½’å¢Ÿåœ°å›¾] åœ°å›¾æ•°æ®æ— å˜åŒ–ï¼Œè·³è¿‡å†™å…¥ã€‚');
                   }
 
               } catch (error) {
                   console.error('å¤„ç†åœ°å›¾æ›´æ–°æŒ‡ä»¤æ—¶å‡ºé”™:', error);
                   // this.showTemporaryMessage(`åœ°å›¾æ›´æ–°å¤±è´¥: ${error.message}`); // ç”¨æˆ·è¦æ±‚é™é»˜å¤„ç†
               }
           },
 
           // --- æ–°å¢ï¼šåœ°å›¾äº¤äº’äº‹ä»¶å¤„ç† ---
            bindMapEvents(container) {
                // äº‹ä»¶ç›´æ¥ç»‘å®šåœ¨æœ€å¤–å±‚å®¹å™¨ä¸Šï¼Œä½†æ“ä½œçš„æ˜¯å†…å±‚ map-container
                const mapContainer = container.querySelector('.map-container');
                if (!mapContainer) return;

                // ä½¿ç”¨ .bind(this) ç¡®ä¿å‡½æ•°å†…çš„ this æŒ‡å‘ GuixuManager
                const handleWheel = this.handleMapWheel.bind(this);
                const handleMouseDown = this.handleMapMouseDown.bind(this);
                const handleMouseMove = this.handleMapMouseMove.bind(this);
                const handleMouseUp = this.handleMapMouseUp.bind(this);
                const handleMouseLeave = this.handleMapMouseLeave.bind(this);

                container.addEventListener('wheel', handleWheel, { passive: false });
                container.addEventListener('mousedown', handleMouseDown);
                container.addEventListener('mousemove', handleMouseMove);
                container.addEventListener('mouseup', handleMouseUp);
                container.addEventListener('mouseleave',handleMouseLeave);

                // --- æ–°å¢ï¼šä¸ºè§¦å±è®¾å¤‡æ·»åŠ äº‹ä»¶ç›‘å¬ ---
                const handleTouchStart = this.handleMapTouchStart.bind(this);
                const handleTouchMove = this.handleMapTouchMove.bind(this);
                const handleTouchEnd = this.handleMapTouchEnd.bind(this);
                container.addEventListener('touchstart', handleTouchStart, { passive: false });
                container.addEventListener('touchmove', handleTouchMove, { passive: false });
                container.addEventListener('touchend', handleTouchEnd);
                container.addEventListener('touchcancel', handleTouchEnd);


                // æ–°å¢ï¼šä¸ºç¼©æ”¾æ»‘å—ç»‘å®šäº‹ä»¶
                const zoomSlider = document.getElementById('zoom-slider');
                if (zoomSlider) {
                    zoomSlider.addEventListener('input', this.handleZoomSlider.bind(this));
                }

               // æ–°å¢ï¼šä¸ºâ€œå›åˆ°ç©å®¶â€æŒ‰é’®ç»‘å®šäº‹ä»¶
               const centerBtn = document.getElementById('btn-center-player');
               if (centerBtn) {
                   centerBtn.addEventListener('click', this.centerOnPlayer.bind(this));
               }
            },

            updateMapTransform() {
                const mapContainer = document.querySelector('#map-modal-body .map-container');
                if (mapContainer) {
                    // æ··åˆæ–¹æ¡ˆï¼šæ‹–åŠ¨ç”¨ left/topï¼Œç¼©æ”¾ç”¨ transformã€‚
                    // left/top ç”¨äºé«˜é¢‘çš„æ‹–åŠ¨äº‹ä»¶ï¼Œé¿å… transform å¯¼è‡´çš„é—ªçƒã€‚
                    // scale ç”¨äºç¼©æ”¾ã€‚æ­¤å‡½æ•°ç°åœ¨æ˜¯æ‰€æœ‰å˜æ¢çš„å”¯ä¸€æ¥æºã€‚
                    mapContainer.style.left = `${this.mapState.panX}px`;
                    mapContainer.style.top = `${this.mapState.panY}px`;
                    mapContainer.style.transform = `scale(${this.mapState.scale})`;
                }
            },
           
            resetMapState() {
                this.mapState = { scale: 1, panX: 0, panY: 0, isPanning: false, startX: 0, startY: 0, animationFrameId: null };
                this.updateMapTransform();
                this.updateZoomSliderUI();
            },

            handleMapWheel(event) {
                event.preventDefault();
                const scaleAmount = 0.1;
                const { clientX, clientY } = event;
                const containerRect = event.currentTarget.getBoundingClientRect();
                
                const mouseX = clientX - containerRect.left;
                const mouseY = clientY - containerRect.top;

                const oldScale = this.mapState.scale;
                const newScale = event.deltaY > 0
                    ? Math.max(0.05, oldScale - scaleAmount)
                    : Math.min(5, oldScale + scaleAmount);

                // è®¡ç®—ç¼©æ”¾ä¸­å¿ƒï¼Œå¹¶è°ƒæ•´panXå’ŒpanYï¼Œä½¿å…¶åœ¨è§†è§‰ä¸Šä»¥é¼ æ ‡ä¸ºä¸­å¿ƒç¼©æ”¾
                this.mapState.panX = mouseX - (mouseX - this.mapState.panX) * (newScale / oldScale);
                this.mapState.panY = mouseY - (mouseY - this.mapState.panY) * (newScale / oldScale);
                this.mapState.scale = newScale;

                this.updateMapTransform();
                this.updateZoomSliderUI(); // åŒæ­¥æ»‘å—UI
            },

            handleMapMouseDown(event) {
                event.preventDefault();
                this.mapState.isPanning = true;
                this.mapState.startX = event.clientX - this.mapState.panX;
                this.mapState.startY = event.clientY - this.mapState.panY;
            },

            handleMapMouseMove(event) {
                // æ— è®ºæ˜¯å¦åœ¨æ‹–åŠ¨ï¼Œéƒ½æ›´æ–°åæ ‡æ˜¾ç¤º
                this.updateCursorCoords(event);

                if (this.mapState.isPanning) {
                    event.preventDefault();
                    this.mapState.panX = event.clientX - this.mapState.startX;
                    this.mapState.panY = event.clientY - this.mapState.startY;
                    // ä½¿ç”¨ requestAnimationFrame ä¼˜åŒ–æ‹–åŠ¨æ€§èƒ½ï¼Œé˜²æ­¢å±é—ª
                    if (!this.mapState.animationFrameId) {
                        this.mapState.animationFrameId = requestAnimationFrame(() => {
                            this.updateMapTransform();
                            this.mapState.animationFrameId = null; // é‡ç½®IDï¼Œå…è®¸ä¸‹ä¸€æ¬¡è¯·æ±‚
                        });
                    }
                }
            },

            handleMapMouseUp(event) {
                this.mapState.isPanning = false;
                // åœæ­¢æ‹–åŠ¨æ—¶ï¼Œå–æ¶ˆä»»ä½•æŒ‚èµ·çš„åŠ¨ç”»å¸§ï¼Œä»¥é˜²æ­¢ä¸å¿…è¦çš„ä¸€æ¬¡æ€§æ›´æ–°
                if (this.mapState.animationFrameId) {
                   cancelAnimationFrame(this.mapState.animationFrameId);
                   this.mapState.animationFrameId = null;
                }
            },
            
            handleMapMouseLeave(event) {
              // é¼ æ ‡ç¦»å¼€æ—¶ï¼Œæ¸…é™¤åæ ‡æ˜¾ç¤º
              this.updateCursorCoords(event, true);

                this.mapState.isPanning = false;
                if (this.mapState.animationFrameId) {
                   cancelAnimationFrame(this.mapState.animationFrameId);
                   this.mapState.animationFrameId = null;
                }
            },

           // --- æ–°å¢ï¼šè§¦å±äº‹ä»¶å¤„ç†å‡½æ•° ---
           handleMapTouchStart(event) {
               if (event.touches.length === 1) { // åªå¤„ç†å•æŒ‡æ‹–åŠ¨
                   event.preventDefault();
                   const touch = event.touches[0];
                   this.mapState.isPanning = true;
                   this.mapState.startX = touch.clientX - this.mapState.panX;
                   this.mapState.startY = touch.clientY - this.mapState.panY;
               }
           },

           handleMapTouchMove(event) {
               if (this.mapState.isPanning && event.touches.length === 1) {
                   event.preventDefault();
                   const touch = event.touches[0];
                   this.mapState.panX = touch.clientX - this.mapState.startX;
                   this.mapState.panY = touch.clientY - this.mapState.startY;

                   if (!this.mapState.animationFrameId) {
                       this.mapState.animationFrameId = requestAnimationFrame(() => {
                           this.updateMapTransform();
                           this.mapState.animationFrameId = null;
                       });
                   }
               }
           },

           handleMapTouchEnd(event) {
               this.mapState.isPanning = false;
               if (this.mapState.animationFrameId) {
                   cancelAnimationFrame(this.mapState.animationFrameId);
                   this.mapState.animationFrameId = null;
               }
           },

            updateZoomSliderUI() {
                const slider = document.getElementById('zoom-slider');
                const display = document.getElementById('zoom-level-display');
                if (slider && display) {
                    slider.value = this.mapState.scale;
                    display.textContent = `${Math.round(this.mapState.scale * 100)}%`;
                }
            },

            handleZoomSlider(event) {
                const newScale = parseFloat(event.target.value);
                if (!isNaN(newScale)) {
                    // å½“é€šè¿‡æ»‘å—ç¼©æ”¾æ—¶ï¼Œä»¥è§†å›¾ä¸­å¿ƒä¸ºç¼©æ”¾ç‚¹
                    const containerRect = document.querySelector('#map-modal-body').getBoundingClientRect();
                    const centerX = containerRect.width / 2;
                    const centerY = containerRect.height / 2;
                    const oldScale = this.mapState.scale;
                    
                    this.mapState.panX = centerX - (centerX - this.mapState.panX) * (newScale / oldScale);
                    this.mapState.panY = centerY - (centerY - this.mapState.panY) * (newScale / oldScale);
                    this.mapState.scale = newScale;

                    this.updateMapTransform();
                    this.updateZoomSliderUI(); // ä»…æ›´æ–°ç™¾åˆ†æ¯”æ˜¾ç¤º
                }
            },

            // --- æ–°å¢ï¼šåœ°å›¾åæ ‡å’Œå±…ä¸­åŠŸèƒ½ ---
            updateCursorCoords(event, clear = false) {
               const display = document.getElementById('cursor-coords-display');
               if (!display) return;

               if (clear) {
                   display.textContent = 'x: ---, y: ---';
                   return;
               }

               const container = document.querySelector('#map-modal-body');
               const containerRect = container.getBoundingClientRect();
               const scale = this.mapState.scale;
               const panX = this.mapState.panX;
               const panY = this.mapState.panY;

               // 1. é¼ æ ‡åœ¨è§†å£ï¼ˆmap-modal-bodyï¼‰å†…çš„åæ ‡
               const mouseX = event.clientX - containerRect.left;
               const mouseY = event.clientY - containerRect.top;

               // 2. é€†å‘è®¡ç®—é¼ æ ‡åœ¨ç¼©æ”¾å‰ã€å¹³ç§»å‰çš„ä½ç½®
               const mapMouseX = (mouseX - panX) / scale;
               const mapMouseY = (mouseY - panY) / scale;

               // 3. é€†å‘è®¡ç®—ç›¸å¯¹äºåœ°å›¾ä¸­å¿ƒ (50%, 50%) çš„åç§»é‡
               const mapContainer = container.querySelector('.map-container');
               const mapRect = mapContainer.getBoundingClientRect();
               const mapCenterX = mapRect.width / 2;
               const mapCenterY = mapRect.height / 2;

               const offsetX = mapMouseX - mapCenterX;
               const offsetY = mapMouseY - mapCenterY;

               // 4. å°†åƒç´ åç§»é‡è½¬æ¢å›ä¸–ç•Œåæ ‡
               const SCALE_FACTOR = 100; // ä¸renderMapä¸­ä¿æŒä¸€è‡´
               const worldX = Math.round(offsetX * SCALE_FACTOR);
               const worldY = Math.round(offsetY * SCALE_FACTOR);

               display.textContent = `x: ${worldX}, y: ${worldY}`;
            },

            centerOnPlayer() {
               if (!this.mapState.playerMapPos) {
                   this.showTemporaryMessage("æœªæ‰¾åˆ°ç©å®¶å½“å‰ä½ç½®ã€‚");
                   return;
               }

               const container = document.querySelector('#map-modal-body');
               const containerRect = container.getBoundingClientRect();
               const targetScale = 1.0; // å›åˆ°100%ç¼©æ”¾

               // ç›®æ ‡ï¼šå°† this.mapState.playerMapPos (ç©å®¶åƒç´ åæ ‡) ç§»åŠ¨åˆ°è§†å£ä¸­å¿ƒ
               const targetX = containerRect.width / 2;
               const targetY = containerRect.height / 2;

               // è®¡ç®—éœ€è¦çš„ panX å’Œ panY
               // panX = targetX - (playerX * scale)
               // panY = targetY - (playerY * scale)
               this.mapState.scale = targetScale;
               this.mapState.panX = targetX - (this.mapState.playerMapPos.x * targetScale);
               this.mapState.panY = targetY - (this.mapState.playerMapPos.y * targetScale);

               this.updateMapTransform();
               this.updateZoomSliderUI();
               this.showTemporaryMessage("å·²å›åˆ°å½“å‰ä½ç½®");
            },

            addTravelAction(location) {
               if (!location || !location.name) return;
               
               // æ·»åŠ åˆ°æŒ‡ä»¤é˜Ÿåˆ—
               this.pendingActions.push({
                   action: 'travel',
                   locationName: location.name,
               });

               this.savePendingActions();
               this.showTemporaryMessage(`å·²å°† [å‰å¾€ ${location.name}] åŠ å…¥æŒ‡ä»¤ä¸­å¿ƒ`);
               this.closeAllModals(); // å…³é—­åœ°å›¾ï¼Œè¿”å›ä¸»ç•Œé¢
            },

           // --- æ–°å¢ï¼šå¿«é€ŸæŒ‡ä»¤åˆ—è¡¨ç›¸å…³å‡½æ•° ---
           toggleQuickCommands() {
             const popup = document.getElementById('quick-command-popup');
            if (!popup) return;

            if (popup.style.display === 'block') {
              this.hideQuickCommands();
            } else {
              this.showQuickCommands();
            }
          },

      // ç»Ÿä¸€çš„æŒ‡ä»¤æ–‡æœ¬æ ¼å¼åŒ–å‡½æ•° (v3 - ä¿®å¤è¯­æ³•é”™è¯¯)
          _formatActionText(cmd) {
              if (!cmd) return '';
              let actionText = '';
              switch (cmd.action) {
                  case 'equip': actionText = `[è£…å¤‡] ${cmd.itemName} åˆ° ${cmd.category}`; break;
                  case 'unequip': actionText = `[å¸ä¸‹] ${cmd.itemName} ä» ${cmd.category}`; break;
                  case 'use': actionText = `[ä½¿ç”¨] ${cmd.itemName} x ${cmd.quantity}`; break;
                  case 'discard': actionText = `[ä¸¢å¼ƒ] ${cmd.quantity ? cmd.quantity + ' ä¸ª ' : ''}${cmd.itemName}`; break;
                  case 'join_world': actionText = `[åŠ å…¥ä¸–ç•Œ] è§’è‰²: ${cmd.itemName}`; break;
                  case 'acquire_item_talent':
                      const type = cmd.itemData && cmd.itemData.ç±»å‹ ? cmd.itemData.ç±»å‹ : 'ç‰©å“';
                      actionText = `[è·å¾—] ${type}: ${cmd.itemName}`;
                      break;
                  case 'travel': actionText = `[å‰å¾€] åœ°ç‚¹: ${cmd.locationName}`; break;
                  case 'do_action': actionText = `[è¡ŒåŠ¨] ${cmd.text}`; break;
                  case 'variable_update': actionText = cmd.text; break;
                  case 'send_as_is': actionText = cmd.text; break; // æ–°å¢ï¼šå¤„ç†å½’å¢Ÿç©ºé—´è´­ä¹°æŒ‡ä»¤
              }

              if (!actionText) {
                  actionText = `[æœªçŸ¥æŒ‡ä»¤] ${cmd.action || 'æ— ç±»å‹'}`;
              }
              return actionText;
          },
    showQuickCommands() {
              const popup = document.getElementById('quick-command-popup');
              if (!popup) return;
              if (this.pendingActions.length === 0) {
                  popup.innerHTML = '<div class="quick-command-empty">æš‚æ— å¾…æ‰§è¡Œçš„æŒ‡ä»¤</div>';
              } else {
                  let listHtml = '<ul class="quick-command-list">';
                  this.pendingActions.forEach(cmd => {
                      const actionText = this._formatActionText(cmd); // æ ¸å¿ƒä¿®å¤ï¼šè°ƒç”¨ç»Ÿä¸€çš„æ ¼å¼åŒ–å‡½æ•°
                      if (actionText) {
                          listHtml += `<li class="quick-command-item">${actionText}</li>`;
                      }
                  });
                  listHtml += '</ul>';
                  popup.innerHTML = listHtml;
              }
              popup.style.display = 'block';
          },

          hideQuickCommands() {
            const popup = document.getElementById('quick-command-popup');
            if (popup) {
              popup.style.display = 'none';
            }
          },

          // --- æ•°æ®ç»“æ„ä¿®å¤å‡½æ•°ï¼šé˜²æ­¢é‡å¤åµŒå¥— ---
          _fixNestedStructure(obj, path = '', visited = new Set()) {
              if (!obj || typeof obj !== 'object') return obj;
              
              // é˜²æ­¢æ— é™é€’å½’
              const objKey = `${path}:${JSON.stringify(obj)}`;
              if (visited.has(objKey)) {
                  console.warn(`[å½’å¢Ÿ-ç»“æ„ä¿®å¤] æ£€æµ‹åˆ°å¾ªç¯å¼•ç”¨ï¼Œè·³è¿‡è·¯å¾„: ${path}`);
                  return obj;
              }
              visited.add(objKey);
              
              // ç‰¹åˆ«å¤„ç†äººç‰©å…³ç³»åˆ—è¡¨çš„é‡å¤åµŒå¥—é—®é¢˜
              if (path === 'äººç‰©å…³ç³»åˆ—è¡¨' || path.endsWith('.äººç‰©å…³ç³»åˆ—è¡¨')) {
                  return this._fixRelationshipNesting(obj, path, visited);
              }
              
              // é€’å½’å¤„ç†å¯¹è±¡çš„æ‰€æœ‰å±æ€§
              if (_.isObject(obj) && !Array.isArray(obj)) {
                  const fixed = {};
                  for (const [key, value] of Object.entries(obj)) {
                      const newPath = path ? `${path}.${key}` : key;
                      fixed[key] = this._fixNestedStructure(value, newPath, visited);
                  }
                  return fixed;
              }
              
              // é€’å½’å¤„ç†æ•°ç»„
              if (Array.isArray(obj)) {
                  return obj.map((item, index) => {
                      const newPath = `${path}[${index}]`;
                      return this._fixNestedStructure(item, newPath, visited);
                  });
              }
              
              return obj;
          },

          // --- ä¸“é—¨ä¿®å¤äººç‰©å…³ç³»åˆ—è¡¨åµŒå¥—é—®é¢˜ ---
          _fixRelationshipNesting(relationships, path, visited) {
              if (!relationships || typeof relationships !== 'object') return relationships;
              
              const fixed = {};
              
              for (const [personName, personData] of Object.entries(relationships)) {
                  if (!personData || typeof personData !== 'object') {
                      fixed[personName] = personData;
                      continue;
                  }
                  
                  // æ£€æŸ¥æ˜¯å¦å­˜åœ¨é‡å¤çš„äººç‰©å…³ç³»åˆ—è¡¨åµŒå¥—
                  if (personData.äººç‰©å…³ç³»åˆ—è¡¨) {
                      console.warn(`[å½’å¢Ÿ-ç»“æ„ä¿®å¤] æ£€æµ‹åˆ°äººç‰© ${personName} å­˜åœ¨é‡å¤çš„äººç‰©å…³ç³»åˆ—è¡¨åµŒå¥—ï¼Œæ­£åœ¨ä¿®å¤...`);
                      
                      // ç§»é™¤åµŒå¥—çš„äººç‰©å…³ç³»åˆ—è¡¨ï¼Œä¿ç•™å…¶ä»–å±æ€§
                      const cleanedPersonData = { ...personData };
                      delete cleanedPersonData.äººç‰©å…³ç³»åˆ—è¡¨;
                      fixed[personName] = cleanedPersonData;
                  } else {
                      // é€’å½’å¤„ç†äººç‰©æ•°æ®çš„å…¶ä»–å±æ€§
                      const cleanedPersonData = {};
                      for (const [key, value] of Object.entries(personData)) {
                          const newPath = `${path}.${personName}.${key}`;
                          cleanedPersonData[key] = this._fixNestedStructure(value, newPath, visited);
                      }
                      fixed[personName] = cleanedPersonData;
                  }
              }
              
              return fixed;
          },

          // --- æ·±åº¦æ£€æµ‹å’Œä¿®å¤MVUçŠ¶æ€æ•°æ® ---
          _deepFixMvuState(mvuState) {
              if (!mvuState || typeof mvuState !== 'object') {
                  return mvuState;
              }

              console.log('[å½’å¢Ÿ-æ·±åº¦ä¿®å¤] å¼€å§‹æ·±åº¦ä¿®å¤MVUçŠ¶æ€æ•°æ®...');
              
              try {
                  // ä½¿ç”¨ç°æœ‰çš„ç»“æ„ä¿®å¤å‡½æ•°ï¼Œå¢åŠ æ·±åº¦é™åˆ¶
                  const fixedState = this._fixNestedStructure(mvuState, '', new Set());
                  console.log('[å½’å¢Ÿ-æ·±åº¦ä¿®å¤] MVUçŠ¶æ€æ•°æ®ä¿®å¤å®Œæˆ');
                  return fixedState;
              } catch (error) {
                  console.error('[å½’å¢Ÿ-æ·±åº¦ä¿®å¤] ä¿®å¤è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
                  return mvuState; // è¿”å›åŸå§‹æ•°æ®
              }
          },

          // --- å®‰å…¨çš„æ•°æ®åŠ è½½å’Œä¿®å¤ ---
          _safeLoadMvuData(rawData) {
              if (!rawData) return null;
              
              try {
                  // é¦–å…ˆè¿›è¡Œæ·±åº¦ä¿®å¤
                  const fixedData = this._deepFixMvuState(rawData);
                  
                  // éªŒè¯å…³é”®æ•°æ®ç»“æ„
                  if (fixedData && fixedData.stat_data) {
                      console.log('[å½’å¢Ÿ-å®‰å…¨åŠ è½½] MVUæ•°æ®åŠ è½½å’Œä¿®å¤æˆåŠŸ');
                      return fixedData;
                  } else {
                      console.warn('[å½’å¢Ÿ-å®‰å…¨åŠ è½½] ä¿®å¤åçš„æ•°æ®ç¼ºå°‘å…³é”®ç»“æ„');
                      return rawData;
                  }
              } catch (error) {
                  console.error('[å½’å¢Ÿ-å®‰å…¨åŠ è½½] æ•°æ®åŠ è½½ä¿®å¤å¤±è´¥:', error);
                  return rawData;
              }
          },

          // --- æ ¸å¿ƒé‡æ„ï¼šå‰ç«¯å¤‡ç”¨MVUå¤„ç†å™¨ï¼ˆå·²ä¿®å¤åµŒå¥—é—®é¢˜ï¼‰---
          // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
          _applyUpdateFallback(script, currentMvuState) {
              if (!script || !currentMvuState) return null;
              
              const newState = _.cloneDeep(currentMvuState);
              let modified = false;

              const commands = this._extractCommands(script);

              for (const command of commands) {
                  try {
                      const path = this._trimQuotes(command.args[0]);
                      
                      switch (command.command) {
                          case 'set': {
                              const newValueStr = command.args.length >= 2 ? command.args[1] : undefined;
                              if(newValueStr === undefined) continue;
                              let newValue = this._parseCommandValue(newValueStr);
                              
                              if (newValue instanceof Date) newValue = newValue.toISOString();

                              _.set(newState.stat_data, path, newValue);
                              modified = true;
                              break;
                          }
                          case 'add': {
                              const value = _.get(newState.stat_data, path);
                              const delta = this._parseCommandValue(command.args[1]);
                              if (typeof value === 'number' && typeof delta === 'number') {
                                  _.set(newState.stat_data, path, value + delta);
                                  modified = true;
                              }
                              break;
                          }
                          case 'remove': {
                              _.unset(newState.stat_data, path);
                              modified = true;
                              break;
                          }
                          case 'assign':
                          case 'insert': {
                              if (command.args.length === 2) {
                                  // Handles _.assign('path', value)
                                  const valueToAssign = this._parseCommandValue(command.args[1]);
                                  const parentCollection = _.get(newState.stat_data, path);

                                  // Special handling for our [data_array, "description"] structure
                                  if (Array.isArray(parentCollection) && parentCollection.length === 2 && Array.isArray(parentCollection[0]) && typeof parentCollection[1] === 'string') {
                                      const innerArray = parentCollection[0];
                                      const description = parentCollection[1];
                                      const newInnerArray = innerArray.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      const newParentArray = [newInnerArray, description];
                                      _.set(newState.stat_data, path, newParentArray);
                                      modified = true;
                                  } else if (Array.isArray(parentCollection)) {
                                      // Standard immutable update for regular arrays
                                      const newCollection = parentCollection.concat(Array.isArray(valueToAssign) ? valueToAssign : [valueToAssign]);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  } else if (_.isObject(parentCollection)) {
                                      // ä¿®å¤ï¼šä½¿ç”¨å®‰å…¨çš„å¯¹è±¡åˆå¹¶ï¼Œé¿å…é‡å¤åµŒå¥—
                                      const safeValueToAssign = this._sanitizeAssignValue(valueToAssign, path);
                                      const mergedObject = this._safeMergeObjects(parentCollection, safeValueToAssign, path);
                                      _.set(newState.stat_data, path, mergedObject);
                                      modified = true;
                                  } else {
                                      // If path doesn't exist, just set it
                                      _.set(newState.stat_data, path, valueToAssign);
                                      modified = true;
                                  }
                              } else if (command.args.length >= 3) {
                                  // Handles _.assign('path', key, value)
                                  const keyOrIndex = this._parseCommandValue(command.args[1]);
                                  const valueToAssign = this._parseCommandValue(command.args[2]);
                                  let collection = _.get(newState.stat_data, path);

                                  if (Array.isArray(collection)) {
                                      if (typeof keyOrIndex === 'number') {
                                          const newCollection = [...collection]; // Create a shallow copy for immutability
                                          newCollection.splice(keyOrIndex, 0, valueToAssign);
                                          _.set(newState.stat_data, path, newCollection);
                                          modified = true;
                                      }
                                  } else if (_.isObject(collection)) {
                                      // ä¿®å¤ï¼šä½¿ç”¨å®‰å…¨çš„é”®å€¼è®¾ç½®ï¼Œé¿å…é‡å¤åµŒå¥—
                                      const safeValue = this._sanitizeAssignValue(valueToAssign, `${path}.${keyOrIndex}`);
                                      _.set(collection, String(keyOrIndex), safeValue);
                                      modified = true;
                                  } else {
                                      // If collection doesn't exist, create it
                                      const newCollection = {};
                                      const safeValue = this._sanitizeAssignValue(valueToAssign, `${path}.${keyOrIndex}`);
                                      _.set(newCollection, String(keyOrIndex), safeValue);
                                      _.set(newState.stat_data, path, newCollection);
                                      modified = true;
                                  }
                              }
                              break;
                          }
                      }
                  } catch (e) {
                      console.error(`[å½’å¢Ÿ-å¤‡ç”¨æ–¹æ¡ˆ] å¤„ç†æŒ‡ä»¤å¤±è´¥:`, command, e);
                  }
              }

              // ä¿®å¤ï¼šåœ¨è¿”å›å‰å¯¹æ•´ä¸ªæ•°æ®ç»“æ„è¿›è¡Œæ¸…ç†
              if (modified && newState.stat_data) {
                  console.log('[å½’å¢Ÿ-å¤‡ç”¨æ–¹æ¡ˆ] æ­£åœ¨ä¿®å¤æ•°æ®ç»“æ„åµŒå¥—é—®é¢˜...');
                  newState.stat_data = this._fixNestedStructure(newState.stat_data);
              }

              return modified ? newState : null;
          },

          // --- å®‰å…¨çš„èµ‹å€¼å€¼æ¸…ç†å‡½æ•° ---
          _sanitizeAssignValue(value, targetPath) {
              if (!value || typeof value !== 'object') return value;
              
              // ç‰¹åˆ«å¤„ç†äººç‰©å…³ç³»åˆ—è¡¨ç›¸å…³çš„èµ‹å€¼
              if (targetPath.includes('äººç‰©å…³ç³»åˆ—è¡¨')) {
                  // å¦‚æœè¦èµ‹å€¼çš„å¯¹è±¡æœ¬èº«åŒ…å«äººç‰©å…³ç³»åˆ—è¡¨ï¼Œç§»é™¤å®ƒä»¥é˜²æ­¢åµŒå¥—
                  if (_.isObject(value) && value.äººç‰©å…³ç³»åˆ—è¡¨) {
                      console.warn(`[å½’å¢Ÿ-æ•°æ®æ¸…ç†] ç§»é™¤èµ‹å€¼å¯¹è±¡ä¸­çš„é‡å¤äººç‰©å…³ç³»åˆ—è¡¨: ${targetPath}`);
                      const cleaned = { ...value };
                      delete cleaned.äººç‰©å…³ç³»åˆ—è¡¨;
                      return cleaned;
                  }
              }
              
              return value;
          },

          // --- å®‰å…¨çš„å¯¹è±¡åˆå¹¶å‡½æ•° ---
          _safeMergeObjects(target, source, path) {
              if (!_.isObject(target) || !_.isObject(source)) {
                  return source; // å¦‚æœä¸æ˜¯å¯¹è±¡ï¼Œç›´æ¥è¿”å›æºå€¼
              }
              
              const result = _.cloneDeep(target);
              
              // ç‰¹åˆ«å¤„ç†äººç‰©å…³ç³»åˆ—è¡¨çš„åˆå¹¶
              if (path === 'äººç‰©å…³ç³»åˆ—è¡¨' || path.endsWith('.äººç‰©å…³ç³»åˆ—è¡¨')) {
                  // å¯¹äºäººç‰©å…³ç³»åˆ—è¡¨ï¼Œæˆ‘ä»¬åªåˆå¹¶ä¸å­˜åœ¨çš„é”®ï¼Œé¿å…é‡å¤åµŒå¥—
                  for (const [key, value] of Object.entries(source)) {
                      if (!result[key]) {
                          result[key] = this._sanitizeAssignValue(value, `${path}.${key}`);
                      } else {
                          // å¦‚æœäººç‰©å·²å­˜åœ¨ï¼Œåªæ›´æ–°ä¸å­˜åœ¨çš„å±æ€§
                          if (_.isObject(result[key]) && _.isObject(value)) {
                              for (const [subKey, subValue] of Object.entries(value)) {
                                  if (subKey !== 'äººç‰©å…³ç³»åˆ—è¡¨') { // æ°¸è¿œä¸åˆå¹¶åµŒå¥—çš„äººç‰©å…³ç³»åˆ—è¡¨
                                      result[key][subKey] = subValue;
                                  }
                              }
                          }
                      }
                  }
                  return result;
              }
              
              // å¯¹äºå…¶ä»–å¯¹è±¡ï¼Œä½¿ç”¨æ ‡å‡†åˆå¹¶ä½†é¿å…å¾ªç¯å¼•ç”¨
              return _.mergeWith(result, source, (objValue, srcValue, key) => {
                  // é˜²æ­¢åˆå¹¶åŒåçš„åµŒå¥—ç»“æ„
                  if (key === path.split('.').pop()) {
                      console.warn(`[å½’å¢Ÿ-å®‰å…¨åˆå¹¶] è·³è¿‡åŒåé”®çš„åˆå¹¶ä»¥é˜²æ­¢åµŒå¥—: ${key}`);
                      return objValue; // ä¿æŒåŸå€¼ï¼Œä¸åˆå¹¶
                  }
                  return undefined; // ä½¿ç”¨é»˜è®¤åˆå¹¶è¡Œä¸º
              });
          },

          // --- å†…éƒ¨è¾…åŠ©å‡½æ•°ï¼Œä» function.ts ç§»æ¤ ---
          _trimQuotes(str) {
              if (typeof str !== 'string') return str;
              return str.replace(/^['"` ]*(.*?)['"` ]*$/, '$1');
          },
          
          _parseCommandValue(valStr) {
              if (typeof valStr !== 'string') return valStr;
              const trimmed = valStr.trim();
              if (trimmed === 'true') return true;
              if (trimmed === 'false') return false;
              if (trimmed === 'null') return null;
              if (trimmed === 'undefined') return undefined;
              try {
                  return JSON.parse(trimmed);
              } catch (e) {
                  if ((trimmed.startsWith('{') && trimmed.endsWith('}')) || (trimmed.startsWith('[') && trimmed.endsWith(']'))) {
                      try {
                          return new Function(`return ${trimmed};`)();
                      } catch (err) { /* continue */ }
                  }
              }
              return this._trimQuotes(valStr);
          },

          _extractCommands(inputText) {
              const results = [];
              let i = 0;
              while (i < inputText.length) {
                  const match = inputText.substring(i).match(/_\.(set|assign|remove|add|insert)\(/);
                  if (!match || match.index === undefined) break;
                  
                  const commandType = match[1];
                  const start = i + match.index;
                  const openParen = start + match[0].length;
                  const closeParen = this._findMatchingCloseParen(inputText, openParen);
                  
                  if (closeParen === -1) {
                      i = openParen;
                      continue;
                  }
                  
                  let endPos = closeParen + 1;
                  if (endPos >= inputText.length || inputText[endPos] !== ';') {
                      i = closeParen + 1;
                      continue;
                  }
                  endPos++;
                  
                  const paramsString = inputText.substring(openParen, closeParen);
                  const params = this._parseParameters(paramsString);
                  
                  results.push({ command: commandType, args: params });
                  i = endPos;
              }
              return results;
          },

          _findMatchingCloseParen(str, startPos) {
              let parenCount = 1;
              let inQuote = false;
              let quoteChar = '';
              for (let i = startPos; i < str.length; i++) {
                  const char = str[i];
                  if ((char === '"' || char === "'" || char === '`') && str[i - 1] !== '\\') {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      else if (char === ')') {
                          parenCount--;
                          if (parenCount === 0) return i;
                      }
                  }
              }
              return -1;
          },

          _parseParameters(paramsString) {
              const params = [];
              let currentParam = '';
              let inQuote = false;
              let quoteChar = '';
              let bracketCount = 0;
              let braceCount = 0;
              let parenCount = 0;
              for (let i = 0; i < paramsString.length; i++) {
                  const char = paramsString[i];
                  if ((char === '"' || char === "'" || char === '`') && (i === 0 || paramsString[i - 1] !== '\\')) {
                      if (!inQuote) {
                          inQuote = true;
                          quoteChar = char;
                      } else if (char === quoteChar) {
                          inQuote = false;
                      }
                  }
                  if (!inQuote) {
                      if (char === '(') parenCount++;
                      if (char === ')') parenCount--;
                      if (char === '[') bracketCount++;
                      if (char === ']') bracketCount--;
                      if (char === '{') braceCount++;
                      if (char === '}') braceCount--;
                  }
                  if (char === ',' && !inQuote && parenCount === 0 && bracketCount === 0 && braceCount === 0) {
                      params.push(currentParam.trim());
                      currentParam = '';
                      continue;
                  }
                  currentParam += char;
              }
              if (currentParam.trim()) {
                  params.push(currentParam.trim());
              }
              return params;
          },

          // --- æ–°å¢ï¼šHTMLè½¬ä¹‰è¾…åŠ©å‡½æ•° ---
          escapeHtml(text) {
            if (typeof text !== 'string') return text;
            return text
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');
          },

          // --- æ–°å¢ï¼šæ–‡æœ¬å‡€åŒ–è¾…åŠ©å‡½æ•° ---
          _getDisplayText(aiResponse) {
            try {
              if (!aiResponse || typeof aiResponse !== 'string') return '';
              
              // ä¼˜å…ˆæå– <gametxt> çš„å†…å®¹
              const gameText = this._extractLastTagContent('gametxt', aiResponse);
              if (gameText !== null) {
                  // æ–°å¢ï¼šç§»é™¤HTMLæ³¨é‡Šï¼Œä¿®å¤å› æ³¨é‡Šå¯¼è‡´çš„å­˜æ¡£é€»è¾‘å´©æºƒé—®é¢˜
                  return gameText.replace(new RegExp('<!--[\\s\\S]*?-->', 'g'), '').trim();
              }

              // ä¿®å¤ï¼šå¦‚æœæ‰¾ä¸åˆ° <gametxt>ï¼Œåˆ™ç›´æ¥è¿”å›åŸå§‹å“åº”ï¼Œé¿å…å¤‡ç”¨æ–¹æ¡ˆé”™è¯¯åœ°ç ´åå…¶ä»–HTMLæ ‡ç­¾ã€‚
              // æŸ“è‰²çš„é€»è¾‘å®Œå…¨äº¤ç»™ formatMessageContent å¤„ç†ã€‚
              return aiResponse.trim();
            } catch (e) {
              console.error("è§£ææ˜¾ç¤ºæ–‡æœ¬æ—¶å‡ºé”™:", e, "åŸå§‹è¾“å…¥:", aiResponse);
              return "[æ‘˜è¦è§£æå¤±è´¥]";
            }
          },

          // --- æ–°å¢ï¼šå¯é‡ç”¨çš„ã€å¥å£®çš„æ ‡ç­¾æå–å‡½æ•° ---
           _extractLastTagContent(tagName, text, ignoreCase = false) {
               if (!text || typeof text !== 'string') return null;

               const flags = ignoreCase ? 'gi' : 'g';
               const regex = new RegExp(`<${tagName}>([\\s\\S]*?)<\\/${tagName}>`, flags);
               
               const matches = [...text.matchAll(regex)];
               
               if (matches.length > 0) {
                   // è¿”å›æœ€åä¸€ä¸ªåŒ¹é…é¡¹çš„å†…å®¹
                   return matches[matches.length - 1][1].trim();
               }

               return null;
           },

           // --- æ–°å¢ï¼šMVUè¯­æ³•è§£æå’Œä¸­æ–‡è½¬ä¹‰ ---
           parseMvuCommands(mvuText) {
               if (!mvuText || typeof mvuText !== 'string') return [];
               
               const changes = [];
               const lines = mvuText.split('\n');
               
               for (const line of lines) {
                   const trimmedLine = line.trim();
                   if (!trimmedLine || trimmedLine.startsWith('//') || trimmedLine.startsWith('<') || trimmedLine.startsWith('</')) {
                       continue;
                   }
                   
                   // è§£æ _.set å‘½ä»¤ (æ”¯æŒ2å‚æ•°å’Œ3å‚æ•°æ ¼å¼)
                   let setMatch = trimmedLine.match(/^_\.set\s*\(\s*['"`]([^'"`]+)['"`]\s*,\s*([^,)]+)(?:\s*,\s*([^)]+))?\)\s*;?\s*(?:\/\/(.*))?$/);
                   if (setMatch) {
                       const [, path, param2, param3, comment] = setMatch;
                       let oldValue, newValue;
                       
                       if (param3 !== undefined) {
                           // ä¸‰å‚æ•°æ ¼å¼: _.set(path, oldValue, newValue)
                           oldValue = this.formatValue(param2);
                           newValue = this.formatValue(param3);
                       } else {
                           // äºŒå‚æ•°æ ¼å¼: _.set(path, newValue)
                           oldValue = 'æœªçŸ¥';
                           newValue = this.formatValue(param2);
                       }
                       
                       changes.push({
                           type: 'set',
                           path: this.translatePath(path),
                           oldValue: oldValue,
                           newValue: newValue,
                           comment: comment ? comment.trim() : '',
                           description: oldValue !== 'æœªçŸ¥' ?
                               `è®¾ç½® ${this.translatePath(path)} ä» ${oldValue} å˜ä¸º ${newValue}` :
                               `è®¾ç½® ${this.translatePath(path)} ä¸º ${newValue}`
                       });
                       continue;
                   }
                   
                   // è§£æ _.add å‘½ä»¤
                   const addMatch = trimmedLine.match(/^_\.add\s*\(\s*['"`]([^'"`]+)['"`]\s*,\s*([^)]+)\)\s*;?\s*(?:\/\/(.*))?$/);
                   if (addMatch) {
                       const [, path, delta, comment] = addMatch;
                       const deltaValue = this.formatValue(delta);
                       changes.push({
                           type: 'add',
                           path: this.translatePath(path),
                           delta: deltaValue,
                           comment: comment ? comment.trim() : '',
                           description: `${this.translatePath(path)} å¢åŠ  ${deltaValue}`
                       });
                       continue;
                   }
                   
                   // è§£æ _.assign å‘½ä»¤ (æ”¯æŒ2å‚æ•°å’Œ3å‚æ•°æ ¼å¼)
                   const assignMatch = trimmedLine.match(/^_\.assign\s*\(\s*['"`]([^'"`]+)['"`]\s*,\s*([^,)]+)(?:\s*,\s*([^)]+))?\)\s*;?\s*(?:\/\/(.*))?$/);
                   if (assignMatch) {
                       const [, path, param2, param3, comment] = assignMatch;
                       let key, value, description;
                       
                       if (param3 !== undefined) {
                           // ä¸‰å‚æ•°æ ¼å¼: _.assign(path, key, value)
                           key = this.formatValue(param2);
                           value = this.formatValue(param3);
                           description = `å‘ ${this.translatePath(path)} æ·»åŠ  ${key}: ${value}`;
                       } else {
                           // äºŒå‚æ•°æ ¼å¼: _.assign(path, value) æˆ– _.assign(path, key)
                           const formattedValue = this.formatValue(param2);
                           
                           // å°è¯•åˆ¤æ–­æ˜¯å¦ä¸ºå¯¹è±¡æ ¼å¼
                           if (param2.trim().startsWith('{') || param2.trim().startsWith('[')) {
                               description = `å‘ ${this.translatePath(path)} æ·»åŠ å¤æ‚å¯¹è±¡`;
                               key = 'å¯¹è±¡';
                               value = formattedValue;
                           } else {
                               // ç®€å•å€¼ï¼Œå¯èƒ½æ˜¯æ•°ç»„å…ƒç´ æˆ–å¯¹è±¡é”®
                               key = formattedValue;
                               value = '';
                               description = `å‘ ${this.translatePath(path)} æ·»åŠ  ${formattedValue}`;
                           }
                       }
                       
                       changes.push({
                           type: 'assign',
                           path: this.translatePath(path),
                           key: key,
                           value: value,
                           comment: comment ? comment.trim() : '',
                           description: description
                       });
                       continue;
                   }
                   
                   // è§£æ _.remove å‘½ä»¤
                   const removeMatch = trimmedLine.match(/^_\.remove\s*\(\s*['"`]([^'"`]+)['"`](?:\s*,\s*([^)]+))?\)\s*;?\s*(?:\/\/(.*))?$/);
                   if (removeMatch) {
                       const [, path, target, comment] = removeMatch;
                       const targetValue = target ? this.formatValue(target) : '';
                       changes.push({
                           type: 'remove',
                           path: this.translatePath(path),
                           target: targetValue,
                           comment: comment ? comment.trim() : '',
                           description: `ä» ${this.translatePath(path)} ç§»é™¤${targetValue ? ' ' + targetValue : 'å†…å®¹'}`
                       });
                       continue;
                   }
               }
               
               return changes;
           },

           // è·¯å¾„ç¿»è¯‘ï¼šå°†è‹±æ–‡è·¯å¾„è½¬æ¢ä¸ºä¸­æ–‡æè¿°
           translatePath(path) {
               const translations = {
                   'å½“å‰å¢ƒç•Œ': 'å½“å‰å¢ƒç•Œ',
                   'å¢ƒç•Œæ˜ å°„': 'å¢ƒç•Œæ˜ å°„',
                   'ä¿®ä¸ºè¿›åº¦': 'ä¿®ä¸ºè¿›åº¦',
                   'ä¿®ä¸ºç“¶é¢ˆ': 'ä¿®ä¸ºç“¶é¢ˆ',
                   'æ³•åŠ›': 'æ³•åŠ›ä¸Šé™',
                   'å½“å‰æ³•åŠ›': 'å½“å‰æ³•åŠ›',
                   'ç¥æµ·': 'ç¥æµ·ä¸Šé™',
                   'å½“å‰ç¥æµ·': 'å½“å‰ç¥æµ·',
                   'é“å¿ƒ': 'é“å¿ƒä¸Šé™',
                   'å½“å‰é“å¿ƒ': 'å½“å‰é“å¿ƒ',
                   'ç©ºé€Ÿ': 'ç©ºé€Ÿä¸Šé™',
                   'å½“å‰ç©ºé€Ÿ': 'å½“å‰ç©ºé€Ÿ',
                   'æ°”è¿': 'æ°”è¿',
                   'ç”Ÿç†å¹´é¾„': 'ç”Ÿç†å¹´é¾„',
                   'å¿ƒç†å¹´é¾„': 'å¿ƒç†å¹´é¾„',
                   'å½“å‰æ—¶é—´çºªå¹´': 'å½“å‰æ—¶é—´',
                   'å½’å¢Ÿå……èƒ½æ—¶é—´': 'å½’å¢Ÿå……èƒ½',
                   'å¤©èµ‹åˆ—è¡¨': 'å¤©èµ‹',
                   'çµæ ¹åˆ—è¡¨': 'çµæ ¹',
                   'æ­¦å™¨åˆ—è¡¨': 'æ­¦å™¨',
                   'é˜²å…·åˆ—è¡¨': 'é˜²å…·',
                   'é¥°å“åˆ—è¡¨': 'é¥°å“',
                   'æ³•å®åˆ—è¡¨': 'æ³•å®',
                   'ä¸¹è¯åˆ—è¡¨': 'ä¸¹è¯',
                   'å…¶ä»–åˆ—è¡¨': 'å…¶ä»–ç‰©å“',
                   'äººç‰©å…³ç³»åˆ—è¡¨': 'äººç‰©å…³ç³»',
                   'å½“å‰çŠ¶æ€': 'çŠ¶æ€æ•ˆæœ',
                   'å½“å‰ä½ç½®': 'å½“å‰ä½ç½®'
               };
               
               // å¤„ç†æ•°ç»„ç´¢å¼• [0] ç­‰
               let translatedPath = path.replace(/\[0\]/g, '');
               
               // é€æ®µç¿»è¯‘è·¯å¾„
               const segments = translatedPath.split('.');
               const translatedSegments = segments.map(segment => {
                   return translations[segment] || segment;
               });
               
               return translatedSegments.join(' â†’ ');
           },

           // æ ¼å¼åŒ–æ•°å€¼æ˜¾ç¤º
           formatValue(value) {
               if (typeof value === 'string') {
                   // ç§»é™¤å¼•å·
                   const cleaned = value.replace(/^['"`]|['"`]$/g, '');
                   return cleaned;
               }
               return String(value);
           },

           // --- æ–°å¢ï¼šå˜é‡æ”¹å˜æé†’åŠŸèƒ½ ---
           updateVariableChangesReminder() {
               if (!this.lastExtractedVariables) {
                   this.hideVariableChangesReminder();
                   return;
               }

               const changes = this.parseMvuCommands(this.lastExtractedVariables);
               if (changes.length === 0) {
                   this.hideVariableChangesReminder();
                   return;
               }

               this.showVariableChangesReminder(changes);
           },

           showVariableChangesReminder(changes) {
               const reminder = document.getElementById('variable-changes-reminder');
               const count = document.getElementById('variable-changes-count');
               const content = document.getElementById('variable-changes-content');

               if (!reminder || !count || !content) return;

               // æ›´æ–°è®¡æ•°
               count.textContent = changes.length;

               // ç”Ÿæˆå˜é‡æ”¹å˜å†…å®¹
               const changesHtml = changes.map(change => {
                   const typeText = {
                       'set': 'è®¾ç½®',
                       'add': 'å¢åŠ ',
                       'assign': 'æ·»åŠ ',
                       'remove': 'ç§»é™¤'
                   }[change.type] || change.type;

                   return `
                       <div class="variable-change-item">
                           <div class="variable-change-description">
                               <span class="variable-change-type ${change.type}">${typeText}</span>
                               ${change.description}
                           </div>
                           ${change.comment ? `<div class="variable-change-comment">${change.comment}</div>` : ''}
                       </div>
                   `;
               }).join('');

               content.innerHTML = changesHtml;
               reminder.style.display = 'block';
           },

           hideVariableChangesReminder() {
               const reminder = document.getElementById('variable-changes-reminder');
               if (reminder) {
                   reminder.style.display = 'none';
               }
           },

           toggleVariableChanges() {
               const content = document.getElementById('variable-changes-content');
               const icon = document.getElementById('variable-changes-icon');

               if (!content || !icon) return;

               const isExpanded = content.classList.contains('expanded');
               
               if (isExpanded) {
                   content.classList.remove('expanded');
                   icon.classList.add('collapsed');
                   icon.textContent = 'â–¶';
               } else {
                   content.classList.add('expanded');
                   icon.classList.remove('collapsed');
                   icon.textContent = 'â–¼';
               }
           },

             // --- æ–°å¢ï¼šæ€ç»´è¿‡ç¨‹æ˜¾ç¤º/éšè— ---
             toggleThinkingDisplay() {
                const content = document.getElementById('thinking-process-content');
                const icon = document.getElementById('thinking-process-icon');

                if (!content || !icon) return;

                const isExpanded = content.classList.contains('expanded');

                if (isExpanded) {
                    content.classList.remove('expanded');
                    icon.classList.add('collapsed');
                    icon.textContent = 'â–¶';
                } else {
                    if (this.lastExtractedThinking) {
                        try {
                            if (typeof formatAsDisplayedMessage === 'function') {
                                const cleanedContent = this.lastExtractedThinking
                                    .replace(/<thinking>/g, '')
                                    .replace(/<\/thinking>/g, '');
                                content.innerHTML = formatAsDisplayedMessage(cleanedContent);
                            } else {
                                content.innerHTML = this.simpleMarkdownParse(this.lastExtractedThinking);
                            }
                        } catch (error) {
                            console.error('Error formatting thinking content:', error);
                            content.textContent = this.lastExtractedThinking;
                        }
                        content.classList.add('expanded');
                        icon.classList.remove('collapsed');
                        icon.textContent = 'â–¼';
                    }
                }
            },
            updateThinkingButtonVisibility() {
                const container = document.getElementById('thinking-process-container');
                if (container) {
                    if (this.lastExtractedThinking && this.lastExtractedThinking.trim() !== '') {
                        container.style.display = 'block';
                    } else {
                        container.style.display = 'none';
                    }
                }
            },
            // --- æ–°å¢ï¼šæ€ç»´è¿‡ç¨‹æŒä¹…åŒ– ---
            saveLastThinking() {
                try {
                    if (this.lastExtractedThinking) {
                        localStorage.setItem('guixu_last_thinking', this.lastExtractedThinking);
                    } else {
                        localStorage.removeItem('guixu_last_thinking');
                    }
                } catch (e) {
                    console.error('ä¿å­˜æ€ç»´è¿‡ç¨‹å¤±è´¥:', e);
                }
            },

            loadLastThinking() {
                try {
                    this.lastExtractedThinking = localStorage.getItem('guixu_last_thinking') || null;
                } catch (e) {
                    console.error('åŠ è½½æ€ç»´è¿‡ç¨‹å¤±è´¥:', e);
                    this.lastExtractedThinking = null;
                }
            },

           // --- æ–°å¢ï¼šå¤šå­˜æ¡£ç®¡ç†åŠŸèƒ½ ---
          showSaveLoadManager() {
            this.openModal('save-load-modal');
            const manualContainer = document.getElementById('save-slots-container');
            const autoContainer = document.getElementById('auto-save-slot-container');
            if (!manualContainer || !autoContainer) return;

            let saves;
            try {
                saves = this.getSavesFromStorage();
            } catch (e) {
                console.error("è§£ææ•´ä¸ªå­˜æ¡£æ–‡ä»¶å¤±è´¥ï¼Œå¯èƒ½æ˜¯JSONæ ¼å¼é”™è¯¯:", e);
                manualContainer.innerHTML = `<div style="color: #ff6b6b; padding: 20px; text-align: center;"><p>é”™è¯¯ï¼šä¸»å­˜æ¡£æ–‡ä»¶å·²æŸåã€‚</p></div>`;
                autoContainer.innerHTML = '';
                return;
            }

            // 1. æ¸²æŸ“è‡ªåŠ¨å­˜æ¡£æ§½ä½ (äº”ç¼“å†²)
            let autoSaveHtml = '';
            const autoSaveSlots = [
                { id: 'auto_save_slot_0', name: 'è‡ªåŠ¨å­˜æ¡£-1 (æœ€æ–°)', color: '#66CDAA' },
                { id: 'auto_save_slot_1', name: 'è‡ªåŠ¨å­˜æ¡£-2', color: '#FFD700' },
                { id: 'auto_save_slot_2', name: 'è‡ªåŠ¨å­˜æ¡£-3', color: '#87CEEB' },
                { id: 'auto_save_slot_3', name: 'è‡ªåŠ¨å­˜æ¡£-4', color: '#FFA07A' },
                { id: 'auto_save_slot_4', name: 'è‡ªåŠ¨å­˜æ¡£-5 (æœ€æ—§)', color: '#D3D3D3' }
            ];

            autoSaveSlots.forEach((slotInfo, index) => {
                const autoSaveData = saves[slotInfo.id];
                autoSaveHtml += `<div class="save-slot" data-slot-id="${slotInfo.id}">`;
                if (autoSaveData && autoSaveData.mvu_data) {
                    const date = new Date(autoSaveData.timestamp).toLocaleString('zh-CN');
                    const statDataForRender = autoSaveData.mvu_data.stat_data || (autoSaveData.mvu_data['å½“å‰å¢ƒç•Œ'] ? autoSaveData.mvu_data : null);
                    const jingjie = this.SafeGetValue(statDataForRender, 'å½“å‰å¢ƒç•Œ', 'æœªçŸ¥');
                    const jinian = this.SafeGetValue(statDataForRender, 'å½“å‰æ—¶é—´çºªå¹´', 'æœªçŸ¥');
                    const summary = this._getDisplayText(autoSaveData.message_content);
                    const displayName = autoSaveData.save_name || slotInfo.name;
                    
                    autoSaveHtml += `
                        <div class="save-slot-info">
                            <div class="slot-name" style="color: ${slotInfo.color};">${displayName}</div>
                            <div class="slot-time">${date} - ${jingjie} - ${jinian}</div>
                            <div class="slot-summary">${summary ? summary.substring(0, 40) + '...' : 'æ— æ­£æ–‡è®°å½•'}</div>
                        </div>
                        <div class="save-slot-actions">
                            <button class="interaction-btn btn-load-slot" style="padding: 8px 12px;">è¯»æ¡£</button>
                            <button class="interaction-btn btn-export-slot" style="padding: 8px 12px;">å¯¼å‡º</button>
                            <button class="interaction-btn btn-delete-slot" style="padding: 8px 12px; background: #8b0000;">åˆ é™¤</button>
                        </div>
                    `;
                } else {
                    autoSaveHtml += `
                        <div class="save-slot-info">
                            <div class="slot-name" style="color: ${slotInfo.color};">${slotInfo.name}</div>
                            <div class="slot-time" style="font-style: italic; color: #8b7355;">ç©ºå­˜æ¡£ä½</div>
                        </div>
                        <div class="save-slot-actions">
                            <button class="interaction-btn btn-load-slot" style="padding: 8px 12px;" disabled>è¯»æ¡£</button>
                            <button class="interaction-btn btn-export-slot" style="padding: 8px 12px;" disabled>å¯¼å‡º</button>
                            <button class="interaction-btn btn-delete-slot" style="padding: 8px 12px; background: #8b0000;" disabled>åˆ é™¤</button>
                        </div>
                    `;
                }
                autoSaveHtml += `</div>`;
            });
            autoContainer.innerHTML = autoSaveHtml;

            // 2. æ¸²æŸ“æ‰‹åŠ¨å­˜æ¡£æ§½ä½
            let manualHtml = '';
            const totalSlots = 5;
            for (let i = 1; i <= totalSlots; i++) {
              const slotId = `slot_${i}`;
              const saveData = saves[slotId];
              
              manualHtml += `<div class="save-slot" data-slot-id="${slotId}"><div class="save-slot-info">`;

              let statDataForRender = null;
              if (saveData && typeof saveData.mvu_data === 'object' && saveData.mvu_data !== null) {
                  statDataForRender = saveData.mvu_data.stat_data || (saveData.mvu_data['å½“å‰å¢ƒç•Œ'] ? saveData.mvu_data : null);
              }

              if (statDataForRender) {
                const date = new Date(saveData.timestamp).toLocaleString('zh-CN');
                const jingjie = this.SafeGetValue(statDataForRender, 'å½“å‰å¢ƒç•Œ', 'æœªçŸ¥');
                const jinian = this.SafeGetValue(statDataForRender, 'å½“å‰æ—¶é—´çºªå¹´', 'æœªçŸ¥');
                const summary = this._getDisplayText(saveData.message_content);
                const saveName = saveData.save_name || `å­˜æ¡£ ${i}`;
                manualHtml += `
                    <div class="slot-name">${saveName}</div>
                    <div class="slot-time">${date} - ${jingjie} - ${jinian}</div>
                    <div class="slot-summary">${summary ? summary.substring(0, 40) + '...' : 'æ— æ­£æ–‡è®°å½•'}</div>
                `;
              } else {
                manualHtml += `
                    <div class="slot-name">å­˜æ¡£ ${i}</div>
                    <div class="slot-time" style="font-style: italic; color: #8b7355;">ç©ºå­˜æ¡£ä½</div>
                `;
              }

              manualHtml += `</div><div class="save-slot-actions">
                    <button class="interaction-btn btn-save-slot" style="padding: 8px 12px;">å­˜æ¡£</button>
                    <button class="interaction-btn btn-load-slot" style="padding: 8px 12px;" ${!saveData ? 'disabled' : ''}>è¯»æ¡£</button>
                    <button class="interaction-btn btn-export-slot" style="padding: 8px 12px;" ${!saveData ? 'disabled' : ''}>å¯¼å‡º</button>
                    <button class="interaction-btn btn-delete-slot" style="padding: 8px 12px; background: #8b0000;" ${!saveData ? 'disabled' : ''}>åˆ é™¤</button>
                </div></div>`;
            }
            manualContainer.innerHTML = manualHtml;
          },

          getSavesFromStorage() {
            try {
              const saves = localStorage.getItem('guixu_multi_save_data');
              return saves ? JSON.parse(saves) : {};
            } catch (e) {
              console.error("è·å–å­˜æ¡£å¤±è´¥:", e);
              return {};
            }
          },

          async saveGame(slotId) {
            try {
              // é¦–å…ˆå¼¹å‡ºè¾“å…¥æ¡†è®©ç”¨æˆ·å‘½åå­˜æ¡£
              const saveName = await this.promptForSaveName(slotId);
              if (!saveName) {
                this.showTemporaryMessage('å­˜æ¡£å·²å–æ¶ˆ');
                return;
              }

              const allSaves = this.getSavesFromStorage();
              const slotExists = allSaves[slotId];

              const performSave = async () => {
                try {
                  // ä¿®å¤ï¼šä¼˜å…ˆä½¿ç”¨ç¼“å­˜çš„mvuçŠ¶æ€ï¼Œå¦‚æœæ²¡æœ‰å†ä»æ¶ˆæ¯è·å–
                  let currentMvuData = this.currentMvuState;
                  let currentMessageContent = '';
                  
                  if (!currentMvuData) {
                    console.log('[å½’å¢Ÿå­˜æ¡£] ç¼“å­˜çŠ¶æ€ä¸ºç©ºï¼Œå°è¯•ä»æ¶ˆæ¯è·å–...');
                    const messages = await getChatMessages(getCurrentMessageId());
                    if (!messages || messages.length === 0) {
                      this.showTemporaryMessage('é”™è¯¯ï¼šæ— æ³•è·å–å½“å‰æ¶ˆæ¯æ•°æ®ï¼Œæ— æ³•å­˜æ¡£ã€‚');
                      return;
                    }
                    currentMvuData = messages[0].data;
                    currentMessageContent = messages[0].message || '';
                  } else {
                    // å¦‚æœæœ‰ç¼“å­˜çŠ¶æ€ï¼Œä¹Ÿå°è¯•è·å–å½“å‰æ¶ˆæ¯å†…å®¹
                    try {
                      const messages = await getChatMessages(getCurrentMessageId());
                      if (messages && messages.length > 0) {
                        currentMessageContent = messages[0].message || '';
                      }
                    } catch (e) {
                      console.warn('[å½’å¢Ÿå­˜æ¡£] è·å–æ¶ˆæ¯å†…å®¹å¤±è´¥ï¼Œä½¿ç”¨ç©ºå†…å®¹:', e);
                    }
                  }
                  
                  if (!currentMvuData || !currentMvuData.stat_data) {
                    this.showTemporaryMessage('é”™è¯¯ï¼šMVUæ•°æ®ä¸å®Œæ•´ï¼Œæ— æ³•å­˜æ¡£ã€‚è¯·å…ˆè¿›è¡Œä¸€æ¬¡æ¸¸æˆæ“ä½œã€‚');
                    return;
                  }
                  
                  console.log('[å½’å¢Ÿå­˜æ¡£] å¼€å§‹å­˜æ¡£ï¼Œæ•°æ®æ£€æŸ¥é€šè¿‡');
                

                // --- æ–°é€»è¾‘ï¼šåˆ›å»ºç‹¬ç«‹çš„ä¸–ç•Œä¹¦æ¡ç›® ---
                const bookName = '1å½’å¢Ÿ';
                const index = this.unifiedIndex;
                const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
                const pastLivesKey = index > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${index})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
                
                // ç”Ÿæˆç‹¬ç«‹ä¸–ç•Œä¹¦æ¡ç›®åç§°
                const saveJourneyEntryName = `${saveName}-æœ¬ä¸–å†ç¨‹`;
                const savePastLivesEntryName = `${saveName}-å¾€ä¸–æ¶Ÿæ¼ª`;
                
                const novelModeIndex = this.unifiedIndex; // ä¿®å¤ï¼šå°è¯´æ¨¡å¼ä½¿ç”¨ç»Ÿä¸€åºå·
                const novelModeKey = novelModeIndex > 1 ? `å°è¯´æ¨¡å¼(${novelModeIndex})` : 'å°è¯´æ¨¡å¼';
                const saveNovelModeEntryName = `${saveName}-å°è¯´æ¨¡å¼`;

                let lorebookEntries = {
                  journey_entry_name: saveJourneyEntryName,
                  past_lives_entry_name: savePastLivesEntryName,
                  novel_mode_entry_name: saveNovelModeEntryName
                };

                try {
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
                  const pastLivesEntry = allEntries.find(entry => entry.comment === pastLivesKey);
                  const novelModeEntry = allEntries.find(entry => entry.comment === novelModeKey);
                  
                  // åˆ›å»ºç‹¬ç«‹çš„ä¸–ç•Œä¹¦æ¡ç›®
                  const entriesToCreate = [];
                  
                  // ä¿®å¤ï¼šå³ä½¿å†…å®¹ä¸ºç©ºä¹Ÿåˆ›å»ºæ¡ç›®ï¼Œé¿å…å­˜æ¡£å¤±è´¥
                  if (journeyEntry) {
                    entriesToCreate.push({
                      comment: saveJourneyEntryName,
                      content: journeyEntry.content || '', // å…è®¸ç©ºå†…å®¹
                      keys: [saveJourneyEntryName],
                      enabled: false, // é»˜è®¤ç¦ç”¨
                      position: 'before_character_definition',
                      order: 20
                    });
                    console.log(`[å½’å¢Ÿå­˜æ¡£] å‡†å¤‡åˆ›å»ºæœ¬ä¸–å†ç¨‹æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${(journeyEntry.content || '').length}`);
                  } else {
                    // å¦‚æœæ‰¾ä¸åˆ°åŸå§‹æ¡ç›®ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„
                    entriesToCreate.push({
                      comment: saveJourneyEntryName,
                      content: '# æœ¬ä¸–å†ç¨‹\næš‚æ— è®°å½•',
                      keys: [saveJourneyEntryName],
                      enabled: false,
                      position: 'before_character_definition',
                      order: 20
                    });
                    console.log(`[å½’å¢Ÿå­˜æ¡£] åŸå§‹æœ¬ä¸–å†ç¨‹æ¡ç›®ä¸å­˜åœ¨ï¼Œåˆ›å»ºç©ºæ¡ç›®`);
                  }
                  
                  if (pastLivesEntry) {
                    entriesToCreate.push({
                      comment: savePastLivesEntryName,
                      content: pastLivesEntry.content || '', // å…è®¸ç©ºå†…å®¹
                      keys: [savePastLivesEntryName],
                      enabled: false, // é»˜è®¤ç¦ç”¨
                      position: 'before_character_definition',
                      order: 19
                    });
                    console.log(`[å½’å¢Ÿå­˜æ¡£] å‡†å¤‡åˆ›å»ºå¾€ä¸–æ¶Ÿæ¼ªæ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${(pastLivesEntry.content || '').length}`);
                  } else {
                    // å¦‚æœæ‰¾ä¸åˆ°åŸå§‹æ¡ç›®ï¼Œåˆ›å»ºä¸€ä¸ªç©ºçš„
                    entriesToCreate.push({
                      comment: savePastLivesEntryName,
                      content: '# å¾€ä¸–æ¶Ÿæ¼ª\næš‚æ— è®°å½•',
                      keys: [savePastLivesEntryName],
                      enabled: false,
                      position: 'before_character_definition',
                      order: 19
                    });
                    console.log(`[å½’å¢Ÿå­˜æ¡£] åŸå§‹å¾€ä¸–æ¶Ÿæ¼ªæ¡ç›®ä¸å­˜åœ¨ï¼Œåˆ›å»ºç©ºæ¡ç›®`);
                  }

                  if (novelModeEntry) {
                    entriesToCreate.push({
                      comment: saveNovelModeEntryName,
                      content: novelModeEntry.content || '', // å…è®¸ç©ºå†…å®¹
                      keys: [saveNovelModeEntryName],
                      enabled: false, // é»˜è®¤ç¦ç”¨
                      position: 'before_character_definition',
                      order: 18 // Give it a different order
                    });
                    console.log(`[å½’å¢Ÿå­˜æ¡£] å‡†å¤‡åˆ›å»ºå°è¯´æ¨¡å¼æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${(novelModeEntry.content || '').length}`);
                  } else {
                     entriesToCreate.push({
                      comment: saveNovelModeEntryName,
                      content: '# å°è¯´æ¨¡å¼\næš‚æ— è®°å½•',
                      keys: [saveNovelModeEntryName],
                      enabled: false,
                      position: 'before_character_definition',
                      order: 18
                    });
                    console.log(`[å½’å¢Ÿå­˜æ¡£] åŸå§‹å°è¯´æ¨¡å¼æ¡ç›®ä¸å­˜åœ¨ï¼Œåˆ›å»ºç©ºæ¡ç›®`);
                  }
                  
                  if (entriesToCreate.length > 0) {
                    await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                    console.log(`[å½’å¢Ÿå­˜æ¡£] å·²åˆ›å»º ${entriesToCreate.length} ä¸ªç‹¬ç«‹ä¸–ç•Œä¹¦æ¡ç›®`);
                  }
                  
                } catch (e) {
                  console.error("åˆ›å»ºç‹¬ç«‹ä¸–ç•Œä¹¦æ¡ç›®æ—¶å‡ºé”™:", e);
                  this.showTemporaryMessage("è­¦å‘Šï¼šåˆ›å»ºä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥ï¼Œä½†ä¸»æ•°æ®ä»ä¼šä¿å­˜ã€‚");
                }
                // --- æ–°é€»è¾‘ç»“æŸ ---
                
                const saveDataPayload = {
                  timestamp: new Date().toISOString(),
                  save_name: saveName, 
                  message_content: currentMessageContent,
                  lorebook_entries: lorebookEntries, 
                  gacha_data: { 
                      state: _.cloneDeep(this.gachaState),
                      collection: _.cloneDeep(this.gachaCollection),
                      history: _.cloneDeep(this.gachaHistory)
                  },
                  mvu_data: {
                    stat_data: currentMvuData.stat_data,
                    schema: currentMvuData.schema,
                    initialized_lorebooks: currentMvuData.initialized_lorebooks,
                    display_data: currentMvuData.display_data,
                    delta_data: currentMvuData.delta_data,
                  }
                };

                allSaves[slotId] = saveDataPayload;

                localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves));
                this.showTemporaryMessage(`å­˜æ¡£"${saveName}"å·²ä¿å­˜åˆ°å­˜æ¡£ä½ ${slotId.split('_')[1]}`);
                this.showSaveLoadManager(); // åˆ·æ–°UI
                } catch (error) {
                  console.error('å­˜æ¡£å¤±è´¥:', error);
                  this.showTemporaryMessage(`å­˜æ¡£å¤±è´¥: ${error.message}`);
                }
              };

              if (slotExists) {
                this.showCustomConfirm(`å­˜æ¡£ä½ ${slotId.split('_')[1]} å·²æœ‰æ•°æ®ï¼Œç¡®å®šè¦è¦†ç›–å—ï¼Ÿ`, performSave);
              } else {
                await performSave();
              }
            } catch (error) {
              console.error('å­˜æ¡£è¿‡ç¨‹ä¸­å‘ç”Ÿé”™è¯¯:', error);
              this.showTemporaryMessage(`å­˜æ¡£å¤±è´¥: ${error.message}`);
            }
          },

          async loadGame(slotId) {
            const allSaves = this.getSavesFromStorage();
            const saveData = allSaves[slotId];
            
            if (!saveData) {
              this.showTemporaryMessage('æ²¡æœ‰æ‰¾åˆ°å­˜æ¡£æ–‡ä»¶ã€‚');
              return;
            }

            const saveName = saveData.save_name || `å­˜æ¡£${slotId.split('_')[1]}`;
            this.showCustomConfirm(`ç¡®å®šè¦è¯»å–å­˜æ¡£"${saveName}"å—ï¼Ÿå½“å‰æ‰€æœ‰æœªä¿å­˜çš„è¿›åº¦å°†ä¼šè¢«è¦†ç›–ã€‚`, async () => {
              try {
                console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] å¼€å§‹è¯»å–å­˜æ¡£"${saveName}"`);
                
                // æ˜¾ç¤ºè¯»æ¡£è¿›åº¦æç¤º
                this.updateWaitingMessage('æ­£åœ¨è¯»å–å­˜æ¡£æ•°æ®ï¼Œè¯·ç¨å€™...');
                
                const messages = await getChatMessages(getCurrentMessageId());
                if (!messages || messages.length === 0) {
                  this.hideWaitingMessage();
                  this.showTemporaryMessage('é”™è¯¯ï¼šæ— æ³•è·å–å½“å‰æ¶ˆæ¯ï¼Œæ— æ³•è¯»æ¡£ã€‚');
                  return;
                }
                
                const messageZero = messages[0];
                const loadedData = saveData.mvu_data;
                const loadedMessageContent = saveData.message_content || '';

                // 1. æ›´æ–°æ¶ˆæ¯æ•°æ®ï¼ˆä½¿ç”¨æ— åˆ·æ–°æ¨¡å¼ï¼‰
                messageZero.data = loadedData;
                messageZero.message = loadedMessageContent;

                // --- 2. ä»ç‹¬ç«‹ä¸–ç•Œä¹¦æ¢å¤åˆ°å½“å‰åºå· ---
                if (saveData.lorebook_entries) {
                  this.updateWaitingMessage('æ­£åœ¨æ¢å¤ä¸–ç•Œä¹¦æ•°æ®...');
                  
                  const entries = saveData.lorebook_entries;
                  const bookName = '1å½’å¢Ÿ';
                  const currentIndex = this.unifiedIndex;
                  const currentJourneyKey = currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹';
                  const currentPastLivesKey = currentIndex > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${currentIndex})` : 'å¾€ä¸–æ¶Ÿæ¼ª';
                  const novelModeIndex = this.unifiedIndex;
                  const currentNovelModeKey = novelModeIndex > 1 ? `å°è¯´æ¨¡å¼(${novelModeIndex})` : 'å°è¯´æ¨¡å¼';

                  try {
                    const allEntries = await TavernHelper.getLorebookEntries(bookName);
                    
                    // æŸ¥æ‰¾å­˜æ¡£çš„ç‹¬ç«‹ä¸–ç•Œä¹¦æ¡ç›®
                    const saveJourneyEntry = allEntries.find(entry => entry.comment === entries.journey_entry_name);
                    const savePastLivesEntry = allEntries.find(entry => entry.comment === entries.past_lives_entry_name);
                    const saveNovelModeEntry = allEntries.find(entry => entry.comment === entries.novel_mode_entry_name);
                    
                    // æŸ¥æ‰¾å½“å‰åºå·çš„ä¸–ç•Œä¹¦æ¡ç›®
                    const currentJourneyEntry = allEntries.find(entry => entry.comment === currentJourneyKey);
                    const currentPastLivesEntry = allEntries.find(entry => entry.comment === currentPastLivesKey);
                    const currentNovelModeEntry = allEntries.find(entry => entry.comment === currentNovelModeKey);
                    
                    const entriesToUpdate = [];
                    
                    // è¦†å†™æœ¬ä¸–å†ç¨‹
                    if (saveJourneyEntry) {
                      const contentToRestore = saveJourneyEntry.content || '';
                      if (currentJourneyEntry) {
                        entriesToUpdate.push({
                          uid: currentJourneyEntry.uid,
                          content: contentToRestore
                        });
                        console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] æ›´æ–°æœ¬ä¸–å†ç¨‹æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                      } else {
                        await TavernHelper.createLorebookEntries(bookName, [{
                          comment: currentJourneyKey,
                          content: contentToRestore,
                          keys: [currentJourneyKey],
                          enabled: true,
                          position: 'before_character_definition',
                          order: 20
                        }]);
                        console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] åˆ›å»ºæœ¬ä¸–å†ç¨‹æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                      }
                    }
                    
                    // è¦†å†™å¾€ä¸–æ¶Ÿæ¼ª
                    if (savePastLivesEntry) {
                      const contentToRestore = savePastLivesEntry.content || '';
                      if (currentPastLivesEntry) {
                        entriesToUpdate.push({
                          uid: currentPastLivesEntry.uid,
                          content: contentToRestore
                        });
                        console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] æ›´æ–°å¾€ä¸–æ¶Ÿæ¼ªæ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                      } else {
                        await TavernHelper.createLorebookEntries(bookName, [{
                          comment: currentPastLivesKey,
                          content: contentToRestore,
                          keys: [currentPastLivesKey],
                          enabled: true,
                          position: 'before_character_definition',
                          order: 19
                        }]);
                        console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] åˆ›å»ºå¾€ä¸–æ¶Ÿæ¼ªæ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                      }
                    }

                    // è¦†å†™å°è¯´æ¨¡å¼
                    if (saveNovelModeEntry) {
                      const contentToRestore = saveNovelModeEntry.content || '';
                      if (currentNovelModeEntry) {
                        entriesToUpdate.push({
                          uid: currentNovelModeEntry.uid,
                          content: contentToRestore
                        });
                        console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] æ›´æ–°å°è¯´æ¨¡å¼æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                      } else {
                        await TavernHelper.createLorebookEntries(bookName, [{
                          comment: currentNovelModeKey,
                          content: contentToRestore,
                          keys: [currentNovelModeKey],
                          enabled: false,
                          position: 'before_character_definition',
                          order: 18
                        }]);
                        console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] åˆ›å»ºå°è¯´æ¨¡å¼æ¡ç›®ï¼Œå†…å®¹é•¿åº¦: ${contentToRestore.length}`);
                      }
                    }
                    
                    // æ‰¹é‡æ›´æ–°ç°æœ‰æ¡ç›®
                    if (entriesToUpdate.length > 0) {
                      await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
                    }
                    
                    console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] å·²å°†å­˜æ¡£"${saveName}"çš„ä¸–ç•Œä¹¦æ•°æ®è¦†å†™åˆ°å½“å‰åºå· ${currentIndex}`);
                    
                  } catch (e) {
                    console.error("æ¢å¤ä¸–ç•Œä¹¦æ•°æ®æ—¶å‡ºé”™:", e);
                    this.showTemporaryMessage("è­¦å‘Šï¼šæ¢å¤ä¸–ç•Œä¹¦æ•°æ®å¤±è´¥ï¼Œä½†ä¸»æ•°æ®å·²æ¢å¤ã€‚");
                  }
                }

                // 3. æ— ç¼æ›´æ–°æ¶ˆæ¯æ•°æ®ï¼ˆå…³é”®ï¼šä½¿ç”¨ refresh: 'none'ï¼‰
                this.updateWaitingMessage('æ­£åœ¨æ›´æ–°ç•Œé¢æ•°æ®...');
                await TavernHelper.setChatMessages([messageZero], { refresh: 'none' });
                
                // 4. ç›´æ¥æ›´æ–°MVUçŠ¶æ€å’ŒUIï¼ˆæ— éœ€é‡æ–°åˆå§‹åŒ–ï¼‰
                this.currentMvuState = this._safeLoadMvuData(loadedData);
                // æ¢å¤GachaçŠ¶æ€åˆ°å†…å­˜
                this._loadGachaDataFromSave(saveData);
                
                // 5. ç›´æ¥æ›´æ–°æ¸¸æˆæ–‡æœ¬æ˜¾ç¤º
                const gameTextDisplay = document.getElementById('game-text-display');
                if (gameTextDisplay && loadedMessageContent) {
                  const displayText = this._getDisplayText(loadedMessageContent);
                  gameTextDisplay.innerHTML = this.formatMessageContent(displayText);
                  this.updateLiveWordCount(); // æ–°å¢ï¼šè°ƒç”¨å­—æ•°ç»Ÿè®¡å‡½æ•°
                  
                  // æ›´æ–°æœ‰æ•ˆå†…å®¹ç¼“å­˜ï¼Œæ”¯æŒåç»­å›é€€åŠŸèƒ½
                  this.lastValidGametxtHTML = gameTextDisplay.innerHTML;
                }
                
                // 6. æ›´æ–°UIæ˜¾ç¤ºï¼ˆåªæ›´æ–°å¿…è¦éƒ¨åˆ†ï¼Œä¿æŒå…¶ä»–çŠ¶æ€ï¼‰
                this.renderUI(this.currentMvuState.stat_data);
                this.loadEquipmentState(); // é‡æ–°åŠ è½½è£…å¤‡çŠ¶æ€
                
                // 7. æå–å¹¶æ›´æ–°ç›¸å…³å†…å®¹
                if (loadedMessageContent) {
                  this.lastExtractedNovelText = this._extractLastTagContent('gametxt', loadedMessageContent);
                  this.lastExtractedJourney = this._extractLastTagContent('æœ¬ä¸–å†ç¨‹', loadedMessageContent);
                  this.lastExtractedPastLives = this._extractLastTagContent('å¾€ä¸–æ¶Ÿæ¼ª', loadedMessageContent);
                  this.lastExtractedThinking = this._extractLastTagContent('thinking', loadedMessageContent, true);
                  this.lastExtractedVariables = this._extractLastTagContent('UpdateVariable', loadedMessageContent, true);
                  
                  // æ›´æ–°ç›¸å…³UIç»„ä»¶
                  this.updateThinkingButtonVisibility();
                  this.updateVariableChangesReminder();
                }

                // æ–°å¢ï¼šè¯»æ¡£æˆåŠŸåï¼Œè§¦å‘ä¸€æ¬¡åˆ†æ®µè®°å¿†æ›´æ–°ï¼Œç¡®ä¿å†…å®¹åŒæ­¥
                if (this.isSegmentedMemoryAutoGenerateEnabled) {
                    console.log('[å½’å¢Ÿ] è¯»æ¡£å®Œæˆï¼Œè§¦å‘åˆ†æ®µè®°å¿†æ›´æ–°...');
                    await this.generateSegmentedMemory(false);
                }

                this.hideWaitingMessage();
                this.showTemporaryMessage(`æ— ç¼è¯»æ¡£"${saveName}"æˆåŠŸï¼`);
                
                // 8. è¯»æ¡£å®Œæˆåå…³é—­å­˜æ¡£ç•Œé¢ï¼Œæ˜¾ç¤ºä¸»ç•Œé¢
                this.closeAllModals();
                
                console.log(`[å½’å¢Ÿæ— ç¼è¯»æ¡£] è¯»æ¡£å®Œæˆï¼Œå·²è¿”å›ä¸»ç•Œé¢`);

              } catch (error) {
                console.error('æ— ç¼è¯»æ¡£å¤±è´¥:', error);
                this.hideWaitingMessage();
                this.showTemporaryMessage(`è¯»æ¡£å¤±è´¥: ${error.message}`);
              }
            });
          },


          deleteSave(slotId) {
            const allSaves = this.getSavesFromStorage();
            const saveData = allSaves[slotId];
            const saveName = saveData?.save_name || `å­˜æ¡£ ${slotId.replace('slot_', '')}`;

            let confirmMessage = `ç¡®å®šè¦åˆ é™¤å­˜æ¡£â€œ${saveName}â€å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`;
            if (saveData && saveData.lorebook_entries) {
                confirmMessage += `\nç›¸å…³çš„ä¸–ç•Œä¹¦æ¡ç›®ä¹Ÿä¼šè¢«ä¸€å¹¶åˆ é™¤ã€‚`;
            }

            this.showCustomConfirm(confirmMessage, async () => {
              try {
                // å¯¹æ‰€æœ‰åŒ…å« lorebook_entries çš„å­˜æ¡£æ‰§è¡Œåˆ é™¤æ“ä½œ
                if (saveData && saveData.lorebook_entries) {
                  const bookName = '1å½’å¢Ÿ';
                  const entryNamesToDelete = Object.values(saveData.lorebook_entries);
                  
                  if (entryNamesToDelete.length > 0) {
                    console.log(`[å½’å¢Ÿåˆ é™¤] å‡†å¤‡åˆ é™¤ä¸–ç•Œä¹¦æ¡ç›®:`, entryNamesToDelete);
                    const allEntries = await TavernHelper.getLorebookEntries(bookName);
                    const uidsToDelete = allEntries
                      .filter(entry => entryNamesToDelete.includes(entry.comment))
                      .map(entry => entry.uid);

                    if (uidsToDelete.length > 0) {
                      await TavernHelper.deleteLorebookEntries(bookName, uidsToDelete);
                      console.log(`[å½’å¢Ÿåˆ é™¤] å·²æˆåŠŸåˆ é™¤ ${uidsToDelete.length} ä¸ªå…³è”çš„ä¸–ç•Œä¹¦æ¡ç›®ã€‚`);
                    }
                  }
                }

                // ä»localStorageä¸­åˆ é™¤å­˜æ¡£è®°å½•
                delete allSaves[slotId];
                localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves));
                
                this.showTemporaryMessage(`å­˜æ¡£â€œ${saveName}â€å·²åˆ é™¤ã€‚`);
                this.showSaveLoadManager(); // åˆ·æ–°UI

              } catch (error) {
                console.error('åˆ é™¤å­˜æ¡£å¤±è´¥:', error);
                this.showTemporaryMessage(`åˆ é™¤å­˜æ¡£å¤±è´¥: ${error.message}`);
              }
            });
          },

          clearAllSaves() {
            this.showCustomConfirm(`ä½ ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰å­˜æ¡£å—ï¼Ÿè¿™ä¸ªæ“ä½œä¼šåˆ é™¤æ‰€æœ‰5ä¸ªå­˜æ¡£æ§½ä½çš„æ•°æ®ï¼Œä¸”ä¸å¯æ¢å¤ã€‚`, () => {
              try {
                localStorage.removeItem('guixu_multi_save_data');
                this.showTemporaryMessage(`æ‰€æœ‰å­˜æ¡£å·²æ¸…é™¤ã€‚`);
                this.showSaveLoadManager(); // åˆ·æ–°UI
              } catch (error) {
                console.error('æ¸…é™¤æ‰€æœ‰å­˜æ¡£å¤±è´¥:', error);
                this.showTemporaryMessage(`æ¸…é™¤å­˜æ¡£å¤±è´¥: ${error.message}`);
              }
            });
          },

          // --- æ–°å¢ï¼šå­˜æ¡£å‘½åè¾“å…¥æ¡† ---
          async promptForSaveName(slotId) {
            console.log('[å½’å¢Ÿå­˜æ¡£] æ˜¾ç¤ºå­˜æ¡£å‘½åå¯¹è¯æ¡†');
            return new Promise((resolve) => {
              try {
                // åˆ›å»ºæ¨¡æ€æ¡†
                const modal = document.createElement('div');
                modal.className = 'modal-overlay';
                modal.style.display = 'flex';
                modal.style.zIndex = '2000'; // ç¡®ä¿åœ¨æœ€é¡¶å±‚
                modal.innerHTML = `
                  <div class="modal-content" style="width: 400px; height: auto; max-height: none;">
                    <div class="modal-header">
                      <h2 class="modal-title">å­˜æ¡£å‘½å</h2>
                    </div>
                    <div class="modal-body" style="padding: 20px;">
                      <p style="margin-bottom: 15px; color: #c9aa71;">è¯·ä¸ºå­˜æ¡£ä½ ${slotId.split('_')[1]} è¾“å…¥ä¸€ä¸ªåç§°ï¼š</p>
                      <input type="text" id="save-name-input" placeholder="ä¾‹å¦‚ï¼šçªç ´é‡‘ä¸¹æœŸ"
                             style="width: 100%; padding: 10px; background: rgba(0,0,0,0.5); border: 1px solid #8b7355;
                                    color: #e0dcd1; border-radius: 4px; font-size: 14px; margin-bottom: 15px;">
                      <p style="font-size: 12px; color: #8b7355; margin-bottom: 20px;">
                        å°†åˆ›å»ºä¸–ç•Œä¹¦æ¡ç›®ï¼š<br>
                        â€¢ <span id="preview-journey">å­˜æ¡£å-æœ¬ä¸–å†ç¨‹</span><br>
                        â€¢ <span id="preview-past-lives">å­˜æ¡£å-å¾€ä¸–æ¶Ÿæ¼ª</span><br>
                        â€¢ <span id="preview-novel-mode">å­˜æ¡£å-å°è¯´æ¨¡å¼</span>
                      </p>
                      <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button id="save-name-cancel" class="interaction-btn">å–æ¶ˆ</button>
                        <button id="save-name-confirm" class="interaction-btn primary-btn">ç¡®è®¤</button>
                      </div>
                    </div>
                  </div>
                `;

                const container = document.querySelector('.guixu-root-container');
                if (!container) {
                  console.error('[å½’å¢Ÿå­˜æ¡£] æ‰¾ä¸åˆ°æ ¹å®¹å™¨');
                  resolve(null);
                  return;
                }
                container.appendChild(modal);

                const input = modal.querySelector('#save-name-input');
                const previewJourney = modal.querySelector('#preview-journey');
                const previewPastLives = modal.querySelector('#preview-past-lives');
                const previewNovelMode = modal.querySelector('#preview-novel-mode');
                const confirmBtn = modal.querySelector('#save-name-confirm');
                const cancelBtn = modal.querySelector('#save-name-cancel');

                if (!input || !confirmBtn || !cancelBtn) {
                  console.error('[å½’å¢Ÿå­˜æ¡£] æ¨¡æ€æ¡†å…ƒç´ åˆ›å»ºå¤±è´¥');
                  modal.remove();
                  resolve(null);
                  return;
                }

                // å®æ—¶æ›´æ–°é¢„è§ˆ
                input.addEventListener('input', () => {
                  const name = input.value.trim() || 'å­˜æ¡£å';
                  if (previewJourney) previewJourney.textContent = `${name}-æœ¬ä¸–å†ç¨‹`;
                  if (previewPastLives) previewPastLives.textContent = `${name}-å¾€ä¸–æ¶Ÿæ¼ª`;
                  if (previewNovelMode) previewNovelMode.textContent = `${name}-å°è¯´æ¨¡å¼`;
                });

                // ç¡®è®¤æŒ‰é’®
                confirmBtn.addEventListener('click', () => {
                  const saveName = input.value.trim();
                  if (!saveName) {
                    this.showTemporaryMessage('è¯·è¾“å…¥å­˜æ¡£åç§°');
                    return;
                  }
                  console.log('[å½’å¢Ÿå­˜æ¡£] ç”¨æˆ·è¾“å…¥å­˜æ¡£åç§°:', saveName);
                  modal.remove();
                  resolve(saveName);
                });

                // å–æ¶ˆæŒ‰é’®
                cancelBtn.addEventListener('click', () => {
                  console.log('[å½’å¢Ÿå­˜æ¡£] ç”¨æˆ·å–æ¶ˆå­˜æ¡£');
                  modal.remove();
                  resolve(null);
                });

                // å›è½¦ç¡®è®¤
                input.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') {
                    confirmBtn.click();
                  }
                });

                // è‡ªåŠ¨èšç„¦
                setTimeout(() => {
                  try {
                    input.focus();
                  } catch (e) {
                    console.warn('[å½’å¢Ÿå­˜æ¡£] è‡ªåŠ¨èšç„¦å¤±è´¥:', e);
                  }
                }, 100);

              } catch (error) {
                console.error('[å½’å¢Ÿå­˜æ¡£] åˆ›å»ºå­˜æ¡£å‘½åå¯¹è¯æ¡†æ—¶å‡ºé”™:', error);
                resolve(null);
              }
            });
          },

          // --- æ–°å¢ï¼šè‡ªåŠ¨å­˜æ¡£æ ¸å¿ƒåŠŸèƒ½ ---
          saveAutoSaveState() {
            try {
              localStorage.setItem('guixu_auto_save_enabled', this.isAutoSaveEnabled);
            } catch (e) {
              console.error('ä¿å­˜è‡ªåŠ¨å­˜æ¡£çŠ¶æ€å¤±è´¥:', e);
            }
          },

          loadAutoSaveState() {
            try {
              const savedState = localStorage.getItem('guixu_auto_save_enabled');
              this.isAutoSaveEnabled = savedState === 'true'; // é»˜è®¤ä¸º false
              const checkbox = document.getElementById('auto-save-checkbox');
              if (checkbox) {
                checkbox.checked = this.isAutoSaveEnabled;
              }
            } catch (e) {
              console.error('åŠ è½½è‡ªåŠ¨å­˜æ¡£çŠ¶æ€å¤±è´¥:', e);
              this.isAutoSaveEnabled = false;
            }
          },

          async performAutoSave() {
            console.log('[å½’å¢Ÿ] æ‰§è¡Œäº”ç¼“å†²è‡ªåŠ¨å­˜æ¡£...');
            try {
                // --- 1. æ•°æ®å‡†å¤‡ ---
                const currentMvuData = this.currentMvuState;
                let currentMessageContent = '';
                try {
                    const messages = await getChatMessages(getCurrentMessageId());
                    if (messages && messages.length > 0) {
                        const lastAiMessage = [...messages].reverse().find(m => m.role === 'assistant');
                        if (lastAiMessage) currentMessageContent = lastAiMessage.message || '';
                    }
                } catch (e) {
                    console.warn('[å½’å¢Ÿè‡ªåŠ¨å­˜æ¡£] è·å–æ¶ˆæ¯å†…å®¹å¤±è´¥:', e);
                }

                if (!currentMvuData || !currentMvuData.stat_data) {
                    console.error('[å½’å¢Ÿè‡ªåŠ¨å­˜æ¡£] MVUæ•°æ®ä¸å®Œæ•´ï¼Œè‡ªåŠ¨å­˜æ¡£å¤±è´¥ã€‚');
                    return;
                }

                const bookName = '1å½’å¢Ÿ';
                const allSaves = this.getSavesFromStorage();
                const allEntries = await TavernHelper.getLorebookEntries(bookName);
                
                const autoSaveConfig = [
                    { id: 'auto_save_slot_0', name: 'è‡ªåŠ¨å­˜æ¡£-1 (æœ€æ–°)' },
                    { id: 'auto_save_slot_1', name: 'è‡ªåŠ¨å­˜æ¡£-2' },
                    { id: 'auto_save_slot_2', name: 'è‡ªåŠ¨å­˜æ¡£-3' },
                    { id: 'auto_save_slot_3', name: 'è‡ªåŠ¨å­˜æ¡£-4' },
                    { id: 'auto_save_slot_4', name: 'è‡ªåŠ¨å­˜æ¡£-5 (æœ€æ—§)' }
                ];
                const numSlots = autoSaveConfig.length;

                // --- 2. è½®æ¢ localStorage ä¸­çš„å­˜æ¡£æ•°æ® (ä»åå¾€å‰) ---
                for (let i = numSlots - 1; i > 0; i--) {
                    const currentSlotId = autoSaveConfig[i].id;
                    const previousSlotId = autoSaveConfig[i - 1].id;
                    if (allSaves[previousSlotId]) {
                        allSaves[currentSlotId] = allSaves[previousSlotId];
                    }
                }

                // --- 3. è½®æ¢ä¸–ç•Œä¹¦æ¡ç›® (ä»åå¾€å‰) ---
                const entriesToUpdate = [];
                const entriesToCreate = [];

                for (let i = numSlots - 1; i > 0; i--) {
                    const currentConfig = autoSaveConfig[i];
                    const prevConfig = autoSaveConfig[i - 1];

                    const prevJourneyKey = `è‡ªåŠ¨å­˜æ¡£(${prevConfig.name})ï¼šæœ¬ä¸–å†ç¨‹`;
                    const prevPastLivesKey = `è‡ªåŠ¨å­˜æ¡£(${prevConfig.name})ï¼šå¾€ä¸–æ¶Ÿæ¼ª`;
                    const prevNovelModeKey = `è‡ªåŠ¨å­˜æ¡£(${prevConfig.name})ï¼šå°è¯´æ¨¡å¼`;

                    const currentJourneyKey = `è‡ªåŠ¨å­˜æ¡£(${currentConfig.name})ï¼šæœ¬ä¸–å†ç¨‹`;
                    const currentPastLivesKey = `è‡ªåŠ¨å­˜æ¡£(${currentConfig.name})ï¼šå¾€ä¸–æ¶Ÿæ¼ª`;
                    const currentNovelModeKey = `è‡ªåŠ¨å­˜æ¡£(${currentConfig.name})ï¼šå°è¯´æ¨¡å¼`;

                    const prevJourneyEntry = allEntries.find(e => e.comment === prevJourneyKey);
                    const prevPastLivesEntry = allEntries.find(e => e.comment === prevPastLivesKey);
                    const prevNovelModeEntry = allEntries.find(e => e.comment === prevNovelModeKey);

                    const currentJourneyEntry = allEntries.find(e => e.comment === currentJourneyKey);
                    const currentPastLivesEntry = allEntries.find(e => e.comment === currentPastLivesKey);
                    const currentNovelModeEntry = allEntries.find(e => e.comment === currentNovelModeKey);

                    if (prevJourneyEntry) {
                        if (currentJourneyEntry) entriesToUpdate.push({ uid: currentJourneyEntry.uid, content: prevJourneyEntry.content });
                        else entriesToCreate.push({ comment: currentJourneyKey, content: prevJourneyEntry.content, keys: [currentJourneyKey], enabled: false, position: 'before_character_definition', order: 18 - i });
                    }
                    if (prevPastLivesEntry) {
                        if (currentPastLivesEntry) entriesToUpdate.push({ uid: currentPastLivesEntry.uid, content: prevPastLivesEntry.content });
                        else entriesToCreate.push({ comment: currentPastLivesKey, content: prevPastLivesEntry.content, keys: [currentPastLivesKey], enabled: false, position: 'before_character_definition', order: 17 - i });
                    }
                    if (prevNovelModeEntry) {
                        if (currentNovelModeEntry) entriesToUpdate.push({ uid: currentNovelModeEntry.uid, content: prevNovelModeEntry.content });
                        else entriesToCreate.push({ comment: currentNovelModeKey, content: prevNovelModeEntry.content, keys: [currentNovelModeKey], enabled: false, position: 'before_character_definition', order: 16 - i });
                    }
                }

                // --- 4. è·å–å½“å‰æ¸¸æˆå†…å®¹ï¼Œå¹¶å†™å…¥æœ€æ–°çš„å­˜æ¡£æ§½ä½ (slot 0) ---
                const latestConfig = autoSaveConfig[0];
                const latestJourneyKey = `è‡ªåŠ¨å­˜æ¡£(${latestConfig.name})ï¼šæœ¬ä¸–å†ç¨‹`;
                const latestPastLivesKey = `è‡ªåŠ¨å­˜æ¡£(${latestConfig.name})ï¼šå¾€ä¸–æ¶Ÿæ¼ª`;
                const latestNovelModeKey = `è‡ªåŠ¨å­˜æ¡£(${latestConfig.name})ï¼šå°è¯´æ¨¡å¼`;

                const latestJourneyEntry = allEntries.find(e => e.comment === latestJourneyKey);
                const latestPastLivesEntry = allEntries.find(e => e.comment === latestPastLivesKey);
                const latestNovelModeEntry = allEntries.find(e => e.comment === latestNovelModeKey);

                const currentJourneyEntry = allEntries.find(entry => entry.comment === (this.unifiedIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${this.unifiedIndex})` : 'æœ¬ä¸–å†ç¨‹'));
                const currentPastLivesEntry = allEntries.find(entry => entry.comment === (this.unifiedIndex > 1 ? `å¾€ä¸–æ¶Ÿæ¼ª(${this.unifiedIndex})` : 'å¾€ä¸–æ¶Ÿæ¼ª'));
                const currentNovelModeEntry = allEntries.find(entry => entry.comment === (this.unifiedIndex > 1 ? `å°è¯´æ¨¡å¼(${this.unifiedIndex})` : 'å°è¯´æ¨¡å¼'));
                
                const journeyContent = currentJourneyEntry ? currentJourneyEntry.content : '';
                const pastLivesContent = currentPastLivesEntry ? currentPastLivesEntry.content : '';
                const novelModeContent = currentNovelModeEntry ? currentNovelModeEntry.content : '';

                if (latestJourneyEntry) entriesToUpdate.push({ uid: latestJourneyEntry.uid, content: journeyContent });
                else entriesToCreate.push({ comment: latestJourneyKey, content: journeyContent, keys: [latestJourneyKey], enabled: false, position: 'before_character_definition', order: 20 });

                if (latestPastLivesEntry) entriesToUpdate.push({ uid: latestPastLivesEntry.uid, content: pastLivesContent });
                else entriesToCreate.push({ comment: latestPastLivesKey, content: pastLivesContent, keys: [latestPastLivesKey], enabled: false, position: 'before_character_definition', order: 19 });
                
                if (latestNovelModeEntry) entriesToUpdate.push({ uid: latestNovelModeEntry.uid, content: novelModeContent });
                else entriesToCreate.push({ comment: latestNovelModeKey, content: novelModeContent, keys: [latestNovelModeKey], enabled: false, position: 'before_character_definition', order: 18 });

                // --- 5. æ‰§è¡Œä¸–ç•Œä¹¦æ“ä½œ ---
                if (entriesToCreate.length > 0) await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                if (entriesToUpdate.length > 0) await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);

                // --- 6. åˆ›å»ºæ–°çš„â€œæœ€æ–°â€å­˜æ¡£å¹¶ä¿å­˜ ---
                const newSaveDataPayload = {
                    timestamp: new Date().toISOString(),
                    save_name: latestConfig.name,
                    message_content: currentMessageContent,
                    mvu_data: currentMvuData,
                    is_auto_save: true,
                    gacha_data: {
                        state: _.cloneDeep(this.gachaState),
                        collection: _.cloneDeep(this.gachaCollection),
                        history: _.cloneDeep(this.gachaHistory)
                    },
                    lorebook_entries: {
                        journey_entry_name: latestJourneyKey,
                        past_lives_entry_name: latestPastLivesKey,
                        novel_mode_entry_name: latestNovelModeKey
                    }
                };
                allSaves[latestConfig.id] = newSaveDataPayload;
                
                // --- 7. æ›´æ–°æ‰€æœ‰è‡ªåŠ¨å­˜æ¡£çš„åç§°å’Œå…³è”æ¡ç›® ---
                for (const config of autoSaveConfig) {
                    if (allSaves[config.id]) {
                        allSaves[config.id].save_name = config.name;
                        allSaves[config.id].lorebook_entries = {
                            journey_entry_name: `è‡ªåŠ¨å­˜æ¡£(${config.name})ï¼šæœ¬ä¸–å†ç¨‹`,
                            past_lives_entry_name: `è‡ªåŠ¨å­˜æ¡£(${config.name})ï¼šå¾€ä¸–æ¶Ÿæ¼ª`,
                            novel_mode_entry_name: `è‡ªåŠ¨å­˜æ¡£(${config.name})ï¼šå°è¯´æ¨¡å¼`
                        };
                    }
                }

                localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves));

                this.showTemporaryMessage('è‡ªåŠ¨å­˜æ¡£æˆåŠŸ', 1500);
                console.log('[å½’å¢Ÿ] äº”ç¼“å†²è‡ªåŠ¨å­˜æ¡£æˆåŠŸã€‚');

            } catch (error) {
                console.error('[å½’å¢Ÿ] è‡ªåŠ¨å­˜æ¡£å¤±è´¥:', error);
                this.showTemporaryMessage(`è‡ªåŠ¨å­˜æ¡£å¤±è´¥: ${error.message}`);
            }
          },

          // --- æ–°å¢ï¼šå­˜æ¡£å¯¼å…¥/å¯¼å‡ºåŠŸèƒ½ ---
          async exportSave(slotId) {
            this.showTemporaryMessage('æ­£åœ¨å‡†å¤‡å¯¼å‡ºæ•°æ®...', 2000);
            try {
                const allSaves = this.getSavesFromStorage();
                const saveData = allSaves[slotId];

                if (!saveData) {
                    this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°è¦å¯¼å‡ºçš„å­˜æ¡£æ•°æ®ã€‚');
                    return;
                }

                const exportData = {
                    exportVersion: '1.0',
                    exportedAt: new Date().toISOString(),
                    saveData: saveData,
                    lorebookData: []
                };

                // å¦‚æœå­˜åœ¨ä¸–ç•Œä¹¦æ¡ç›®å…³è”ï¼Œåˆ™è¯»å–å…¶å†…å®¹
                if (saveData.lorebook_entries && typeof saveData.lorebook_entries === 'object') {
                    const bookName = '1å½’å¢Ÿ';
                    const entryNamesToExport = Object.values(saveData.lorebook_entries);
                    if (entryNamesToExport.length > 0) {
                        const allLorebookEntries = await TavernHelper.getLorebookEntries(bookName);
                        exportData.lorebookData = allLorebookEntries.filter(entry =>
                            entryNamesToExport.includes(entry.comment)
                        );
                    }
                }

                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                const safeSaveName = (saveData.save_name || slotId).replace(/[^a-z0-9_\-]/gi, '_');
                a.download = `GuixuSave_${safeSaveName}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                this.showTemporaryMessage('å­˜æ¡£å·²æˆåŠŸå¯¼å‡ºï¼');

            } catch (error) {
                console.error('å¯¼å‡ºå­˜æ¡£æ—¶å‡ºé”™:', error);
                this.showTemporaryMessage(`å¯¼å‡ºå¤±è´¥: ${error.message}`);
            }
          },

          async handleFileImport(event) {
              const file = event.target.files[0];
              if (!file) return;

              this.showTemporaryMessage('æ­£åœ¨å¯¼å…¥å­˜æ¡£...', 3000);
              const reader = new FileReader();

              reader.onload = async (e) => {
                  try {
                      const importData = JSON.parse(e.target.result);

                      // 1. éªŒè¯å¯¼å…¥æ•°æ®
                      if (importData.exportVersion !== '1.0' || !importData.saveData || !importData.lorebookData) {
                          throw new Error('å­˜æ¡£æ–‡ä»¶æ ¼å¼æ— æ•ˆæˆ–å·²æŸåã€‚');
                      }

                      const allSaves = this.getSavesFromStorage();
                      
                      // 2. å¯»æ‰¾ç©ºçš„æ‰‹åŠ¨å­˜æ¡£æ§½ä½
                      let emptySlotId = null;
                      for (let i = 1; i <= 5; i++) {
                          const slotId = `slot_${i}`;
                          if (!allSaves[slotId]) {
                              emptySlotId = slotId;
                              break;
                          }
                      }

                      if (!emptySlotId) {
                          throw new Error('æ²¡æœ‰å¯ç”¨çš„æ‰‹åŠ¨å­˜æ¡£æ§½ä½ã€‚è¯·å…ˆåˆ é™¤ä¸€ä¸ªã€‚');
                      }

                      const bookName = '1å½’å¢Ÿ';
                      const currentEntries = await TavernHelper.getLorebookEntries(bookName);
                      const currentEntryNames = new Set(currentEntries.map(entry => entry.comment));
                      
                      const newSaveData = _.cloneDeep(importData.saveData);
                      const entriesToCreate = [];

                      // 3. å¤„ç†ä¸–ç•Œä¹¦æ¡ç›®å†²çªå¹¶å‡†å¤‡åˆ›å»º
                      for (const entryToImport of importData.lorebookData) {
                          let newEntryName = entryToImport.comment;
                          let originalEntryName = entryToImport.comment;

                          // å¦‚æœæ¡ç›®åå·²å­˜åœ¨ï¼Œåˆ™é‡å‘½å
                          if (currentEntryNames.has(newEntryName)) {
                              newEntryName = `${newEntryName}_imported_${Date.now()}`;
                              this.showTemporaryMessage(`ä¸–ç•Œä¹¦æ¡ç›®â€œ${originalEntryName}â€å·²å­˜åœ¨ï¼Œé‡å‘½åä¸ºâ€œ${newEntryName}â€`, 4000);
                          }
                          
                          const newEntry = { ...entryToImport };
                          delete newEntry.uid; // å¿…é¡»åˆ é™¤æ—§çš„uid
                          newEntry.comment = newEntryName;
                          newEntry.keys = [newEntryName]; // æ›´æ–°å…³é”®å­—
                          newEntry.enabled = false; // å¯¼å…¥åé»˜è®¤ç¦ç”¨
                          entriesToCreate.push(newEntry);

                          // 4. æ›´æ–°å­˜æ¡£æ•°æ®ä¸­å¯¹ä¸–ç•Œä¹¦æ¡ç›®çš„å¼•ç”¨
                          for (const key in newSaveData.lorebook_entries) {
                              if (newSaveData.lorebook_entries[key] === originalEntryName) {
                                  newSaveData.lorebook_entries[key] = newEntryName;
                              }
                          }
                      }
                      
                      // 5. åˆ›å»ºä¸–ç•Œä¹¦æ¡ç›®
                      if (entriesToCreate.length > 0) {
                          await TavernHelper.createLorebookEntries(bookName, entriesToCreate);
                      }

                      // 6. å†™å…¥å­˜æ¡£æ•°æ®åˆ°localStorage
                      newSaveData.save_name = `${newSaveData.save_name} (å¯¼å…¥)`; // æ ‡è®°ä¸ºå¯¼å…¥å­˜æ¡£
                      allSaves[emptySlotId] = newSaveData;
                      localStorage.setItem('guixu_multi_save_data', JSON.stringify(allSaves));

                      this.showTemporaryMessage(`å­˜æ¡£å·²æˆåŠŸå¯¼å…¥åˆ°æ§½ä½ ${emptySlotId.split('_')[1]}ï¼`);
                      this.showSaveLoadManager(); // åˆ·æ–°UI

                  } catch (error) {
                      console.error('å¯¼å…¥å­˜æ¡£æ—¶å‡ºé”™:', error);
                      this.showTemporaryMessage(`å¯¼å…¥å¤±è´¥: ${error.message}`);
                  } finally {
                      // æ¸…ç©ºfile inputçš„å€¼ï¼Œä»¥ä¾¿å¯ä»¥å†æ¬¡é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶
                      event.target.value = '';
                  }
              };

              reader.readAsText(file);
          },

           // --- æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹çŠ¶æ€å­˜å– ---
           saveActionOptionsState() {
             try {
               localStorage.setItem('guixu_action_options_enabled', this.isActionOptionsEnabled);
             } catch (e) {
               console.error('ä¿å­˜è¡ŒåŠ¨é€‰é¡¹çŠ¶æ€å¤±è´¥:', e);
             }
         },
         // --- æ–°å¢ï¼šè¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€å­˜å– ---
         saveActionAutoSendState() {
           try {
             localStorage.setItem('guixu_action_auto_send_enabled', this.isActionAutoSend);
           } catch (e) {
             console.error('ä¿å­˜è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€å¤±è´¥:', e);
           }
         },
         loadActionAutoSendState() {
           try {
             const savedState = localStorage.getItem('guixu_action_auto_send_enabled');
             // é»˜è®¤ä¸º true (å¼€å¯)
             this.isActionAutoSend = savedState === null ? true : savedState === 'true';
             const checkbox = document.getElementById('auto-send-action-checkbox');
             if (checkbox) {
               checkbox.checked = this.isActionAutoSend;
             }
           } catch (e) {
             console.error('åŠ è½½è¡ŒåŠ¨é€‰é¡¹è‡ªåŠ¨å‘é€çŠ¶æ€å¤±è´¥:', e);
             this.isActionAutoSend = true;
           }
         },

           loadActionOptionsState() {
             try {
               const savedState = localStorage.getItem('guixu_action_options_enabled');
               // é»˜è®¤ä¸º true (å¼€å¯)
               this.isActionOptionsEnabled = savedState === null ? true : savedState === 'true';
               const checkbox = document.getElementById('action-options-enabled-checkbox');
               if (checkbox) {
                 checkbox.checked = this.isActionOptionsEnabled;
               }
             } catch (e) {
               console.error('åŠ è½½è¡ŒåŠ¨é€‰é¡¹çŠ¶æ€å¤±è´¥:', e);
               this.isActionOptionsEnabled = true;
             }
           },

          // --- æ–°å¢ï¼šè‡ªåŠ¨åŒ–ç³»ç»Ÿä¿®å‰ªåŠŸèƒ½ ---
          showTrimJourneyModal() {
              this.openModal('trim-journey-modal', true); // keepOpen = true to show over history modal
              const indexInput = document.getElementById('trim-journey-index-input');
              if (indexInput) {
                  indexInput.value = this.unifiedIndex;
              }
          },

          _getTrimmedJourneyContent(fullContent) {
              if (!fullContent) return fullContent;
              const events = this.parseJourneyEntry(fullContent);
              if (events.length <= 2) {
                  return fullContent; // ä¸éœ€è¦ä¿®å‰ª
              }

              let trimCount = 0;
              events.forEach((event, idx) => {
                  if (idx < events.length - 2) {
                      if (event['è‡ªåŠ¨åŒ–ç³»ç»Ÿ']) {
                          delete event['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];
                          trimCount++;
                      }
                  }
              });

              if (trimCount === 0) {
                  return fullContent; // æ²¡æœ‰å†…å®¹è¢«æ”¹å˜
              }

              // é‡æ„å†…å®¹å­—ç¬¦ä¸²
              const newContent = events.map(event => {
                  const fieldOrder = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'åœ°ç‚¹', 'äººç‰©', 'æè¿°', 'äººç‰©å…³ç³»', 'æ ‡ç­¾', 'é‡è¦ä¿¡æ¯', 'æš—çº¿ä¸ä¼ç¬”', 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];
                  return fieldOrder
                      .map(key => (event[key] ? `${key}|${event[key]}` : null))
                      .filter(Boolean)
                      .join('\n');
              }).join('\n\n');

              console.log(`[å½’å¢Ÿ-å†…éƒ¨ä¿®å‰ª] æˆåŠŸç§»é™¤ ${trimCount} æ¡è‡ªåŠ¨åŒ–ç³»ç»Ÿè®°å½•ã€‚`);
              return newContent;
          },

          async trimJourneyAutomation(index, silent = false) {
              const bookName = '1å½’å¢Ÿ';
              const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
              if (!silent) this.showTemporaryMessage(`æ­£åœ¨å¼€å§‹ä¿®å‰ªåºå· ${index} çš„æœ¬ä¸–å†ç¨‹...`);

              try {
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                  if (!journeyEntry || !journeyEntry.content) {
                      if (!silent) this.showTemporaryMessage(`é”™è¯¯ï¼šæ‰¾ä¸åˆ°æˆ–å†…å®¹ä¸ºç©ºï¼Œæ— æ³•ä¿®å‰ªã€‚`, 3000);
                      return;
                  }

                  const newContent = this._getTrimmedJourneyContent(journeyEntry.content);

                  if (newContent === journeyEntry.content) {
                      if (!silent) this.showTemporaryMessage('æ²¡æœ‰éœ€è¦ä¿®å‰ªçš„è‡ªåŠ¨åŒ–å†…å®¹ã€‚');
                      return;
                  }
                  
                  await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);

                  if (!silent) {
                    this.showTemporaryMessage(`ä¿®å‰ªæˆåŠŸï¼`, 3000);
                    this.closeModal('trim-journey-modal');
                    this.showJourney(); // åˆ·æ–°è§†å›¾
                  }

              } catch (error) {
                  console.error('ä¿®å‰ªæœ¬ä¸–å†ç¨‹æ—¶å‡ºé”™:', error);
                  if (!silent) this.showTemporaryMessage(`ä¿®å‰ªå¤±è´¥: ${error.message}`, 3000);
              }
          },

          // --- æ–°å¢ï¼šè‡ªåŠ¨ä¿®å‰ªçŠ¶æ€å­˜å– ---
          saveAutoTrimState() {
              try {
                  localStorage.setItem('guixu_auto_trim_enabled', this.isAutoTrimEnabled);
              } catch (e) {
                  console.error('ä¿å­˜è‡ªåŠ¨ä¿®å‰ªçŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadAutoTrimState() {
              try {
                  const savedState = localStorage.getItem('guixu_auto_trim_enabled');
                  this.isAutoTrimEnabled = savedState === 'true'; // é»˜è®¤ä¸º false
                  // æ³¨æ„ï¼šå¤é€‰æ¡†æ˜¯åœ¨ showJourney æ—¶åŠ¨æ€åˆ›å»ºçš„ï¼Œæ‰€ä»¥åœ¨è¿™é‡Œæ— æ³•ç›´æ¥æ›´æ–°å®ƒ
              } catch (e) {
                  console.error('åŠ è½½è‡ªåŠ¨ä¿®å‰ªçŠ¶æ€å¤±è´¥:', e);
                  this.isAutoTrimEnabled = false;
              }
          },

         // --- æ–°å¢ï¼šæµå¼å¼€å…³çŠ¶æ€å­˜å– ---
         saveStreamingState() {
             try {
                 localStorage.setItem('guixu_streaming_enabled', this.isStreamingEnabled);
             } catch (e) {
                 console.error('ä¿å­˜æµå¼çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadStreamingState() {
             try {
                 const savedState = localStorage.getItem('guixu_streaming_enabled');
                 // é»˜è®¤ä¸º true (å¼€å¯)
                 this.isStreamingEnabled = savedState === null ? true : savedState === 'true';
                 const checkbox = document.getElementById('streaming-enabled-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isStreamingEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½æµå¼çŠ¶æ€å¤±è´¥:', e);
                 this.isStreamingEnabled = true;
             }
         },

         // --- æ–°å¢ï¼šæ ¼å¼å®¡æŸ¥çŠ¶æ€å­˜å– ---
         saveFormatValidationState() {
             try {
                 localStorage.setItem('guixu_format_validation_enabled', this.isFormatValidationEnabled);
             } catch (e) {
                 console.error('ä¿å­˜æ ¼å¼å®¡æŸ¥çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadFormatValidationState() {
             try {
                 const savedState = localStorage.getItem('guixu_format_validation_enabled');
                 // é»˜è®¤ä¸º true (å¼€å¯)
                 this.isFormatValidationEnabled = savedState === null ? true : savedState === 'true';
                 const checkbox = document.getElementById('format-validation-enabled-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isFormatValidationEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½æ ¼å¼å®¡æŸ¥çŠ¶æ€å¤±è´¥:', e);
                 this.isFormatValidationEnabled = true;
             }
         },

         // --- æ–°å¢ï¼šå›è½¦å‘é€çŠ¶æ€å­˜å– ---
         saveEnterSendState() {
             try {
                 localStorage.setItem('guixu_enter_send_enabled', this.isEnterSendEnabled);
             } catch (e) {
                 console.error('ä¿å­˜å›è½¦å‘é€çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadEnterSendState() {
             try {
                 const savedState = localStorage.getItem('guixu_enter_send_enabled');
                 // é»˜è®¤ä¸º false (å…³é—­)
                 this.isEnterSendEnabled = savedState === 'true';
                 const checkbox = document.getElementById('enter-send-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isEnterSendEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½å›è½¦å‘é€çŠ¶æ€å¤±è´¥:', e);
                 this.isEnterSendEnabled = false;
             }
         },

         // --- æ–°å¢ï¼šé”®ç›˜å¿«æ·é”®çŠ¶æ€å­˜å– ---
         saveKeyboardShortcutsState() {
             try {
                 localStorage.setItem('guixu_keyboard_shortcuts_enabled', this.isKeyboardShortcutsEnabled);
             } catch (e) {
                 console.error('ä¿å­˜é”®ç›˜å¿«æ·é”®çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadKeyboardShortcutsState() {
             try {
                 const savedState = localStorage.getItem('guixu_keyboard_shortcuts_enabled');
                 // é»˜è®¤ä¸º true (å¼€å¯)
                 this.isKeyboardShortcutsEnabled = savedState !== 'false';
                 const checkbox = document.getElementById('keyboard-shortcuts-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isKeyboardShortcutsEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½é”®ç›˜å¿«æ·é”®çŠ¶æ€å¤±è´¥:', e);
                 this.isKeyboardShortcutsEnabled = true;
             }
         },

         // --- æ–°å¢ï¼šæ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€å­˜å– ---
         saveMobileInputAdaptState() {
             try {
                 localStorage.setItem('guixu_mobile_input_adapt_enabled', this.isMobileInputAdaptEnabled);
             } catch (e) {
                 console.error('ä¿å­˜æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€å¤±è´¥:', e);
             }
         },
         loadMobileInputAdaptState() {
             try {
                 const savedState = localStorage.getItem('guixu_mobile_input_adapt_enabled');
                 // é»˜è®¤ä¸º false (å…³é—­)
                 this.isMobileInputAdaptEnabled = savedState === 'true';
                 const checkbox = document.getElementById('mobile-input-adapt-checkbox');
                 if (checkbox) {
                     checkbox.checked = this.isMobileInputAdaptEnabled;
                 }
             } catch (e) {
                 console.error('åŠ è½½æ‰‹æœºè¾“å…¥æ¡†é€‚é…çŠ¶æ€å¤±è´¥:', e);
                 this.isMobileInputAdaptEnabled = false;
             }
         },

         // --- æ–°å¢ï¼šå†ç¨‹ä¿®å‰ªåŠŸèƒ½å¤„ç†å‡½æ•° ---
          reconstructJourneyEntry(events) {
            if (!Array.isArray(events)) return '';

            const fieldOrder = ['åºå·', 'æ—¥æœŸ', 'æ ‡é¢˜', 'åœ°ç‚¹', 'äººç‰©', 'æè¿°', 'äººç‰©å…³ç³»', 'æ ‡ç­¾', 'é‡è¦ä¿¡æ¯', 'æš—çº¿ä¸ä¼ç¬”', 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];

            return events.map(event => {
                return fieldOrder
                    .map(key => {
                        // æ£€æŸ¥å±æ€§æ˜¯å¦å­˜åœ¨ä¸”ä¸ä¸ºnull/undefined
                        if (event[key] !== undefined && event[key] !== null) {
                            return `${key}|${String(event[key]).trim()}`;
                        }
                        return null;
                    })
                    .filter(Boolean) // è¿‡æ»¤æ‰nullæˆ–undefinedçš„æ¡ç›®
                    .join('\n');
            }).join('\n\n');
          },

          async handlePreciseTrim() {
            // 1. è·å–è¦æ“ä½œçš„æ¡ç›®
            const checkedBoxes = document.querySelectorAll('#history-modal-body .journey-trim-checkbox:checked');
            if (checkedBoxes.length === 0) {
                this.showTemporaryMessage('è¯·å…ˆåœ¨ä¸‹æ–¹å†ç¨‹ä¸­å‹¾é€‰éœ€è¦ä¿®å‰ªçš„æ¡ç›®ã€‚');
                return;
            }
            const sequenceIdsToTrim = Array.from(checkedBoxes).map(box => box.dataset.sequenceId);

            // 2. è·å–è¦åˆ é™¤çš„å­—æ®µ
            const fieldsToRemove = Array.from(document.querySelectorAll('.trim-field-checkbox:checked')).map(cb => cb.value);
            if (fieldsToRemove.length === 0) {
                this.showTemporaryMessage('è¯·å…ˆåœ¨ä¸Šæ–¹æ§åˆ¶å°å‹¾é€‰éœ€è¦ä¿®å‰ªçš„å­—æ®µã€‚');
                return;
            }

            // 3. å¼¹å‡ºç¡®è®¤æ¡†
            this.showCustomConfirm(
                `ä½ ç¡®å®šè¦ä»é€‰ä¸­çš„ ${checkedBoxes.length} ä¸ªæ¡ç›®ä¸­ï¼Œåˆ é™¤ã€${fieldsToRemove.join('ã€')}ã€‘å­—æ®µå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
                async () => {
                    this.showTemporaryMessage('æ­£åœ¨è¿›è¡Œç²¾ç¡®ä¿®å‰ª...');
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ã€‚');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        let trimCount = 0;

                        events.forEach(event => {
                            if (sequenceIdsToTrim.includes(event['åºå·'])) {
                                let trimmedThisEvent = false;
                                fieldsToRemove.forEach(field => {
                                    if (event.hasOwnProperty(field)) {
                                        delete event[field];
                                        trimmedThisEvent = true;
                                    }
                                });
                                if (trimmedThisEvent) trimCount++;
                            }
                        });

                        if (trimCount === 0) {
                            this.showTemporaryMessage('é€‰ä¸­çš„æ¡ç›®ä¸­æ²¡æœ‰å¯ä¿®å‰ªçš„å†…å®¹ã€‚');
                            return;
                        }

                        const newContent = this.reconstructJourneyEntry(events);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`ä¿®å‰ªæˆåŠŸï¼å·²å¤„ç† ${trimCount} ä¸ªæ¡ç›®ã€‚`, 3000);
                        this.showJourney(); // åˆ·æ–°è§†å›¾

                    } catch (error) {
                        console.error('ç²¾ç¡®ä¿®å‰ªå¤±è´¥:', error);
                        this.showTemporaryMessage(`ä¿®å‰ªå¤±è´¥: ${error.message}`, 3000);
                    }
                },
                true // keepCurrentModal
            );
          },

          async handleAutoTrim() {
            // 1. è·å–è¦åˆ é™¤çš„å­—æ®µ
            const fieldsToRemove = Array.from(document.querySelectorAll('.trim-field-checkbox:checked')).map(cb => cb.value);
            if (fieldsToRemove.length === 0) {
                this.showTemporaryMessage('è¯·å…ˆåœ¨ä¸Šæ–¹æ§åˆ¶å°å‹¾é€‰éœ€è¦ä¿®å‰ªçš„å­—æ®µã€‚');
                return;
            }

            // 2. è·å–ä¿ç•™æ•°é‡
            const keepCountInput = document.getElementById('trim-keep-count');
            const keepCount = parseInt(keepCountInput.value, 10);
            if (isNaN(keepCount) || keepCount < 0) {
                this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¿ç•™æ•°é‡ã€‚');
                return;
            }

            // 3. å¼¹å‡ºç¡®è®¤æ¡†
            this.showCustomConfirm(
                `ä½ ç¡®å®šè¦ä¿ç•™æœ€æ–°çš„ ${keepCount} ä¸ªæ¡ç›®ï¼Œå¹¶ä»æ‰€æœ‰æ›´æ—©çš„æ¡ç›®ä¸­åˆ é™¤ã€${fieldsToRemove.join('ã€')}ã€‘å­—æ®µå—ï¼Ÿæ­¤æ“ä½œä¸å¯æ¢å¤ã€‚`,
                async () => {
                    this.showTemporaryMessage('æ­£åœ¨è¿›è¡Œè‡ªåŠ¨ä¿®å‰ª...');
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ã€‚');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        if (events.length <= keepCount) {
                            this.showTemporaryMessage('æ— éœ€ä¿®å‰ªï¼Œå½“å‰æ¡ç›®æ•°æœªè¶…è¿‡ä¿ç•™æ•°é‡ã€‚');
                            return;
                        }

                        let trimCount = 0;
                        const eventsToTrimCount = events.length - keepCount;

                        events.forEach((event, idx) => {
                            if (idx < eventsToTrimCount) {
                                let trimmedThisEvent = false;
                                fieldsToRemove.forEach(field => {
                                    if (event.hasOwnProperty(field)) {
                                        delete event[field];
                                        trimmedThisEvent = true;
                                    }
                                });
                                if (trimmedThisEvent) trimCount++;
                            }
                        });

                        if (trimCount === 0) {
                            this.showTemporaryMessage('æ²¡æœ‰å¯ä¿®å‰ªçš„å†…å®¹ã€‚');
                            return;
                        }

                        const newContent = this.reconstructJourneyEntry(events);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`è‡ªåŠ¨ä¿®å‰ªæˆåŠŸï¼å·²å¤„ç† ${trimCount} ä¸ªæ—§æ¡ç›®ã€‚`, 3000);
                        this.showJourney();

                    } catch (error) {
                        console.error('è‡ªåŠ¨ä¿®å‰ªå¤±è´¥:', error);
                        this.showTemporaryMessage(`ä¿®å‰ªå¤±è´¥: ${error.message}`, 3000);
                    }
                },
                true
            );
          },

          async handleFullTrim() {
            const keepCountInput = document.getElementById('trim-keep-count');
            const keepCount = parseInt(keepCountInput.value, 10);
            if (isNaN(keepCount) || keepCount < 0) {
                this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„ä¿ç•™æ•°é‡ã€‚');
                return;
            }

            this.showCustomConfirm(
                `ã€é«˜å±æ“ä½œã€‘ä½ ç¡®å®šè¦æ°¸ä¹…åˆ é™¤é™¤æœ€è¿‘ ${keepCount} æ¡å¤–çš„æ‰€æœ‰å†ç¨‹è®°å½•å—ï¼Ÿæ­¤æ“ä½œå°†å½»åº•åˆ é™¤æ•°æ®ï¼Œä¸å¯æ¢å¤ï¼`,
                async () => {
                    this.showTemporaryMessage('æ­£åœ¨è¿›è¡Œå®Œæ•´åˆ é™¤...');
                    const bookName = '1å½’å¢Ÿ';
                    const index = this.unifiedIndex;
                    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';

                    try {
                        const allEntries = await TavernHelper.getLorebookEntries(bookName);
                        const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);

                        if (!journeyEntry || !journeyEntry.content) {
                            this.showTemporaryMessage('é”™è¯¯ï¼šæ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ã€‚');
                            return;
                        }

                        let events = this.parseJourneyEntry(journeyEntry.content);
                        if (events.length <= keepCount) {
                            this.showTemporaryMessage('æ— éœ€åˆ é™¤ï¼Œå½“å‰æ¡ç›®æ•°æœªè¶…è¿‡ä¿ç•™æ•°é‡ã€‚');
                            return;
                        }

                        const deletedCount = events.length - keepCount;
                        const keptEvents = events.slice(deletedCount);
                        
                        const newContent = this.reconstructJourneyEntry(keptEvents);
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newContent }]);
                        this.showTemporaryMessage(`å®Œæ•´åˆ é™¤æˆåŠŸï¼å·²åˆ é™¤ ${deletedCount} ä¸ªæ—§æ¡ç›®ã€‚`, 3000);
                        this.showJourney();

                    } catch (error) {
                        console.error('å®Œæ•´åˆ é™¤å¤±è´¥:', error);
                        this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${error.message}`, 3000);
                    }
                },
                true
            );
          },

          // --- æ–°å¢ï¼šä¿®å‰ªå­—æ®µçŠ¶æ€çš„ä¿å­˜ä¸åŠ è½½ ---
          saveTrimFieldsState() {
              const checkboxes = document.querySelectorAll('.trim-field-checkbox');
              const state = {};
              checkboxes.forEach(cb => {
                  state[cb.value] = cb.checked;
              });
              this.trimFieldsState = state;
              try {
                  localStorage.setItem('guixu_trim_fields_state', JSON.stringify(state));
              } catch (e) {
                  console.error('ä¿å­˜ä¿®å‰ªå­—æ®µçŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadTrimFieldsState() {
              try {
                  const savedState = localStorage.getItem('guixu_trim_fields_state');
                  if (savedState) {
                      this.trimFieldsState = JSON.parse(savedState);
                  } else {
                      // å¦‚æœæ²¡æœ‰ä¿å­˜çš„çŠ¶æ€ï¼Œåˆ™ä»HTMLçš„é»˜è®¤checkedçŠ¶æ€åˆå§‹åŒ–
                      this.saveTrimFieldsState();
                      return;
                  }
              } catch (e) {
                  console.error('åŠ è½½ä¿®å‰ªå­—æ®µçŠ¶æ€å¤±è´¥:', e);
                  this.trimFieldsState = {}; // å‡ºé”™æ—¶é‡ç½®
              }
              
              // å°†åŠ è½½çš„çŠ¶æ€åº”ç”¨åˆ°å¤é€‰æ¡†
              const checkboxes = document.querySelectorAll('.trim-field-checkbox');
              checkboxes.forEach(cb => {
                  // å¦‚æœçŠ¶æ€å¯¹è±¡ä¸­æœ‰è¿™ä¸ªå€¼ï¼Œåˆ™ä½¿ç”¨å®ƒï¼›å¦åˆ™ä¿æŒé»˜è®¤
                  if (this.trimFieldsState.hasOwnProperty(cb.value)) {
                      cb.checked = this.trimFieldsState[cb.value];
                  }
              });
           },

            // --- æ–°å¢ï¼šè¾“å…¥ç¼“å­˜å†å²åŠŸèƒ½ ---
            getInputHistory() {
                try {
                    const history = localStorage.getItem('guixu_input_history');
                    return history ? JSON.parse(history) : [];
                } catch (e) {
                    return [];
                }
            },

            saveInputToHistory(content) {
                if (!content) return;
                try {
                    let history = this.getInputHistory();
                    // é¿å…é‡å¤ä¿å­˜å®Œå…¨ç›¸åŒçš„å†…å®¹åˆ°æœ€å‰é¢
                    if (history[0] === content) return;
                    // å°†æ–°å†…å®¹æ·»åŠ åˆ°æ•°ç»„å¼€å¤´
                    history.unshift(content);
                    // é™åˆ¶å†å²è®°å½•æ•°é‡ï¼Œä¾‹å¦‚100æ¡
                    if (history.length > 100) {
                        history.pop();
                    }
                    localStorage.setItem('guixu_input_history', JSON.stringify(history));
                } catch (e) {
                    // Fail silently
                }
            },

            showInputCacheModal() {
                const history = this.getInputHistory();
                const recentListEl = document.getElementById('recent-inputs-list');
                const allListEl = document.getElementById('all-inputs-list');

                if (!recentListEl || !allListEl) return;

                recentListEl.innerHTML = '';
                allListEl.innerHTML = '';

                if (history.length === 0) {
                    recentListEl.innerHTML = '<li class="empty-category-text">æš‚æ— è®°å½•</li>';
                    allListEl.innerHTML = '<li class="empty-category-text">æš‚æ— è®°å½•</li>';
                } else {
                    // å¡«å……æœ€è¿‘ä¸¤æ¬¡è¾“å…¥
                    history.slice(0, 2).forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'input-cache-item';
                        li.dataset.content = item;
                        li.innerHTML = `<span class="item-index">${index + 1}.</span>${item}`;
                        recentListEl.appendChild(li);
                    });

                    // å¡«å……æ‰€æœ‰å†å²è®°å½•
                    history.forEach((item, index) => {
                        const li = document.createElement('li');
                        li.className = 'input-cache-item';
                        li.dataset.content = item;
                        li.innerHTML = `<span class="item-index">${index + 1}.</span>${item}`;
                        allListEl.appendChild(li);
                    });
                }
                
                this.openModal('input-cache-modal');
            },

            applyInputFromHistory(content) {
                const inputEl = document.getElementById('quick-send-input');
                if (inputEl) {
                    inputEl.value = content;
                    this.closeModal('input-cache-modal');
                    this.showTemporaryMessage('å·²åº”ç”¨å†å²è¾“å…¥ã€‚');
                }
            },

          // --- æ–°å¢ï¼šä¸–ç•Œä¹¦ç®¡ç†åŠŸèƒ½ ---
          // æ–°å¢ï¼šæ˜¾ç¤ºåˆ†æ®µè®°å¿†æ¨¡æ€æ¡†
          async showSegmentedMemoryModal() {
            this.loadSegmentedMemoryCounts(); // æ–°å¢ï¼šåŠ è½½ä¿ç•™æ•°è®¾ç½®
            this.updateUnifiedSummaryDisplay(); // åœ¨æ‰“å¼€æ¨¡æ€æ¡†æ—¶æ›´æ–°ç»Ÿä¸€é¢„è§ˆ
            const modal = document.getElementById('segmented-memory-modal');
            if (!modal) {
                this.showTemporaryMessage('åˆ†æ®µè®°å¿†æ¨¡æ€æ¡†åŠ è½½å¤±è´¥', 'error');
                return;
            }
            this.openModal('segmented-memory-modal', true); // ç¡®ä¿åœ¨è®¾ç½®ä¹‹ä¸Š

            // æ›´æ–°ç»Ÿä¸€é¢„è§ˆ
            this.updateUnifiedSummaryDisplay();

            // åˆå§‹åŒ–UIçŠ¶æ€
            const autoGenerateCheckbox = document.getElementById('auto-segmented-memory-checkbox');
            if(autoGenerateCheckbox) autoGenerateCheckbox.checked = this.isSegmentedMemoryAutoGenerateEnabled; // ä¸»å¼€å…³çš„çŠ¶æ€

            // ç”±äºå…¶ä»–å¼€å…³å·²ç§»é™¤ï¼Œä¸å†éœ€è¦å•ç‹¬åˆå§‹åŒ–å®ƒä»¬

            // ç»‘å®šæ¨¡æ€æ¡†å†…éƒ¨äº‹ä»¶
            const closeBtn = modal.querySelector('.modal-close-btn');
            closeBtn?.addEventListener('click', () => {
                this.closeModal('segmented-memory-modal');
                if (this.isFromSettingsModal) {
                    this.showSettings();
                    this.isFromSettingsModal = false; // é‡ç½®æ ‡å¿—ä½
                }
            });
            
            modal.addEventListener('click', (event) => {
                if (event.target === modal) {
                    this.closeModal('segmented-memory-modal');
                    if (this.isFromSettingsModal) {
                        this.showSettings();
                        this.isFromSettingsModal = false; // é‡ç½®æ ‡å¿—ä½
                    }
                }
            });

            const generateBtn = document.getElementById('btn-generate-segmented-memory');
            generateBtn?.addEventListener('click', async () => {
                // ä¾æ¬¡è°ƒç”¨ä¸‰ä¸ªç”Ÿæˆå‡½æ•°
                await this.generateSegmentedMemory();
                await this.generateSmallSummary();
                await this.generateLargeSummary();

                // åœ¨æ‰‹åŠ¨ç”Ÿæˆåï¼Œå¦‚æœæ¨¡æ€æ¡†æ˜¯æ‰“å¼€çš„ï¼Œåˆ™åˆ·æ–°ç»Ÿä¸€é¢„è§ˆ
                const modal = document.getElementById('segmented-memory-modal');
                if (modal && modal.style.display !== 'none') {
                    this.updateUnifiedSummaryDisplay();
                }
            });

            // æ–°å¢ï¼šä¸ºé¢„è§ˆåˆ—è¡¨æ·»åŠ ç‚¹å‡»å±•å¼€/æŠ˜å äº‹ä»¶ (ä¼˜åŒ–ç‰ˆ)
            const displayEl = document.getElementById('unified-summary-display');
            if (displayEl && !displayEl.dataset.listenerAttached) {
                displayEl.dataset.listenerAttached = 'true';
                displayEl.addEventListener('click', (e) => {
                    const header = e.target.closest('.summary-header');
                    if (header) {
                        const item = header.closest('.summary-item');
                        item.classList.toggle('expanded');
                    }
                });
            }

            const segmentedCountInput = document.getElementById('segmented-memory-count');
            const smallSummaryCountInput = document.getElementById('small-summary-count');

            segmentedCountInput?.addEventListener('input', () => {
                this.updateUnifiedSummaryDisplay();
                this.saveSegmentedMemoryCounts();
            });
            smallSummaryCountInput?.addEventListener('input', () => {
                this.updateUnifiedSummaryDisplay();
                this.saveSegmentedMemoryCounts();
            });

            autoGenerateCheckbox?.addEventListener('change', (e) => {
               const isEnabled = e.target.checked;
               this.isSegmentedMemoryAutoGenerateEnabled = isEnabled;
               this.isSmallSummaryAutoOn = isEnabled;
               this.isLargeSummaryAutoOn = isEnabled;

               this.saveSegmentedMemoryState();
               this.saveSmallSummaryState();
               this.saveLargeSummaryState();

               this.showTemporaryMessage(`åˆ†æ®µè®°å¿†è‡ªåŠ¨ç”Ÿæˆå·²${isEnabled ? 'å¼€å¯' : 'å…³é—­'}`);

               if (isEnabled) {
                   this.startSegmentedMemoryPolling();
                   // æ³¨æ„ï¼šå°æ€»ç»“å’Œå¤§æ€»ç»“çš„è½®è¯¢é€»è¾‘å¯èƒ½éœ€è¦å•ç‹¬çš„è®¡æ—¶å™¨æˆ–åœ¨åˆ†æ®µè®°å¿†è½®è¯¢ä¸­è§¦å‘
               } else {
                   this.stopSegmentedMemoryPolling();
                   // åŒæ ·éœ€è¦åœæ­¢å°æ€»ç»“å’Œå¤§æ€»ç»“çš„è½®è¯¢
               }
            });

            // --- æ•´åˆåçš„äº‹ä»¶ç»‘å®š ---
            document.getElementById('edit-small-summary-btn')?.addEventListener('click', () => this.showSummaryEditorModal('small'));
            document.getElementById('edit-large-summary-btn')?.addEventListener('click', () => this.showSummaryEditorModal('large'));
const generateSummariesBtn = document.getElementById('btn-generate-summaries');
generateSummariesBtn?.addEventListener('click', async () => {
    const statusEl = document.getElementById('summaries-status');
    if (generateSummariesBtn) {
        generateSummariesBtn.disabled = true;
        generateSummariesBtn.textContent = 'æ­£åœ¨ç”Ÿæˆ...';
    }
    
    try {
        await this.generateSmallSummary();
        await this.generateLargeSummary();
        if (statusEl) statusEl.textContent = 'ç”Ÿæˆå®Œæˆï¼';
        this.showTemporaryMessage('å°ç»“ä¸æ€»ç»“å·²æ›´æ–°', 'success');
        // ç”Ÿæˆååˆ·æ–°ç»Ÿä¸€é¢„è§ˆ
        this.updateUnifiedSummaryDisplay();
    } catch (e) {
        // é”™è¯¯å·²åœ¨å„è‡ªå‡½æ•°ä¸­å¤„ç†å’Œæ˜¾ç¤º
    } finally {
        if (generateSummariesBtn) {
            generateSummariesBtn.disabled = false;
            generateSummariesBtn.textContent = 'ç«‹å³ç”Ÿæˆå°ç»“ä¸æ€»ç»“';
        }
        setTimeout(() => { if (statusEl) statusEl.textContent = ''; }, 3000);
    }
});
},

// æ—§çš„ updateSmallSummaryDisplay å’Œ updateLargeSummaryDisplay å‡½æ•°å·²è¢«ç§»é™¤


// --- æ–°å¢ï¼šæ€»ç»“ç¼–è¾‘å™¨ ---
async showSummaryEditorModal(summaryType) {
    const modal = document.getElementById('summary-editor-modal');
    const titleEl = document.getElementById('summary-editor-title');
    const textarea = document.getElementById('summary-editor-textarea');
    if (!modal || !titleEl || !textarea) return;

    const bookName = '1å½’å¢Ÿ';
    const index = this.unifiedIndex;
    const entryName = summaryType === 'small'
        ? (index > 1 ? `å°æ€»ç»“(${index})` : 'å°æ€»ç»“')
        : (index > 1 ? `å¤§æ€»ç»“(${index})` : 'å¤§æ€»ç»“');
    
    titleEl.textContent = `ç¼–è¾‘${summaryType === 'small' ? 'å°æ€»ç»“' : 'å¤§æ€»ç»“'}`;
    textarea.value = 'æ­£åœ¨åŠ è½½...';
    this.openModal('summary-editor-modal', true);

    try {
        const allEntries = await TavernHelper.getLorebookEntries(bookName);
        const entry = allEntries.find(e => e.comment === entryName);
        textarea.value = entry ? entry.content : '';
    } catch (error) {
        textarea.value = `åŠ è½½å¤±è´¥: ${error.message}`;
    }

    // ç»‘å®šäº‹ä»¶
    modal.querySelector('.modal-close-btn').onclick = () => this.closeModal('summary-editor-modal');
    modal.querySelector('#summary-editor-cancel').onclick = () => this.closeModal('summary-editor-modal');
    
    const saveBtn = modal.querySelector('#summary-editor-save');
    saveBtn.onclick = async () => {
        const newContent = textarea.value;
        saveBtn.textContent = 'ä¿å­˜ä¸­...';
        saveBtn.disabled = true;

        try {
            // åå‘æ›´æ–°æœ¬ä¸–å†ç¨‹
            await this.updateJourneyFromSummary(newContent, summaryType);
            
            // é‡æ–°ç”Ÿæˆæ€»ç»“
            await this.generateSmallSummary();
            await this.generateLargeSummary();

            this.showTemporaryMessage('ä¿å­˜å¹¶æ›´æ–°æˆåŠŸï¼', 'success');
            this.closeModal('summary-editor-modal');

            // åˆ·æ–°ä¸»æ¨¡æ€æ¡†çš„æ˜¾ç¤º
            this.updateSmallSummaryDisplay();
            this.updateLargeSummaryDisplay();

        } catch (error) {
            console.error('ä¿å­˜æ€»ç»“å¤±è´¥:', error);
            this.showTemporaryMessage(`ä¿å­˜å¤±è´¥: ${error.message}`, 'error');
        } finally {
            saveBtn.textContent = 'ä¿å­˜æ›´æ”¹';
            saveBtn.disabled = false;
        }
    };
},

async updateJourneyFromSummary(summaryContent, summaryType) {
    const bookName = '1å½’å¢Ÿ';
    const index = this.unifiedIndex;
    const journeyKey = index > 1 ? `æœ¬ä¸–å†ç¨‹(${index})` : 'æœ¬ä¸–å†ç¨‹';
    
    const allEntries = await TavernHelper.getLorebookEntries(bookName);
    const journeyEntry = allEntries.find(entry => entry.comment === journeyKey);
    if (!journeyEntry) throw new Error('æ‰¾ä¸åˆ°â€œæœ¬ä¸–å†ç¨‹â€ä¸–ç•Œä¹¦ã€‚');
    
    let journeyEvents = this.parseJourneyEntry(journeyEntry.content);
    const summaryEvents = summaryType === 'small'
        ? summaryContent.split('\n\n').filter(Boolean)
        : summaryContent.split('\n').filter(Boolean);

    if (journeyEvents.length < summaryEvents.length) {
        console.warn('æ€»ç»“ä¸­çš„äº‹ä»¶æ•°é‡å¤šäºæœ¬ä¸–å†ç¨‹ï¼Œå¯èƒ½å¯¼è‡´éƒ¨åˆ†æ›´æ–°ä¸¢å¤±ã€‚');
    }

    // ä»åå¾€å‰åŒ¹é…å’Œæ›´æ–°
    const journeyLen = journeyEvents.length;
    const summaryLen = summaryEvents.length;
    for (let i = 0; i < summaryLen; i++) {
        const journeyIndex = journeyLen - 1 - i;
        const summaryIndex = summaryLen - 1 - i;
        if (journeyIndex < 0) break;

        const journeyEvent = journeyEvents[journeyIndex];
        const summaryText = summaryEvents[summaryIndex];

        if (summaryType === 'small') {
            const lines = summaryText.split('\n');
            const firstLineContent = lines[0].replace(/^.+?ï¼Œ/, '').trim();
            journeyEvent['é‡è¦ä¿¡æ¯'] = firstLineContent;
            delete journeyEvent['æš—çº¿ä¸ä¼ç¬”'];
            delete journeyEvent['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'];
            lines.slice(1).forEach(line => {
                const parts = line.split('|');
                if (parts.length === 2) {
                    if (parts[0] === 'æš—çº¿ä¸ä¼ç¬”') journeyEvent['æš—çº¿ä¸ä¼ç¬”'] = parts[1];
                    if (parts[0] === 'è‡ªåŠ¨åŒ–ç³»ç»Ÿ') journeyEvent['è‡ªåŠ¨åŒ–ç³»ç»Ÿ'] = parts[1];
                }
            });
        } else { // large
            const contentWithoutDate = summaryText.replace(/^.+?ï¼Œ/, '').trim();
            journeyEvent['æè¿°'] = contentWithoutDate;
        }
    }
    
    const newJourneyContent = this.reconstructJourneyEntry(journeyEvents);
    await TavernHelper.setLorebookEntries(bookName, [{ uid: journeyEntry.uid, content: newJourneyContent }]);
},
// æ–°å¢ï¼šæ›´æ–°åˆ†æ®µè®°å¿†æ¨¡æ€æ¡†ä¸­çš„ç« èŠ‚æ˜¾ç¤º
async updateUnifiedSummaryDisplay() {
    const displayEl = document.getElementById('unified-summary-display');
    if (!displayEl) return;

    displayEl.innerHTML = '<div style="color: #8b7355; text-align: center;">æ­£åœ¨åŠ è½½...</div>';

    try {
        const bookName = '1å½’å¢Ÿ';
        const currentIndex = this.unifiedIndex;

        // 1. å¹¶è¡Œè·å–æ‰€æœ‰éœ€è¦çš„æ•°æ®æº
        const entryNames = [
            currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹',
            currentIndex > 1 ? `åˆ†æ®µæ­£æ–‡(${currentIndex})` : 'åˆ†æ®µæ­£æ–‡',
            currentIndex > 1 ? `å°æ€»ç»“(${currentIndex})` : 'å°æ€»ç»“',
            currentIndex > 1 ? `å¤§æ€»ç»“(${currentIndex})` : 'å¤§æ€»ç»“'
        ];

        const allEntries = await TavernHelper.getLorebookEntries(bookName);
        const [journeyEntry, segmentedEntry, smallSummaryEntry, largeSummaryEntry] = entryNames.map(name =>
            allEntries.find(entry => entry.comment === name)
        );

        if (!journeyEntry || !journeyEntry.content) {
            displayEl.innerHTML = '<div class="modal-display-placeholder">â€œæœ¬ä¸–å†ç¨‹â€å†…å®¹ä¸ºç©º</div>';
            return;
        }

        const journeyEvents = this.parseJourneyEntry(journeyEntry.content);
        if (journeyEvents.length === 0) {
            displayEl.innerHTML = '<div class="modal-display-placeholder">æ— äº‹ä»¶å¯ä¾›é¢„è§ˆ</div>';
            return;
        }

        // 2. è§£æä¸‰å¤§äº§ç‰©çš„å†…å®¹
        const segmentedContent = segmentedEntry ? segmentedEntry.content.split('\nâ€”â€”\n') : [];
        const smallSummaryContent = smallSummaryEntry ? smallSummaryEntry.content.split('\nâ€”â€”\n') : [];
        const largeSummaryContent = largeSummaryEntry ? largeSummaryEntry.content.split('\nâ€”â€”\n') : [];

        const segmentedCount = parseInt(document.getElementById('segmented-memory-count').value, 10) || 0;
        const smallSummaryCount = parseInt(document.getElementById('small-summary-count').value, 10) || 0;

        const html = journeyEvents.map((event, index) => {
            const eventNumber = index + 1;
            let tag = '';
            let tagColor = '';
            let contentToShow = '<div class="summary-detail-placeholder">æ— å¯¹åº”å†…å®¹</div>';

            // 3. æ ¹æ®åˆ‡ç‰‡æ¨¡å‹å†³å®šæ ‡ç­¾å’Œè¦æ˜¾ç¤ºçš„å†…å®¹
            if (eventNumber > journeyEvents.length - segmentedCount) {
                tag = 'åˆ†æ®µæ­£æ–‡';
                tagColor = '#C9AA71';
                const contentIndex = index - (journeyEvents.length - segmentedCount);
                if (segmentedContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-language">${_.escape(segmentedContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            } else if (eventNumber > journeyEvents.length - segmentedCount - smallSummaryCount) {
                tag = 'å°æ€»ç»“';
                tagColor = '#A9C971';
                const contentIndex = index - (journeyEvents.length - segmentedCount - smallSummaryCount);
                if (smallSummaryContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-psychology">${_.escape(smallSummaryContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            } else {
                tag = 'å¤§æ€»ç»“';
                tagColor = '#71A9C9';
                const contentIndex = index;
                if (largeSummaryContent[contentIndex]) {
                    contentToShow = `<div class="summary-detail-content text-scenery">${_.escape(largeSummaryContent[contentIndex]).replace(/\n/g, '<br>')}</div>`;
                }
            }
            
            const chapterNumber = event['åºå·'] || eventNumber;
            const chapterTitle = event['æ ‡é¢˜'] || 'æ— æ ‡é¢˜';
            const title = `ç¬¬${chapterNumber}ç«  ${chapterTitle}`;

            // 4. æ„å»ºUIï¼Œå†…å®¹é»˜è®¤å±•å¼€
            return `
                <div class="summary-item">
                    <div class="summary-header">
                        <span class="summary-arrow">â–¶</span>
                        <span class="summary-title">${_.escape(title)}</span>
                        <span class="summary-tag" style="background-color: ${tagColor};">${tag}</span>
                    </div>
                    <div class="summary-details" style="display: none;">
                        ${contentToShow}
                    </div>
                </div>
            `;
        }).join('');

        displayEl.innerHTML = html;
    } catch (error) {
        console.error('æ›´æ–°åˆ†æ®µè®°å¿†é¢„è§ˆå¤±è´¥:', error);
        displayEl.innerHTML = `<div style="color: #ff6b6b; text-align: center;">åŠ è½½å¤±è´¥: ${error.message}</div>`;
    }
},

          // æ–°å¢ï¼šç”Ÿæˆ/æ›´æ–°åˆ†æ®µè®°å¿†çš„æ ¸å¿ƒé€»è¾‘
          async generateSegmentedMemory(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const countInput = document.getElementById('segmented-memory-count');
            const generateBtn = document.getElementById('btn-generate-segmented-memory');

            if (!statusEl || !countInput || !generateBtn) {
                this.showTemporaryMessage('UIå…ƒç´ ç¼ºå¤±ï¼Œæ“ä½œä¸­æ–­', 'error');
                return;
            }

            try {
                if (!isPolling) {
                    generateBtn.disabled = true;
                    generateBtn.textContent = 'æ­£åœ¨ç”Ÿæˆ...';
                    statusEl.textContent = 'æ­£åœ¨è¯»å–å°è¯´æ¨¡å¼æ•°æ®...';
                }

                const count = parseInt(countInput.value, 10);
                if (isNaN(count) || count < 0) {
                    throw new Error('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„éè´Ÿæ•´æ•°');
                }

                const bookName = '1å½’å¢Ÿ';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`ä¸–ç•Œä¹¦ "${bookName}" ä¸­æ²¡æœ‰æ¡ç›®ã€‚`);
                }

                // æ ¹æ®å½“å‰è¯»å†™åºå·ï¼Œç²¾ç¡®å®šä½æºâ€œå°è¯´æ¨¡å¼â€æ¡ç›®
                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `å°è¯´æ¨¡å¼(${currentIndex})` : 'å°è¯´æ¨¡å¼';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`æœªæ‰¾åˆ°æˆ–å†…å®¹ä¸ºç©ºçš„æºæ¡ç›®: "${sourceEntryName}"`);
                }

                // ä½¿ç”¨æ­£åˆ™è¡¨è¾¾å¼åˆ†å‰²ç« èŠ‚
                const chapters = sourceEntry.content.split(/(?=ç¬¬\d+ç« \s+.*)/g).filter(c => c.trim() !== '');

                // ä»ç« èŠ‚æœ«å°¾æå–æœ€æ–°çš„Xä¸ª
                // ä¿®å¤ï¼šå½“countä¸º0æ—¶ï¼Œslice(0)ä¼šè¿”å›æ•´ä¸ªæ•°ç»„ï¼Œè€Œä¸æ˜¯ç©ºæ•°ç»„
                const latestChapters = count === 0 ? [] : chapters.slice(-count);

                // åˆå¹¶å†…å®¹
                const combinedContent = latestChapters.join('\nâ€”â€”\n');

                if (!isPolling) {
                    statusEl.textContent = 'æ­£åœ¨å†™å…¥â€œåˆ†æ®µæ­£æ–‡â€...';
                }

                // æ ¹æ®ç»Ÿä¸€åºå·ç”Ÿæˆç›®æ ‡æ¡ç›®åç§°
                const targetEntryName = currentIndex > 1 ? `åˆ†æ®µæ­£æ–‡(${currentIndex})` : 'åˆ†æ®µæ­£æ–‡';

                // æŸ¥æ‰¾ç°æœ‰çš„â€œåˆ†æ®µæ­£æ–‡â€æ¡ç›®
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    // ä»…åœ¨å†…å®¹æœ‰å˜åŒ–æ—¶æ‰æ›´æ–°ï¼Œé¿å…ä¸å¿…è¦çš„å†™å…¥
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{
                            uid: existingEntry.uid,
                            content: combinedContent,
                        }]);
                    }
                } else {
                    // åˆ›å»ºæ–°æ¡ç›®
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [], // ä½œä¸ºä¸€ä¸ªå¸¸é‡æ¡ç›®ï¼Œä¸éœ€è¦å…³é”®è¯
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `åˆ†æ®µè®°å¿†å·²æ›´æ–°ï¼Œå…±èšåˆ ${latestChapters.length} ä¸ªæœ€æ–°ç« èŠ‚ã€‚`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[å½’å¢Ÿ-åˆ†æ®µè®°å¿†] è‡ªåŠ¨æ›´æ–°æˆåŠŸï¼Œèšåˆ ${latestChapters.length} ä¸ªç« èŠ‚ã€‚`);
                }

                // æ–°å¢ï¼šå¦‚æœåˆ†æ®µè®°å¿†çª—å£æ˜¯æ‰“å¼€çš„ï¼Œåˆ™é™é»˜åˆ·æ–°ç« èŠ‚åˆ—è¡¨æ˜¾ç¤º
                const modal = document.getElementById('segmented-memory-modal');
                if (modal && modal.style.display !== 'none') {
                    this.updateUnifiedSummaryDisplay();
                }

            } catch (error) {
                console.error('ç”Ÿæˆåˆ†æ®µè®°å¿†æ—¶å‡ºé”™:', error);
                if (!isPolling) {
                    const errorMsg = `é”™è¯¯: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                if (!isPolling) {
                    generateBtn.disabled = false;
                    generateBtn.textContent = 'ç«‹å³ç”Ÿæˆ/æ›´æ–°';
                }
            }
          },

          // æ–°å¢ï¼šç”Ÿæˆ/æ›´æ–°å°æ€»ç»“çš„æ ¸å¿ƒé€»è¾‘
          async generateSmallSummary(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const smallSummaryCountInput = document.getElementById('small-summary-count');
            const segmentedCountInput = document.getElementById('segmented-memory-count'); // è·å–åˆ†æ®µæ­£æ–‡çš„æ•°é‡è¾“å…¥æ¡†

            if (!smallSummaryCountInput || !segmentedCountInput) {
                this.showTemporaryMessage('UIå…ƒç´ ç¼ºå¤±ï¼Œæ“ä½œä¸­æ–­', 'error');
                return;
            }

            try {
                if (!isPolling && statusEl) {
                    statusEl.textContent = 'æ­£åœ¨è¯»å–(å°æ€»ç»“)...';
                }

                const smallSummaryCount = parseInt(smallSummaryCountInput.value, 10);
                const segmentedCount = parseInt(segmentedCountInput.value, 10); // è·å–åˆ†æ®µæ­£æ–‡çš„æ•°é‡

                if (isNaN(smallSummaryCount) || smallSummaryCount < 0 || isNaN(segmentedCount) || segmentedCount < 0) {
                    throw new Error('è¯·è¾“å…¥ä¸€ä¸ªæœ‰æ•ˆçš„éè´Ÿæ•´æ•°');
                }

                const bookName = '1å½’å¢Ÿ';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`ä¸–ç•Œä¹¦ "${bookName}" ä¸­æ²¡æœ‰æ¡ç›®ã€‚`);
                }

                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`æœªæ‰¾åˆ°æˆ–å†…å®¹ä¸ºç©ºçš„æºæ¡ç›®: "${sourceEntryName}"`);
                }

                const journeyEvents = this.parseJourneyEntry(sourceEntry.content);
                
                // æ–°çš„åˆ‡ç‰‡é€»è¾‘
                const start = -(segmentedCount + smallSummaryCount);
                const end = -segmentedCount;
                const latestEvents = smallSummaryCount === 0 ? [] : journeyEvents.slice(start, end < 0 ? end : undefined);


                const formattedEvents = latestEvents.map(event => {
                    const parts = [];
                    // æ ¼å¼ï¼šxxxï¼ˆæ—¥æœŸï¼‰ï¼Œxxxï¼ˆé‡è¦ä¿¡æ¯ï¼‰
                    if (event['æ—¥æœŸ'] && event['é‡è¦ä¿¡æ¯']) {
                        parts.push(`${event['æ—¥æœŸ']}ï¼Œ${event['é‡è¦ä¿¡æ¯']}`);
                    } else if (event['æ—¥æœŸ']) {
                        parts.push(event['æ—¥æœŸ']);
                    } else if (event['é‡è¦ä¿¡æ¯']) {
                        parts.push(event['é‡è¦ä¿¡æ¯']);
                    }

                    // æ ¼å¼ï¼šæš—çº¿ä¸ä¼ç¬”|xxx
                    if (event['æš—çº¿ä¸ä¼ç¬”']) {
                        parts.push(`æš—çº¿ä¸ä¼ç¬”|${event['æš—çº¿ä¸ä¼ç¬”']}`);
                    }
                    // æ ¼å¼ï¼šè‡ªåŠ¨åŒ–ç³»ç»Ÿ|xxx
                    if (event['è‡ªåŠ¨åŒ–ç³»ç»Ÿ']) {
                        parts.push(`è‡ªåŠ¨åŒ–ç³»ç»Ÿ|${event['è‡ªåŠ¨åŒ–ç³»ç»Ÿ']}`);
                    }
                    return parts.join('\n');
                }).filter(Boolean); // è¿‡æ»¤æ‰å¯èƒ½ä¸ºç©ºçš„äº‹ä»¶å­—ç¬¦ä¸²
                const combinedContent = formattedEvents.join('\nâ€”â€”\n'); // ä½¿ç”¨æ–°çš„åˆ†éš”ç¬¦
                
                if (!isPolling) {
                    statusEl.textContent = 'æ­£åœ¨å†™å…¥â€œå°æ€»ç»“â€...';
                }

                const targetEntryName = currentIndex > 1 ? `å°æ€»ç»“(${currentIndex})` : 'å°æ€»ç»“';
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: existingEntry.uid, content: combinedContent }]);
                    }
                } else {
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [],
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `å°æ€»ç»“å·²æ›´æ–°ï¼Œå…±èšåˆ ${latestEvents.length} ä¸ªæœ€æ–°äº‹ä»¶ã€‚`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[å½’å¢Ÿ-å°æ€»ç»“] è‡ªåŠ¨æ›´æ–°æˆåŠŸï¼Œèšåˆ ${latestEvents.length} ä¸ªäº‹ä»¶ã€‚`);
                }

            } catch (error) {
                console.error('ç”Ÿæˆå°æ€»ç»“æ—¶å‡ºé”™:', error);
                if (!isPolling) {
                    const errorMsg = `é”™è¯¯: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                // æŒ‰é’®çŠ¶æ€ç®¡ç†å·²ç§»è‡³è°ƒç”¨å¤„
            }
          },

          // æ–°å¢ï¼šç”Ÿæˆ/æ›´æ–°å¤§æ€»ç»“çš„æ ¸å¿ƒé€»è¾‘
          async generateLargeSummary(isPolling = false) {
            const statusEl = document.getElementById('segmented-memory-status');
            const smallSummaryCountInput = document.getElementById('small-summary-count');
            const segmentedCountInput = document.getElementById('segmented-memory-count');

            try {
                if (!isPolling && statusEl) {
                    statusEl.textContent = 'æ­£åœ¨è¯»å–(å¤§æ€»ç»“)...';
                }

                const smallSummaryCount = parseInt(smallSummaryCountInput.value, 10);
                const segmentedCount = parseInt(segmentedCountInput.value, 10);

                if (isNaN(smallSummaryCount) || smallSummaryCount < 0 || isNaN(segmentedCount) || segmentedCount < 0) {
                    throw new Error('è·å–çš„æ•°å€¼æ— æ•ˆ');
                }

                const bookName = '1å½’å¢Ÿ';
                const allEntries = await TavernHelper.getLorebookEntries(bookName);

                if (!allEntries || allEntries.length === 0) {
                    throw new Error(`ä¸–ç•Œä¹¦ "${bookName}" ä¸­æ²¡æœ‰æ¡ç›®ã€‚`);
                }

                const currentIndex = this.unifiedIndex;
                const sourceEntryName = currentIndex > 1 ? `æœ¬ä¸–å†ç¨‹(${currentIndex})` : 'æœ¬ä¸–å†ç¨‹';
                const sourceEntry = allEntries.find(entry => entry.comment === sourceEntryName);

                if (!sourceEntry || !sourceEntry.content) {
                    throw new Error(`æœªæ‰¾åˆ°æˆ–å†…å®¹ä¸ºç©ºçš„æºæ¡ç›®: "${sourceEntryName}"`);
                }

                const journeyEvents = this.parseJourneyEntry(sourceEntry.content);
                
                // æ–°çš„åˆ‡ç‰‡é€»è¾‘
                const end = -(segmentedCount + smallSummaryCount);
                const largeSummaryEvents = journeyEvents.slice(0, end < 0 ? end : undefined);

                const formattedEvents = largeSummaryEvents.map(event => {
                    // æ ¼å¼ï¼šxxxï¼ˆæ—¥æœŸï¼‰ï¼Œxxxï¼ˆæè¿°ï¼‰
                    if (event['æ—¥æœŸ'] && event['æè¿°']) {
                        return `${event['æ—¥æœŸ']}ï¼Œ${event['æè¿°']}`;
                    }
                    return null; // å¦‚æœç¼ºå°‘ä»»ä¸€å­—æ®µï¼Œåˆ™å¿½ç•¥æ­¤äº‹ä»¶
                }).filter(Boolean); // è¿‡æ»¤æ‰ä¸ºnullçš„äº‹ä»¶
                const combinedContent = formattedEvents.join('\nâ€”â€”\n'); // ä½¿ç”¨æ–°çš„åˆ†éš”ç¬¦
                
                if (!isPolling) {
                    statusEl.textContent = 'æ­£åœ¨å†™å…¥â€œå¤§æ€»ç»“â€...';
                }

                const targetEntryName = currentIndex > 1 ? `å¤§æ€»ç»“(${currentIndex})` : 'å¤§æ€»ç»“';
                const existingEntry = allEntries.find(entry => entry.comment === targetEntryName);

                if (existingEntry) {
                    if (existingEntry.content !== combinedContent) {
                        await TavernHelper.setLorebookEntries(bookName, [{ uid: existingEntry.uid, content: combinedContent }]);
                    }
                } else {
                    await TavernHelper.createLorebookEntries(bookName, [{
                        comment: targetEntryName,
                        content: combinedContent,
                        keys: [],
                        type: 'constant',
                        enabled: true,
                    }]);
                }

                const successMsg = `å¤§æ€»ç»“å·²æ›´æ–°ï¼Œå…±èšåˆ ${journeyEvents.length} ä¸ªäº‹ä»¶ã€‚`;
                if (!isPolling) {
                    statusEl.textContent = successMsg;
                    this.showTemporaryMessage(successMsg, 'success');
                } else {
                    console.log(`[å½’å¢Ÿ-å¤§æ€»ç»“] è‡ªåŠ¨æ›´æ–°æˆåŠŸï¼Œèšåˆ ${journeyEvents.length} ä¸ªäº‹ä»¶ã€‚`);
                }

            } catch (error) {
                console.error('ç”Ÿæˆå¤§æ€»ç»“æ—¶å‡ºé”™:', error);
                if (!isPolling) {
                    const errorMsg = `é”™è¯¯: ${error.message}`;
                    statusEl.textContent = errorMsg;
                    this.showTemporaryMessage(errorMsg, 'error', 5000);
                }
            } finally {
                // æŒ‰é’®çŠ¶æ€ç®¡ç†å·²ç§»è‡³è°ƒç”¨å¤„
            }
          },

          // --- æ–°å¢ï¼šåˆ†æ®µè®°å¿†è‡ªåŠ¨ç”Ÿæˆç›¸å…³ ---
          startSegmentedMemoryPolling() {
              this.stopSegmentedMemoryPolling();
              console.log('[å½’å¢Ÿ] å¯åŠ¨åˆ†æ®µè®°å¿†ç»Ÿä¸€è‡ªåŠ¨ç”Ÿæˆè½®è¯¢...');
              this.segmentedMemoryIntervalId = setInterval(async () => {
                  console.log('[å½’å¢Ÿ] è½®è¯¢è§¦å‘ï¼šå¼€å§‹è‡ªåŠ¨æ›´æ–°åˆ†æ®µè®°å¿†...');
                  await this.generateSegmentedMemory(true);
                  if (this.isSmallSummaryAutoOn) {
                      console.log('[å½’å¢Ÿ] è½®è¯¢è§¦å‘ï¼šå¼€å§‹è‡ªåŠ¨æ›´æ–°å°æ€»ç»“...');
                      await this.generateSmallSummary(true);
                  }
                  if (this.isLargeSummaryAutoOn) {
                      console.log('[å½’å¢Ÿ] è½®è¯¢è§¦å‘ï¼šå¼€å§‹è‡ªåŠ¨æ›´æ–°å¤§æ€»ç»“...');
                      await this.generateLargeSummary(true);
                  }
                  console.log('[å½’å¢Ÿ] è½®è¯¢æ›´æ–°å®Œæˆã€‚');
              }, 60000); // æ¯60ç§’æ£€æŸ¥ä¸€æ¬¡
          },

          stopSegmentedMemoryPolling() {
              if (this.segmentedMemoryIntervalId) {
                  console.log('[å½’å¢Ÿ] åœæ­¢åˆ†æ®µè®°å¿†ç»Ÿä¸€è‡ªåŠ¨ç”Ÿæˆè½®è¯¢ã€‚');
                  clearInterval(this.segmentedMemoryIntervalId);
                  this.segmentedMemoryIntervalId = null;
              }
          },

          saveSegmentedMemoryState() {
              try {
                  localStorage.setItem('guixu_segmented_memory_enabled', this.isSegmentedMemoryAutoGenerateEnabled);
              } catch (e) {
                  console.error('ä¿å­˜åˆ†æ®µè®°å¿†çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadSegmentedMemoryState() {
              try {
                  const savedState = localStorage.getItem('guixu_segmented_memory_enabled');
                  this.isSegmentedMemoryAutoGenerateEnabled = savedState === 'true';
                  if (this.isSegmentedMemoryAutoGenerateEnabled) {
                      this.startSegmentedMemoryPolling();
                  }
              } catch (e) {
                  console.error('åŠ è½½åˆ†æ®µè®°å¿†çŠ¶æ€å¤±è´¥:', e);
                  this.isSegmentedMemoryAutoGenerateEnabled = false;
              }
          },

          saveSmallSummaryState() {
              try {
                  localStorage.setItem('guixu_small_summary_enabled', this.isSmallSummaryAutoOn);
              } catch (e) {
                  console.error('ä¿å­˜å°æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
              }
          },

          // --- æ–°å¢ï¼šåˆ†æ®µè®°å¿†ä¿ç•™æ•°å­˜å– ---
          saveSegmentedMemoryCounts() {
              try {
                  const segmentedCount = document.getElementById('segmented-memory-count')?.value || '3';
                  const smallSummaryCount = document.getElementById('small-summary-count')?.value || '25';
                  localStorage.setItem('guixu_segmented_memory_count', segmentedCount);
                  localStorage.setItem('guixu_small_summary_count', smallSummaryCount);
              } catch (e) {
                  console.error('ä¿å­˜åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },

          loadSegmentedMemoryCounts() {
              try {
                  const segmentedCount = localStorage.getItem('guixu_segmented_memory_count');
                  const smallSummaryCount = localStorage.getItem('guixu_small_summary_count');
                  
                  const segmentedCountInput = document.getElementById('segmented-memory-count');
                  if (segmentedCountInput && segmentedCount !== null) {
                      segmentedCountInput.value = segmentedCount;
                  }

                  const smallSummaryCountInput = document.getElementById('small-summary-count');
                  if (smallSummaryCountInput && smallSummaryCount !== null) {
                      smallSummaryCountInput.value = smallSummaryCount;
                  }
              } catch (e) {
                  console.error('åŠ è½½åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },

          // --- æ–°å¢ï¼šåˆ†æ®µè®°å¿†ä¿ç•™æ•°å­˜å– ---
          saveSegmentedMemoryCounts() {
              try {
                  const segmentedCount = document.getElementById('segmented-memory-count')?.value || '3';
                  const smallSummaryCount = document.getElementById('small-summary-count')?.value || '25';
                  localStorage.setItem('guixu_segmented_memory_count', segmentedCount);
                  localStorage.setItem('guixu_small_summary_count', smallSummaryCount);
              } catch (e) {
                  console.error('ä¿å­˜åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },

          loadSegmentedMemoryCounts() {
              try {
                  const segmentedCount = localStorage.getItem('guixu_segmented_memory_count');
                  const smallSummaryCount = localStorage.getItem('guixu_small_summary_count');
                  
                  const segmentedCountInput = document.getElementById('segmented-memory-count');
                  if (segmentedCountInput && segmentedCount !== null) {
                      segmentedCountInput.value = segmentedCount;
                  }

                  const smallSummaryCountInput = document.getElementById('small-summary-count');
                  if (smallSummaryCountInput && smallSummaryCount !== null) {
                      smallSummaryCountInput.value = smallSummaryCount;
                  }
              } catch (e) {
                  console.error('åŠ è½½åˆ†æ®µè®°å¿†ä¿ç•™æ•°å¤±è´¥:', e);
              }
          },

          loadSmallSummaryState() {
              try {
                  const savedState = localStorage.getItem('guixu_small_summary_enabled');
                  this.isSmallSummaryAutoOn = savedState === 'true';
              } catch (e) {
                  console.error('åŠ è½½å°æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
                  this.isSmallSummaryAutoOn = false;
              }
          },

          saveLargeSummaryState() {
              try {
                  localStorage.setItem('guixu_large_summary_enabled', this.isLargeSummaryAutoOn);
              } catch (e) {
                  console.error('ä¿å­˜å¤§æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
              }
          },

          loadLargeSummaryState() {
              try {
                  const savedState = localStorage.getItem('guixu_large_summary_enabled');
                  this.isLargeSummaryAutoOn = savedState === 'true';
              } catch (e) {
                  console.error('åŠ è½½å¤§æ€»ç»“çŠ¶æ€å¤±è´¥:', e);
                  this.isLargeSummaryAutoOn = false;
              }
          },

          // æ˜¾ç¤ºä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
          showWorldbookManager() {
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹æ˜¾ç¤ºä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢');
            
            // å…ˆæ‰“å¼€æ¨¡æ€æ¡†
            this.openModal('worldbook-manager-modal');
            
            // æ£€æŸ¥æ¨¡æ€æ¡†æ˜¯å¦æ­£ç¡®æ˜¾ç¤º
            const modal = document.getElementById('worldbook-manager-modal');
            if (!modal) {
              console.error('[ä¸–ç•Œä¹¦ç®¡ç†] æ‰¾ä¸åˆ°ä¸–ç•Œä¹¦ç®¡ç†æ¨¡æ€æ¡†');
              this.showTemporaryMessage('ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢åŠ è½½å¤±è´¥');
              return;
            }
            
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] æ¨¡æ€æ¡†æ˜¾ç¤ºçŠ¶æ€:', modal.style.display);
            
            // åˆå§‹åŒ–ç•Œé¢çŠ¶æ€
            this.worldbookManagerState = {
              allEntries: [],
              filteredEntries: [],
              currentFilter: 'all',
              currentPrefix: ''
            };
            
            // å»¶è¿Ÿç»‘å®šäº‹ä»¶ç›‘å¬å™¨å’ŒåŠ è½½æ•°æ®ï¼Œç¡®ä¿æ¨¡æ€æ¡†å·²å®Œå…¨æ˜¾ç¤º
            setTimeout(() => {
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹ç»‘å®šäº‹ä»¶ç›‘å¬å™¨');
              this.bindWorldbookManagerEvents();
              
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®');
              this.loadWorldbookEntries();
            }, 100);
          },

          // åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®
          async loadWorldbookEntries() {
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®');
            
            const listContainer = document.getElementById('worldbook-entries-list');
            if (!listContainer) {
              console.error('[ä¸–ç•Œä¹¦ç®¡ç†] æ‰¾ä¸åˆ°æ¡ç›®åˆ—è¡¨å®¹å™¨ worldbook-entries-list');
              return;
            }
            
            console.log('[ä¸–ç•Œä¹¦ç®¡ç†] æ‰¾åˆ°æ¡ç›®åˆ—è¡¨å®¹å™¨');
            
            try {
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 24px; margin-bottom: 10px;">â³</div>æ­£åœ¨åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®...</div>';
              
              const bookName = '1å½’å¢Ÿ';
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹è°ƒç”¨ TavernHelper.getLorebookEntriesï¼Œä¹¦å:', bookName);
              
              const entries = await TavernHelper.getLorebookEntries(bookName);
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] è·å–åˆ°æ¡ç›®æ•°é‡:', entries ? entries.length : 0);
              
              if (!entries || entries.length === 0) {
                console.log('[ä¸–ç•Œä¹¦ç®¡ç†] æ²¡æœ‰æ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›®');
                listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 48px; margin-bottom: 10px;">ğŸ“š</div>æš‚æ— ä¸–ç•Œä¹¦æ¡ç›®</div>';
                this.updateWorldbookStats([], []);
                return;
              }
              
              // ä¿å­˜æ‰€æœ‰æ¡ç›®
              this.worldbookManagerState.allEntries = entries;
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å·²ä¿å­˜æ¡ç›®åˆ°çŠ¶æ€ç®¡ç†');
              
              // åº”ç”¨å½“å‰ç­›é€‰
              console.log('[ä¸–ç•Œä¹¦ç®¡ç†] å¼€å§‹åº”ç”¨ç­›é€‰');
              this.applyWorldbookFilter();
              
            } catch (error) {
              console.error('[ä¸–ç•Œä¹¦ç®¡ç†] åŠ è½½ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', error);
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #ff6b6b;"><div style="font-size: 48px; margin-bottom: 10px;">âŒ</div>åŠ è½½å¤±è´¥ï¼Œè¯·é‡è¯•<br><small>é”™è¯¯: ' + error.message + '</small></div>';
              this.updateWorldbookStats([], []);
            }
          },

          // åº”ç”¨ç­›é€‰æ¡ä»¶
          applyWorldbookFilter() {
            if (!this.worldbookManagerState) return;
            
            const filterType = document.getElementById('worldbook-filter-type')?.value || 'all';
            const prefixFilter = document.getElementById('worldbook-prefix-filter')?.value.trim() || '';
            
            let filtered = [...this.worldbookManagerState.allEntries];
            
            // æŒ‰ç±»å‹ç­›é€‰
            switch (filterType) {
              case 'journey':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('æœ¬ä¸–å†ç¨‹') || entry.comment.includes('å†ç¨‹'))
                );
                break;
              case 'pastlife':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.includes('æ¶Ÿæ¼ª'))
                );
                break;
              case 'bracket':
                filtered = filtered.filter(entry =>
                  entry.comment && entry.comment.includes('ã€') && entry.comment.includes('ã€‘')
                );
                break;
              case 'enabled':
                filtered = filtered.filter(entry => entry.enabled);
                break;
              case 'disabled':
                filtered = filtered.filter(entry => !entry.enabled);
                break;
              case 'all':
              default:
                // ä¸ç­›é€‰
                break;
            }
            
            // æŒ‰å‰ç¼€ç­›é€‰
            if (prefixFilter) {
              filtered = filtered.filter(entry =>
                entry.comment && entry.comment.includes(prefixFilter)
              );
            }
            
            this.worldbookManagerState.filteredEntries = filtered;
            this.worldbookManagerState.currentFilter = filterType;
            this.worldbookManagerState.currentPrefix = prefixFilter;
            
            // æ¸²æŸ“ç­›é€‰åçš„æ¡ç›®
            this.renderWorldbookEntries(filtered);
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            this.updateWorldbookStats(this.worldbookManagerState.allEntries, filtered);
          },

          // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
          updateWorldbookStats(allEntries, filteredEntries) {
            const totalCount = allEntries.length;
            const enabledCount = allEntries.filter(e => e.enabled).length;
            const disabledCount = totalCount - enabledCount;
            const filteredCount = filteredEntries.length;
            
            document.getElementById('stats-total').textContent = totalCount;
            document.getElementById('stats-enabled').textContent = enabledCount;
            document.getElementById('stats-disabled').textContent = disabledCount;
            document.getElementById('stats-filtered').textContent = filteredCount;
          },

          // æ¸²æŸ“ä¸–ç•Œä¹¦æ¡ç›®åˆ—è¡¨
          renderWorldbookEntries(entries) {
            const listContainer = document.getElementById('worldbook-entries-list');
            if (!listContainer) return;
            
            if (!entries || entries.length === 0) {
              listContainer.innerHTML = '<div style="padding: 20px; text-align: center; color: #8b7355;"><div style="font-size: 48px; margin-bottom: 10px;">ğŸ”</div>æ²¡æœ‰ç¬¦åˆç­›é€‰æ¡ä»¶çš„æ¡ç›®</div>';
              return;
            }
            
            listContainer.innerHTML = '';
            
            entries.forEach((entry, index) => {
              const entryDiv = document.createElement('div');
              entryDiv.className = 'worldbook-entry-item';
              entryDiv.style.cssText = `
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 12px;
                margin: 8px;
                background: rgba(26, 26, 46, 0.4);
                border-radius: 6px;
                border: 1px solid ${entry.enabled ? '#4a9eff' : '#8b7355'};
                transition: all 0.2s ease;
              `;
              
              // é¼ æ ‡æ‚¬æµ®æ•ˆæœ
              entryDiv.addEventListener('mouseenter', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.6)';
                entryDiv.style.borderColor = entry.enabled ? '#5ba0ff' : '#c9aa71';
              });
              entryDiv.addEventListener('mouseleave', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.4)';
                entryDiv.style.borderColor = entry.enabled ? '#4a9eff' : '#8b7355';
              });
              
              // å·¦ä¾§ä¿¡æ¯åŒºåŸŸ
              const infoDiv = document.createElement('div');
              infoDiv.style.cssText = 'flex: 1; min-width: 0; margin-right: 15px;';
              
              // åºå·å’Œæ ‡é¢˜
              const titleDiv = document.createElement('div');
              titleDiv.style.cssText = 'display: flex; align-items: center; margin-bottom: 4px;';
              
              const indexSpan = document.createElement('span');
              indexSpan.style.cssText = `
                display: inline-block;
                width: 30px;
                height: 20px;
                line-height: 20px;
                text-align: center;
                background: ${entry.enabled ? '#4a9eff' : '#8b7355'};
                color: white;
                font-size: 10px;
                border-radius: 10px;
                margin-right: 8px;
                font-weight: bold;
              `;
              indexSpan.textContent = (index + 1).toString();
              
              const titleSpan = document.createElement('span');
              titleSpan.style.cssText = `
                color: ${entry.enabled ? '#4a9eff' : '#c9aa71'};
                font-size: 13px;
                font-weight: bold;
                flex: 1;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
              `;
              titleSpan.textContent = entry.comment || 'æœªå‘½åæ¡ç›®';
              titleSpan.title = entry.comment || 'æœªå‘½åæ¡ç›®';
              
              titleDiv.appendChild(indexSpan);
              titleDiv.appendChild(titleSpan);
              
              // çŠ¶æ€å’Œç±»å‹ä¿¡æ¯
              const metaDiv = document.createElement('div');
              metaDiv.style.cssText = 'display: flex; align-items: center; gap: 8px;';
              
              const statusSpan = document.createElement('span');
              statusSpan.style.cssText = `
                color: ${entry.enabled ? '#90ee90' : '#ff6b6b'};
                font-size: 11px;
                font-weight: bold;
              `;
              statusSpan.textContent = entry.enabled ? 'âœ“ å·²å¯ç”¨' : 'âœ— å·²ç¦ç”¨';
              
              // æ¡ç›®ç±»å‹æ ‡ç­¾
              const typeSpan = document.createElement('span');
              let typeText = 'æ™®é€š';
              let typeColor = '#888';
              
              if (entry.comment) {
                if (entry.comment.includes('æœ¬ä¸–å†ç¨‹') || entry.comment.includes('å†ç¨‹')) {
                  typeText = 'æœ¬ä¸–å†ç¨‹';
                  typeColor = '#007bff';
                } else if (entry.comment.includes('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.includes('æ¶Ÿæ¼ª')) {
                  typeText = 'å¾€ä¸–æ¶Ÿæ¼ª';
                  typeColor = '#9932cc';
                } else if (entry.comment.includes('ã€') && entry.comment.includes('ã€‘')) {
                  const match = entry.comment.match(/ã€([^ã€‘]+)ã€‘/);
                  if (match) {
                    typeText = `ã€${match[1]}ã€‘`;
                    typeColor = '#28a745';
                  }
                }
              }
              
              typeSpan.style.cssText = `
                background: rgba(${typeColor === '#007bff' ? '0, 123, 255' :
                                  typeColor === '#9932cc' ? '153, 50, 204' :
                                  typeColor === '#28a745' ? '40, 167, 69' : '136, 136, 136'}, 0.2);
                color: ${typeColor};
                font-size: 10px;
                padding: 2px 6px;
                border-radius: 10px;
                border: 1px solid ${typeColor};
              `;
              typeSpan.textContent = typeText;
              
              metaDiv.appendChild(statusSpan);
              metaDiv.appendChild(typeSpan);
              
              infoDiv.appendChild(titleDiv);
              infoDiv.appendChild(metaDiv);
              
              // å³ä¾§æ“ä½œæŒ‰é’®åŒºåŸŸ
              const actionsDiv = document.createElement('div');
              actionsDiv.style.cssText = 'display: flex; gap: 6px; flex-shrink: 0;';
              
              // å¼€å¯/å…³é—­æŒ‰é’®
              const toggleBtn = document.createElement('button');
              toggleBtn.className = 'interaction-btn';
              toggleBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 11px;
                border: 1px solid ${entry.enabled ? '#ff6b6b' : '#90ee90'};
                background: ${entry.enabled ? 'rgba(255, 107, 107, 0.2)' : 'rgba(144, 238, 144, 0.2)'};
                color: ${entry.enabled ? '#ff6b6b' : '#90ee90'};
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              toggleBtn.textContent = entry.enabled ? 'å…³é—­' : 'å¼€å¯';
              toggleBtn.onclick = () => this.toggleWorldbookEntry(entry.uid, !entry.enabled);
              
              // åˆ é™¤æŒ‰é’®
              const deleteBtn = document.createElement('button');
              deleteBtn.className = 'interaction-btn';
              deleteBtn.style.cssText = `
                padding: 4px 8px;
                font-size: 11px;
                border: 1px solid #ff6b6b;
                background: rgba(255, 107, 107, 0.2);
                color: #ff6b6b;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s ease;
              `;
              deleteBtn.textContent = 'åˆ é™¤';
              deleteBtn.onclick = () => this.deleteWorldbookEntry(entry.uid, entry.comment);
              
              actionsDiv.appendChild(toggleBtn);
              actionsDiv.appendChild(deleteBtn);
              
              entryDiv.appendChild(infoDiv);
              entryDiv.appendChild(actionsDiv);
              
              listContainer.appendChild(entryDiv);
            });
          },

          // æ‰¹é‡å¯ç”¨ç­›é€‰é¡¹
          async enableFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries.filter(e => !e.enabled);
            if (entries.length === 0) {
              this.showTemporaryMessage('æ²¡æœ‰éœ€è¦å¯ç”¨çš„æ¡ç›®');
              return;
            }

            this.showConfirmModal(
              'æ‰¹é‡å¯ç”¨ç¡®è®¤',
              `ç¡®å®šè¦å¯ç”¨ ${entries.length} ä¸ªæ¡ç›®å—ï¼Ÿ`,
              async () => {
                try {
                  const bookName = '1å½’å¢Ÿ';
                  const updates = entries.map(entry => ({ uid: entry.uid, enabled: true }));
                  await TavernHelper.setLorebookEntries(bookName, updates);
                  this.showTemporaryMessage(`å·²å¯ç”¨ ${entries.length} ä¸ªæ¡ç›®`);
                  this.loadWorldbookEntries();
                } catch (error) {
                  console.error('æ‰¹é‡å¯ç”¨å¤±è´¥:', error);
                  this.showTemporaryMessage('æ‰¹é‡å¯ç”¨å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
              }
            );
          },

          // æ‰¹é‡ç¦ç”¨ç­›é€‰é¡¹
          async disableFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries.filter(e => e.enabled);
            if (entries.length === 0) {
              this.showTemporaryMessage('æ²¡æœ‰éœ€è¦ç¦ç”¨çš„æ¡ç›®');
              return;
            }
            
            this.showConfirmModal(
              'æ‰¹é‡ç¦ç”¨ç¡®è®¤',
              `ç¡®å®šè¦ç¦ç”¨ ${entries.length} ä¸ªæ¡ç›®å—ï¼Ÿ`,
              async () => {
                try {
                  const bookName = '1å½’å¢Ÿ';
                  const updates = entries.map(entry => ({ uid: entry.uid, enabled: false }));
                  await TavernHelper.setLorebookEntries(bookName, updates);
                  this.showTemporaryMessage(`å·²ç¦ç”¨ ${entries.length} ä¸ªæ¡ç›®`);
                  this.loadWorldbookEntries();
                } catch (error) {
                  console.error('æ‰¹é‡ç¦ç”¨å¤±è´¥:', error);
                  this.showTemporaryMessage('æ‰¹é‡ç¦ç”¨å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
              }
            );
          },

          // æ˜¾ç¤ºåˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†
          showDeleteConfirmModal(deleteType, deleteData) {
            // å­˜å‚¨åˆ é™¤ç›¸å…³æ•°æ®
            this.deleteConfirmState = {
              type: deleteType, // 'single' æˆ– 'batch'
              data: deleteData, // å•ä¸ªæ¡ç›®çš„ {uid, comment} æˆ–æ‰¹é‡æ¡ç›®æ•°ç»„
              step: 1 // å½“å‰ç¡®è®¤æ­¥éª¤
            };

            // æ›´æ–°æ¨¡æ€æ¡†å†…å®¹
            this.updateDeleteConfirmContent();
            
            // æ˜¾ç¤ºæ¨¡æ€æ¡†
            this.openModal('worldbook-delete-confirm-modal');
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            setTimeout(() => {
              this.bindDeleteConfirmEvents();
            }, 100);
          },

          // æ›´æ–°åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†å†…å®¹
          updateDeleteConfirmContent() {
            const state = this.deleteConfirmState;
            if (!state) return;

            // ä½¿ç”¨ç°æœ‰HTMLç»“æ„ä¸­çš„å…ƒç´ ID
            const step1El = document.getElementById('delete-step-1');
            const step2El = document.getElementById('delete-step-2');
            const deleteItemDetailsEl = document.getElementById('delete-item-details');
            const confirmationInputEl = document.getElementById('delete-confirmation-input');

            if (!step1El || !step2El) {
              console.error('åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            if (state.step === 1) {
              // æ˜¾ç¤ºç¬¬ä¸€æ­¥
              step1El.style.display = 'block';
              step2El.style.display = 'none';
              
              if (deleteItemDetailsEl) {
                if (state.type === 'single') {
                  const { comment } = state.data;
                  deleteItemDetailsEl.innerHTML = `å•ä¸ªæ¡ç›®: <strong>"${comment}"</strong>`;
                } else if (state.type === 'batch') {
                  const entries = state.data;
                  deleteItemDetailsEl.innerHTML = `æ‰¹é‡åˆ é™¤: <strong>${entries.length} ä¸ªæ¡ç›®</strong>`;
                }
              }
            } else {
              // æ˜¾ç¤ºç¬¬äºŒæ­¥
              step1El.style.display = 'none';
              step2El.style.display = 'block';
              
              // æ¸…ç©ºè¾“å…¥æ¡†
              if (confirmationInputEl) {
                confirmationInputEl.value = '';
              }
            }
          },

          // å¤„ç†åˆ é™¤ç¡®è®¤çš„ä¸‹ä¸€æ­¥
          proceedDeleteConfirm() {
            if (!this.deleteConfirmState) return;

            if (this.deleteConfirmState.step === 1) {
              // è¿›å…¥ç¬¬äºŒæ­¥ç¡®è®¤
              this.deleteConfirmState.step = 2;
              this.updateDeleteConfirmContent();
            }
          },

          // æ‰§è¡Œæœ€ç»ˆåˆ é™¤æ“ä½œ
          async executeDelete() {
            const state = this.deleteConfirmState;
            if (!state || state.step !== 2) return;

            // ä¸´æ—¶é˜»æ­¢è‡ªåŠ¨è¿”å›è®¾ç½®ç•Œé¢
            const originalFromSettings = this.isFromSettingsModal;
            this.isFromSettingsModal = false;

            // éªŒè¯è¾“å…¥ - ä½¿ç”¨æ­£ç¡®çš„å…ƒç´ ID
            const inputEl = document.getElementById('delete-confirmation-input');
            if (!inputEl) {
              console.error('åˆ é™¤ç¡®è®¤è¾“å…¥æ¡†æœªæ‰¾åˆ°');
              return;
            }
            
            const input = inputEl.value.trim();
            if (input !== 'ç¡®è®¤åˆ é™¤') {
              this.showTemporaryMessage('è¾“å…¥ä¸æ­£ç¡®ï¼Œè¯·è¾“å…¥"ç¡®è®¤åˆ é™¤"');
              // æ˜¾ç¤ºé”™è¯¯æç¤º
              const errorEl = document.getElementById('delete-input-error');
              if (errorEl) {
                errorEl.style.display = 'block';
                setTimeout(() => {
                  errorEl.style.display = 'none';
                }, 3000);
              }
              // æ¢å¤åŸå§‹çŠ¶æ€
              this.isFromSettingsModal = originalFromSettings;
              return;
            }

            try {
              const bookName = '1å½’å¢Ÿ';
              
              // åœ¨åˆ é™¤å‰è·å–å®Œæ•´çš„æ¡ç›®æ•°æ®ç”¨äºç¼“å­˜
              let entriesToCache = [];
              
              if (state.type === 'single') {
                const { uid } = state.data;
                // ä»å½“å‰åŠ è½½çš„æ¡ç›®ä¸­æ‰¾åˆ°å®Œæ•´æ•°æ®
                const fullEntry = this.worldbookManagerState?.allEntries?.find(entry => entry.uid === uid);
                if (fullEntry) {
                  entriesToCache = [fullEntry];
                }
                await TavernHelper.deleteLorebookEntries(bookName, [uid]);
                this.showTemporaryMessage('ä¸–ç•Œä¹¦æ¡ç›®å·²åˆ é™¤');
              } else if (state.type === 'batch') {
                const uids = state.data.map(entry => entry.uid);
                // è·å–æ‰€æœ‰è¦åˆ é™¤æ¡ç›®çš„å®Œæ•´æ•°æ®
                entriesToCache = state.data.slice(); // å¤åˆ¶æ•°ç»„
                await TavernHelper.deleteLorebookEntries(bookName, uids);
                this.showTemporaryMessage(`å·²åˆ é™¤ ${state.data.length} ä¸ªæ¡ç›®`);
              }

              // å°†åˆ é™¤çš„æ¡ç›®æ·»åŠ åˆ°ç¼“å­˜
              if (entriesToCache.length > 0) {
                this.addToDeleteCache(entriesToCache, state.type);
              }

              // å…³é—­ç¡®è®¤æ¨¡æ€æ¡†
              this.closeModal('worldbook-delete-confirm-modal');
              this.deleteConfirmState = null;
              
              // åˆ·æ–°ä¸–ç•Œä¹¦åˆ—è¡¨
              this.loadWorldbookEntries();
              
              // æ¢å¤åŸå§‹çš„isFromSettingsModalçŠ¶æ€
              this.isFromSettingsModal = originalFromSettings;
              
            } catch (error) {
              console.error('åˆ é™¤æ“ä½œå¤±è´¥:', error);
              this.showTemporaryMessage('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
              // æ¢å¤åŸå§‹çŠ¶æ€
              this.isFromSettingsModal = originalFromSettings;
            }
          },

          // å–æ¶ˆåˆ é™¤æ“ä½œ
          cancelDelete() {
            this.closeModal('worldbook-delete-confirm-modal');
            this.deleteConfirmState = null;
            this.showTemporaryMessage('åˆ é™¤æ“ä½œå·²å–æ¶ˆ');
            // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
            this.showWorldbookManager();
          },

          // --- åˆ é™¤ç¼“å­˜ç®¡ç†åŠŸèƒ½ ---
          
          // æ·»åŠ æ¡ç›®åˆ°åˆ é™¤ç¼“å­˜
          addToDeleteCache(entries, deleteType) {
            try {
              // è·å–ç°æœ‰ç¼“å­˜
              let deleteCache = this.getDeleteCache();
              
              // åˆ›å»ºç¼“å­˜æ¡ç›®
              const cacheEntry = {
                id: Date.now() + Math.random(), // å”¯ä¸€ID
                timestamp: new Date().toISOString(),
                type: deleteType, // 'single' æˆ– 'batch'
                count: entries.length,
                entries: entries.map(entry => {
                  // ä¿å­˜å®Œæ•´çš„æ¡ç›®æ•°æ®ä»¥ç¡®ä¿æ— æŸæ¢å¤ï¼Œä½¿ç”¨æ­£ç¡®çš„APIå­—æ®µç»“æ„
                  const savedEntry = { ...entry }; // å®Œæ•´å¤åˆ¶åŸå§‹æ¡ç›®
                  
                  // ç¡®ä¿å…³é”®å­—æ®µå­˜åœ¨
                  if (!savedEntry.keys) savedEntry.keys = [];
                  if (!savedEntry.filters) savedEntry.filters = [];
                  if (typeof savedEntry.enabled !== 'boolean') savedEntry.enabled = true;
                  if (!savedEntry.type) savedEntry.type = 'selective';
                  if (!savedEntry.position) savedEntry.position = 'after_character_definition';
                  if (!savedEntry.logic) savedEntry.logic = 'and_any';
                  if (typeof savedEntry.probability !== 'number') savedEntry.probability = 100;
                  if (typeof savedEntry.order !== 'number') savedEntry.order = 0;
                  
                  // ç¡®ä¿æ‰«æå’ŒåŒ¹é…è®¾ç½®å­˜åœ¨
                  if (savedEntry.scan_depth === undefined) savedEntry.scan_depth = 'same_as_global';
                  if (savedEntry.case_sensitive === undefined) savedEntry.case_sensitive = 'same_as_global';
                  if (savedEntry.match_whole_words === undefined) savedEntry.match_whole_words = 'same_as_global';
                  if (savedEntry.use_group_scoring === undefined) savedEntry.use_group_scoring = 'same_as_global';
                  
                  // ç¡®ä¿é€’å½’æ§åˆ¶å­—æ®µå­˜åœ¨
                  if (typeof savedEntry.exclude_recursion !== 'boolean') savedEntry.exclude_recursion = false;
                  if (typeof savedEntry.prevent_recursion !== 'boolean') savedEntry.prevent_recursion = false;
                  if (savedEntry.delay_until_recursion === undefined) savedEntry.delay_until_recursion = false;
                  
                  // ç¡®ä¿åˆ†ç»„å’Œå…¶ä»–é«˜çº§å­—æ®µå­˜åœ¨
                  if (!savedEntry.group) savedEntry.group = '';
                  if (typeof savedEntry.group_prioritized !== 'boolean') savedEntry.group_prioritized = false;
                  if (typeof savedEntry.group_weight !== 'number') savedEntry.group_weight = 100;
                  
                  // ç¡®ä¿å¯ä¸ºnullçš„å­—æ®µæ­£ç¡®å¤„ç†
                  if (savedEntry.sticky === undefined) savedEntry.sticky = null;
                  if (savedEntry.cooldown === undefined) savedEntry.cooldown = null;
                  if (savedEntry.delay === undefined) savedEntry.delay = null;
                  if (savedEntry.automation_id === undefined) savedEntry.automation_id = null;
                  if (savedEntry.depth === undefined) savedEntry.depth = null;
                  
                  // ç¡®ä¿åŸºç¡€å­—ç¬¦ä¸²å­—æ®µå­˜åœ¨
                  if (!savedEntry.comment) savedEntry.comment = '';
                  if (!savedEntry.content) savedEntry.content = '';
                  
                  console.log('[åˆ é™¤ç¼“å­˜] ä¿å­˜çš„å®Œæ•´å­—æ®µ:', Object.keys(savedEntry));
                  console.log('[åˆ é™¤ç¼“å­˜] å­—æ®µè¯¦æƒ…:', {
                    uid: savedEntry.uid,
                    display_index: savedEntry.display_index,
                    comment: savedEntry.comment,
                    enabled: savedEntry.enabled,
                    type: savedEntry.type,
                    position: savedEntry.position,
                    depth: savedEntry.depth,
                    order: savedEntry.order,
                    probability: savedEntry.probability,
                    keys: savedEntry.keys,
                    logic: savedEntry.logic,
                    filters: savedEntry.filters,
                    scan_depth: savedEntry.scan_depth,
                    case_sensitive: savedEntry.case_sensitive,
                    match_whole_words: savedEntry.match_whole_words,
                    use_group_scoring: savedEntry.use_group_scoring,
                    automation_id: savedEntry.automation_id,
                    exclude_recursion: savedEntry.exclude_recursion,
                    prevent_recursion: savedEntry.prevent_recursion,
                    delay_until_recursion: savedEntry.delay_until_recursion,
                    content: savedEntry.content,
                    group: savedEntry.group,
                    group_prioritized: savedEntry.group_prioritized,
                    group_weight: savedEntry.group_weight,
                    sticky: savedEntry.sticky,
                    cooldown: savedEntry.cooldown,
                    delay: savedEntry.delay
                  });
                  
                  return savedEntry;
                })
              };
              
              // æ·»åŠ åˆ°ç¼“å­˜å¼€å¤´
              deleteCache.unshift(cacheEntry);
              
              // ä¿æŒæœ€å¤š10ä¸ªç¼“å­˜æ¡ç›®
              if (deleteCache.length > 10) {
                deleteCache = deleteCache.slice(0, 10);
              }
              
              // ä¿å­˜åˆ°localStorage
              localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(deleteCache));
              
              console.log(`[åˆ é™¤ç¼“å­˜] å·²ç¼“å­˜ ${entries.length} ä¸ªæ¡ç›®ï¼Œç¼“å­˜æ€»æ•°: ${deleteCache.length}`);
              
            } catch (error) {
              console.error('ä¿å­˜åˆ é™¤ç¼“å­˜å¤±è´¥:', error);
            }
          },

          // è·å–åˆ é™¤ç¼“å­˜
          getDeleteCache() {
            try {
              const cache = localStorage.getItem('guixu_worldbook_delete_cache');
              return cache ? JSON.parse(cache) : [];
            } catch (error) {
              console.error('è¯»å–åˆ é™¤ç¼“å­˜å¤±è´¥:', error);
              return [];
            }
          },

          // ä»ç¼“å­˜ä¸­æ¢å¤æ¡ç›®
          async restoreFromCache(cacheId) {
            // ä¸´æ—¶é˜»æ­¢è‡ªåŠ¨è¿”å›è®¾ç½®ç•Œé¢
            const originalFromSettings = this.isFromSettingsModal;
            this.isFromSettingsModal = false;
            
            try {
              const deleteCache = this.getDeleteCache();
              const cacheEntry = deleteCache.find(entry => entry.id === cacheId);
              
              if (!cacheEntry) {
                this.showTemporaryMessage('ç¼“å­˜æ¡ç›®ä¸å­˜åœ¨');
                // æ¢å¤åŸå§‹çŠ¶æ€
                this.isFromSettingsModal = originalFromSettings;
                return;
              }

              const bookName = '1å½’å¢Ÿ';
              
              console.log('[æ¢å¤ç¼“å­˜] å¼€å§‹æ¢å¤æ¡ç›®:', cacheEntry);
              
              // å‡†å¤‡è¦æ¢å¤çš„æ¡ç›®æ•°æ®ï¼Œåªç§»é™¤uidå’Œdisplay_indexè®©ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆï¼Œä¿ç•™æ‰€æœ‰å…¶ä»–å­—æ®µ
              const entriesToRestore = cacheEntry.entries.map(entry => {
                const newEntry = { ...entry }; // å®Œæ•´å¤åˆ¶ç¼“å­˜çš„æ¡ç›®æ•°æ®
                
                // åªç§»é™¤è¿™ä¸¤ä¸ªå­—æ®µï¼Œè®©APIè‡ªåŠ¨ç”Ÿæˆ
                delete newEntry.uid;
                delete newEntry.display_index;
                
                // éªŒè¯æ‰€æœ‰APIè¦æ±‚çš„å­—æ®µéƒ½å­˜åœ¨ï¼Œç¡®ä¿æ•°æ®å®Œæ•´æ€§
                const requiredFields = [
                  'comment', 'enabled', 'type', 'position', 'depth', 'order', 'probability',
                  'keys', 'logic', 'filters', 'scan_depth', 'case_sensitive', 'match_whole_words',
                  'use_group_scoring', 'automation_id', 'exclude_recursion', 'prevent_recursion',
                  'delay_until_recursion', 'content', 'group', 'group_prioritized', 'group_weight',
                  'sticky', 'cooldown', 'delay'
                ];
                
                // æ£€æŸ¥æ˜¯å¦æœ‰ç¼ºå¤±çš„å­—æ®µ
                const missingFields = requiredFields.filter(field => !(field in newEntry));
                if (missingFields.length > 0) {
                  console.warn('[æ¢å¤ç¼“å­˜] å‘ç°ç¼ºå¤±å­—æ®µ:', missingFields);
                }
                
                // éªŒè¯å­—æ®µç±»å‹å’Œå€¼çš„æ­£ç¡®æ€§
                console.log('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®çš„å®Œæ•´å­—æ®µéªŒè¯:', {
                  comment: typeof newEntry.comment + ' = ' + JSON.stringify(newEntry.comment),
                  enabled: typeof newEntry.enabled + ' = ' + newEntry.enabled,
                  type: typeof newEntry.type + ' = ' + newEntry.type,
                  position: typeof newEntry.position + ' = ' + newEntry.position,
                  depth: typeof newEntry.depth + ' = ' + newEntry.depth,
                  order: typeof newEntry.order + ' = ' + newEntry.order,
                  probability: typeof newEntry.probability + ' = ' + newEntry.probability,
                  keys: Array.isArray(newEntry.keys) + ' = ' + JSON.stringify(newEntry.keys),
                  logic: typeof newEntry.logic + ' = ' + newEntry.logic,
                  filters: Array.isArray(newEntry.filters) + ' = ' + JSON.stringify(newEntry.filters),
                  scan_depth: typeof newEntry.scan_depth + ' = ' + newEntry.scan_depth,
                  case_sensitive: typeof newEntry.case_sensitive + ' = ' + newEntry.case_sensitive,
                  match_whole_words: typeof newEntry.match_whole_words + ' = ' + newEntry.match_whole_words,
                  use_group_scoring: typeof newEntry.use_group_scoring + ' = ' + newEntry.use_group_scoring,
                  automation_id: typeof newEntry.automation_id + ' = ' + newEntry.automation_id,
                  exclude_recursion: typeof newEntry.exclude_recursion + ' = ' + newEntry.exclude_recursion,
                  prevent_recursion: typeof newEntry.prevent_recursion + ' = ' + newEntry.prevent_recursion,
                  delay_until_recursion: typeof newEntry.delay_until_recursion + ' = ' + newEntry.delay_until_recursion,
                  content: typeof newEntry.content + ' = ' + JSON.stringify(newEntry.content?.substring(0, 50) + '...'),
                  group: typeof newEntry.group + ' = ' + JSON.stringify(newEntry.group),
                  group_prioritized: typeof newEntry.group_prioritized + ' = ' + newEntry.group_prioritized,
                  group_weight: typeof newEntry.group_weight + ' = ' + newEntry.group_weight,
                  sticky: typeof newEntry.sticky + ' = ' + newEntry.sticky,
                  cooldown: typeof newEntry.cooldown + ' = ' + newEntry.cooldown,
                  delay: typeof newEntry.delay + ' = ' + newEntry.delay
                });
                
                console.log('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®å­—æ®µæ€»æ•°:', Object.keys(newEntry).length);
                console.log('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®æ‰€æœ‰å­—æ®µ:', Object.keys(newEntry).sort());
                
                return newEntry;
              });

              console.log('[æ¢å¤ç¼“å­˜] å‡†å¤‡æ¢å¤çš„æ¡ç›®:', entriesToRestore);

              // ä½¿ç”¨createLorebookEntries APIåˆ›å»ºæ–°æ¡ç›®
              const result = await TavernHelper.createLorebookEntries(bookName, entriesToRestore);
              console.log('[æ¢å¤ç¼“å­˜] æ¢å¤ç»“æœ:', result);

              if (result && result.new_uids && result.new_uids.length > 0) {
                // ä»ç¼“å­˜ä¸­ç§»é™¤å·²æ¢å¤çš„æ¡ç›®
                const updatedCache = deleteCache.filter(entry => entry.id !== cacheId);
                localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(updatedCache));
                
                this.showTemporaryMessage(`æˆåŠŸæ¢å¤ ${result.new_uids.length} ä¸ªæ¡ç›®`);
                
                // åˆ·æ–°ä¸–ç•Œä¹¦åˆ—è¡¨
                this.loadWorldbookEntries();
                
                // å¦‚æœåˆ é™¤å†å²ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°å®ƒ
                if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                  this.renderDeleteHistory();
                }
                
                // æ¢å¤åŸå§‹çš„isFromSettingsModalçŠ¶æ€
                this.isFromSettingsModal = originalFromSettings;
                
              } else {
                console.error('[æ¢å¤ç¼“å­˜] æ¢å¤å¤±è´¥ï¼ŒAPIè¿”å›ç»“æœå¼‚å¸¸:', result);
                this.showTemporaryMessage('æ¢å¤å¤±è´¥ï¼šAPIè°ƒç”¨å¼‚å¸¸');
              }
              
            } catch (error) {
              console.error('[æ¢å¤ç¼“å­˜] æ¢å¤æ¡ç›®å¤±è´¥:', error);
              this.showTemporaryMessage(`æ¢å¤å¤±è´¥: ${error.message}`);
            }
          },

          // æ˜¾ç¤ºé€šç”¨ç¡®è®¤æ¨¡æ€æ¡†
          showConfirmModal(title, message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-confirm-modal');
            const titleEl = document.getElementById('confirm-modal-title');
            const messageEl = document.getElementById('confirm-modal-message');
            const confirmBtn = document.getElementById('confirm-modal-confirm');
            const cancelBtn = document.getElementById('confirm-modal-cancel');

            if (!modal || !titleEl || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            titleEl.textContent = title;
            messageEl.innerHTML = message;

            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-confirm-modal');
              if (onConfirm) onConfirm();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-confirm-modal');
              if (onCancel) onCancel();
            });

            this.openModal('worldbook-confirm-modal');
          },

          // æ˜¾ç¤ºæ¢å¤ç¡®è®¤æ¨¡æ€æ¡†
          showRestoreConfirmModal(message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-restore-confirm-modal');
            const messageEl = document.getElementById('restore-confirm-message');
            const confirmBtn = document.getElementById('restore-confirm-confirm');
            const cancelBtn = document.getElementById('restore-confirm-cancel');

            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('æ¢å¤ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            messageEl.innerHTML = message;

            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-restore-confirm-modal');
              if (onConfirm) onConfirm();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-restore-confirm-modal');
              if (onCancel) onCancel();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            this.openModal('worldbook-restore-confirm-modal');
          },

          // æ˜¾ç¤ºç§»é™¤å†å²ç¡®è®¤æ¨¡æ€æ¡†
          showRemoveHistoryConfirmModal(message, onConfirm, onCancel = null) {
            const modal = document.getElementById('worldbook-remove-history-confirm-modal');
            const messageEl = document.getElementById('remove-history-confirm-message');
            const confirmBtn = document.getElementById('remove-history-confirm-confirm');
            const cancelBtn = document.getElementById('remove-history-confirm-cancel');

            if (!modal || !messageEl || !confirmBtn || !cancelBtn) {
              console.error('ç§»é™¤å†å²ç¡®è®¤æ¨¡æ€æ¡†å…ƒç´ æœªæ‰¾åˆ°');
              return;
            }

            messageEl.innerHTML = message;

            // æ¸…é™¤ä¹‹å‰çš„äº‹ä»¶ç›‘å¬å™¨
            const newConfirmBtn = confirmBtn.cloneNode(true);
            const newCancelBtn = cancelBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

            // æ·»åŠ æ–°çš„äº‹ä»¶ç›‘å¬å™¨
            newConfirmBtn.addEventListener('click', () => {
              this.closeModal('worldbook-remove-history-confirm-modal');
              if (onConfirm) onConfirm();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            newCancelBtn.addEventListener('click', () => {
              this.closeModal('worldbook-remove-history-confirm-modal');
              if (onCancel) onCancel();
              // è¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
              this.showWorldbookManager();
            });

            this.openModal('worldbook-remove-history-confirm-modal');
          },

          // æ¸…ç©ºåˆ é™¤ç¼“å­˜
          clearDeleteCache() {
            try {
              localStorage.removeItem('guixu_worldbook_delete_cache');
              this.showTemporaryMessage('åˆ é™¤ç¼“å­˜å·²æ¸…ç©º');
              
              // å¦‚æœåˆ é™¤å†å²ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œåˆ·æ–°å®ƒ
              if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                this.renderDeleteHistory();
              }
            } catch (error) {
              console.error('æ¸…ç©ºåˆ é™¤ç¼“å­˜å¤±è´¥:', error);
            }
          },

          // ä»ç¼“å­˜ä¸­ç§»é™¤æŒ‡å®šæ¡ç›®
          removeFromCache(cacheId) {
            try {
              const deleteCache = this.getDeleteCache();
              const updatedCache = deleteCache.filter(entry => entry.id !== cacheId);
              localStorage.setItem('guixu_worldbook_delete_cache', JSON.stringify(updatedCache));
              
              // å¦‚æœåˆ é™¤å†å²ç•Œé¢æ˜¯æ‰“å¼€çš„ï¼Œåˆ·æ–°å®ƒ
              if (document.getElementById('worldbook-delete-history-modal')?.style.display !== 'none') {
                this.renderDeleteHistory();
              }
            } catch (error) {
              console.error('ç§»é™¤ç¼“å­˜æ¡ç›®å¤±è´¥:', error);
            }
          },

          // --- åˆ é™¤å†å²ç®¡ç†ç•Œé¢åŠŸèƒ½ ---
          
          // æ˜¾ç¤ºåˆ é™¤å†å²ç®¡ç†ç•Œé¢
          showDeleteHistory() {
            this.openModal('worldbook-delete-history-modal');
            this.renderDeleteHistory();
            
            // ç»‘å®šäº‹ä»¶ç›‘å¬å™¨
            setTimeout(() => {
              this.bindDeleteHistoryEvents();
            }, 100);
          },

          // æ¸²æŸ“åˆ é™¤å†å²åˆ—è¡¨
          renderDeleteHistory() {
            const listContainer = document.getElementById('delete-history-list');
            const countElement = document.getElementById('delete-history-count');
            
            if (!listContainer || !countElement) return;

            const deleteCache = this.getDeleteCache();
            
            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            countElement.textContent = `å…±æœ‰ ${deleteCache.length} æ¡åˆ é™¤è®°å½•`;

            if (deleteCache.length === 0) {
              listContainer.innerHTML = `
                <div style="text-align: center; padding: 40px; color: #8b7355;">
                  <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“­</div>
                  <div style="font-size: 16px; margin-bottom: 8px;">æš‚æ— åˆ é™¤è®°å½•</div>
                  <div style="font-size: 12px;">åˆ é™¤çš„æ¡ç›®ä¼šè‡ªåŠ¨ä¿å­˜åœ¨è¿™é‡Œï¼Œæ–¹ä¾¿æ‚¨éšæ—¶æ¢å¤</div>
                </div>
              `;
              return;
            }

            listContainer.innerHTML = '';

            deleteCache.forEach((cacheEntry, index) => {
              const entryDiv = document.createElement('div');
              entryDiv.className = 'delete-history-item';
              entryDiv.style.cssText = `
                background: rgba(26, 26, 46, 0.4);
                border: 1px solid #8b7355;
                border-radius: 8px;
                padding: 15px;
                margin-bottom: 12px;
                transition: all 0.3s ease;
              `;

              // é¼ æ ‡æ‚¬æµ®æ•ˆæœ
              entryDiv.addEventListener('mouseenter', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.6)';
                entryDiv.style.borderColor = '#c9aa71';
              });
              entryDiv.addEventListener('mouseleave', () => {
                entryDiv.style.background = 'rgba(26, 26, 46, 0.4)';
                entryDiv.style.borderColor = '#8b7355';
              });

              const deleteTime = new Date(cacheEntry.timestamp);
              const timeStr = deleteTime.toLocaleString('zh-CN');
              
              entryDiv.innerHTML = `
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 12px;">
                  <div style="flex: 1;">
                    <div style="display: flex; align-items: center; margin-bottom: 8px;">
                      <span style="background: ${cacheEntry.type === 'single' ? '#007bff' : '#9932cc'}; color: white; padding: 2px 8px; border-radius: 12px; font-size: 10px; margin-right: 10px;">
                        ${cacheEntry.type === 'single' ? 'å•ä¸ªåˆ é™¤' : 'æ‰¹é‡åˆ é™¤'}
                      </span>
                      <span style="color: #c9aa71; font-size: 14px; font-weight: bold;">
                        ${cacheEntry.count} ä¸ªæ¡ç›®
                      </span>
                    </div>
                    <div style="color: #8b7355; font-size: 12px; margin-bottom: 8px;">
                      åˆ é™¤æ—¶é—´: ${timeStr}
                    </div>
                    <div style="color: #8b7355; font-size: 11px;">
                      ${cacheEntry.entries.map(entry => entry.comment || 'æœªå‘½åæ¡ç›®').slice(0, 3).join(', ')}
                      ${cacheEntry.entries.length > 3 ? ` ç­‰${cacheEntry.entries.length}ä¸ªæ¡ç›®` : ''}
                    </div>
                  </div>
                  <div style="display: flex; gap: 8px; flex-shrink: 0;">
                    <button class="restore-cache-btn interaction-btn" data-cache-id="${cacheEntry.id}"
                            style="background: rgba(40, 167, 69, 0.2); border-color: #28a745; color: #28a745; font-size: 11px; padding: 6px 12px;">
                      ğŸ”„ æ¢å¤
                    </button>
                    <button class="remove-cache-btn interaction-btn" data-cache-id="${cacheEntry.id}"
                            style="background: rgba(255, 107, 107, 0.2); border-color: #ff6b6b; color: #ff6b6b; font-size: 11px; padding: 6px 12px;">
                      ğŸ—‘ï¸ ç§»é™¤
                    </button>
                  </div>
                </div>
                <div class="delete-history-details" style="background: rgba(0, 0, 0, 0.2); border-radius: 4px; padding: 10px; font-size: 11px; color: #8b7355; max-height: 100px; overflow-y: auto;">
                  <strong>åŒ…å«æ¡ç›®:</strong><br>
                  ${cacheEntry.entries.map((entry, i) => `${i + 1}. ${entry.comment || 'æœªå‘½åæ¡ç›®'}`).join('<br>')}
                </div>
              `;

              listContainer.appendChild(entryDiv);
            });
          },

          // ç»‘å®šåˆ é™¤å†å²ç•Œé¢äº‹ä»¶ç›‘å¬å™¨
          bindDeleteHistoryEvents() {
            // æ¸…ç©ºå†å²æŒ‰é’®
            const clearBtn = document.getElementById('clear-delete-history-btn');
            if (clearBtn) {
              clearBtn.addEventListener('click', () => {
                this.showConfirmModal(
                  'æ¸…ç©ºåˆ é™¤å†å²',
                  'ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰åˆ é™¤å†å²å—ï¼Ÿ<br><br><span style="color: #ff6b6b; font-weight: bold;">âš ï¸ æ¸…ç©ºåå°†æ— æ³•æ¢å¤è¿™äº›è®°å½•</span>',
                  () => {
                    this.clearDeleteCache();
                  }
                );
              });
            }

            // å…³é—­æŒ‰é’®
            const closeBtn = document.getElementById('close-delete-history');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-delete-history-modal');
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
            const modal = document.getElementById('worldbook-delete-history-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-delete-history-modal');
                }
              });
            }

            // æ¢å¤å’Œç§»é™¤æŒ‰é’®äº‹ä»¶å§”æ‰˜
            const listContainer = document.getElementById('delete-history-list');
            if (listContainer) {
              listContainer.addEventListener('click', (e) => {
                const target = e.target;
                
                if (target.classList.contains('restore-cache-btn')) {
                  const cacheId = parseFloat(target.dataset.cacheId);
                  this.showRestoreConfirmModal(
                    'ç¡®å®šè¦æ¢å¤è¿™äº›åˆ é™¤çš„æ¡ç›®å—ï¼Ÿ',
                    () => this.restoreFromCache(cacheId)
                  );
                } else if (target.classList.contains('remove-cache-btn')) {
                  const cacheId = parseFloat(target.dataset.cacheId);
                  this.showRemoveHistoryConfirmModal(
                    'ç¡®å®šè¦ä»å†å²è®°å½•ä¸­ç§»é™¤è¿™æ¡è®°å½•å—ï¼Ÿ<br><span style="color: #ff6b6b; font-weight: bold;">ç§»é™¤åå°†æ— æ³•æ¢å¤ã€‚</span>',
                    () => this.removeFromCache(cacheId)
                  );
                }
              });
            }
          },

          // æ‰¹é‡åˆ é™¤ç­›é€‰é¡¹ï¼ˆä¿®æ”¹ä¸ºä½¿ç”¨æ–°çš„ç¡®è®¤æµç¨‹ï¼‰
          async deleteFilteredEntries() {
            if (!this.worldbookManagerState?.filteredEntries) return;
            
            const entries = this.worldbookManagerState.filteredEntries;
            if (entries.length === 0) {
              this.showTemporaryMessage('æ²¡æœ‰éœ€è¦åˆ é™¤çš„æ¡ç›®');
              return;
            }

            // ä½¿ç”¨æ–°çš„åˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†
            this.showDeleteConfirmModal('batch', entries);
          },

          async toggleWorldbookEntry(uid, enabled) {
            try {
              const bookName = '1å½’å¢Ÿ';
              await TavernHelper.setLorebookEntries(bookName, [{ uid, enabled }]);
              this.showTemporaryMessage(`ä¸–ç•Œä¹¦æ¡ç›®å·²${enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`);
              this.loadWorldbookEntries(); // åˆ·æ–°åˆ—è¡¨
            } catch (error) {
              console.error('åˆ‡æ¢ä¸–ç•Œä¹¦æ¡ç›®çŠ¶æ€å¤±è´¥:', error);
              this.showTemporaryMessage('æ“ä½œå¤±è´¥ï¼Œè¯·é‡è¯•');
            }
          },

          // åˆ é™¤å•ä¸ªä¸–ç•Œä¹¦æ¡ç›®ï¼ˆç®€åŒ–ä¸ºä¸€æ¬¡ç¡®è®¤ï¼‰
          async deleteWorldbookEntry(uid, comment) {
            // å•ä¸ªæ¡ç›®åˆ é™¤åªéœ€è¦ç®€å•ç¡®è®¤ï¼Œä¸éœ€è¦äºŒæ¬¡ç¡®è®¤å’Œè¾“å…¥æ–‡æœ¬
            this.showConfirmModal(
              'åˆ é™¤æ¡ç›®ç¡®è®¤',
              `ç¡®å®šè¦åˆ é™¤æ¡ç›® <strong>"${comment}"</strong> å—ï¼Ÿ<br><br><span style="color: #4a9eff;">ğŸ’¾ åˆ é™¤åå¯ä»¥åœ¨åˆ é™¤å†å²ä¸­æ¢å¤</span>`,
              async () => {
                try {
                  const bookName = '1å½’å¢Ÿ';
                  
                  // åœ¨åˆ é™¤å‰è·å–å®Œæ•´çš„æ¡ç›®æ•°æ®ç”¨äºç¼“å­˜
                  const fullEntry = this.worldbookManagerState?.allEntries?.find(entry => entry.uid === uid);
                  if (fullEntry) {
                    // æ·»åŠ åˆ°åˆ é™¤ç¼“å­˜
                    this.addToDeleteCache([fullEntry]);
                  }
                  
                  // æ‰§è¡Œåˆ é™¤
                  await TavernHelper.deleteLorebookEntries(bookName, [uid]);
                  this.showTemporaryMessage('ä¸–ç•Œä¹¦æ¡ç›®å·²åˆ é™¤');
                  
                  // åˆ·æ–°åˆ—è¡¨
                  await this.loadWorldbookEntries();
                } catch (error) {
                  console.error('åˆ é™¤ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', error);
                  this.showTemporaryMessage('åˆ é™¤å¤±è´¥ï¼Œè¯·é‡è¯•');
                }
              }
            );
          },

          // ç»‘å®šä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢äº‹ä»¶ç›‘å¬å™¨
          bindWorldbookManagerEvents() {
            // ç­›é€‰ç±»å‹å˜åŒ–
            const filterTypeSelect = document.getElementById('worldbook-filter-type');
            if (filterTypeSelect) {
              filterTypeSelect.addEventListener('change', () => {
                this.applyWorldbookFilter();
              });
            }

            // å‰ç¼€ç­›é€‰è¾“å…¥
            const prefixFilterInput = document.getElementById('worldbook-prefix-filter');
            if (prefixFilterInput) {
              prefixFilterInput.addEventListener('input', () => {
                this.applyWorldbookFilter();
              });
            }

            // æ‰¹é‡æ“ä½œæŒ‰é’®
            const enableBtn = document.getElementById('enable-filtered-btn');
            if (enableBtn) {
              enableBtn.addEventListener('click', () => {
                this.enableFilteredEntries();
              });
            }

            const disableBtn = document.getElementById('disable-filtered-btn');
            if (disableBtn) {
              disableBtn.addEventListener('click', () => {
                this.disableFilteredEntries();
              });
            }

            // å³ä¸Šè§’åˆ é™¤æŒ‰é’®
            const deleteHeaderBtn = document.getElementById('delete-filtered-btn-header');
            if (deleteHeaderBtn) {
              deleteHeaderBtn.addEventListener('click', () => {
                this.deleteFilteredEntries();
              });
            }

            // åˆ é™¤å†å²æŒ‰é’®
            const deleteHistoryBtn = document.getElementById('show-delete-history-btn');
            if (deleteHistoryBtn) {
              deleteHistoryBtn.addEventListener('click', () => {
                this.showDeleteHistory();
              });
            }

            // å…³é—­æŒ‰é’®
            const closeBtn = document.getElementById('close-worldbook-manager');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-manager-modal');
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
            const modal = document.getElementById('worldbook-manager-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-manager-modal');
                }
              });
            }
          },

          // ç»‘å®šåˆ é™¤ç¡®è®¤æ¨¡æ€æ¡†äº‹ä»¶ç›‘å¬å™¨
          bindDeleteConfirmEvents() {
            // ç¬¬ä¸€æ­¥ç¡®è®¤æŒ‰é’®
            const proceedBtn = document.getElementById('confirm-delete-step1-btn');
            if (proceedBtn) {
              proceedBtn.addEventListener('click', () => {
                this.proceedDeleteConfirm();
              });
            }

            // ç¬¬ä¸€æ­¥å–æ¶ˆæŒ‰é’®
            const cancelStep1Btn = document.getElementById('cancel-delete-btn');
            if (cancelStep1Btn) {
              cancelStep1Btn.addEventListener('click', () => {
                this.cancelDelete();
              });
            }

            // æœ€ç»ˆç¡®è®¤æŒ‰é’®
            const confirmBtn = document.getElementById('final-delete-btn');
            if (confirmBtn) {
              confirmBtn.addEventListener('click', () => {
                this.executeDelete();
              });
            }

            // è¿”å›æŒ‰é’®
            const backBtn = document.getElementById('back-delete-step-btn');
            if (backBtn) {
              backBtn.addEventListener('click', () => {
                this.deleteConfirmState.step = 1;
                this.updateDeleteConfirmContent();
              });
            }

            // è¾“å…¥æ¡†å›è½¦é”®ç¡®è®¤
            const confirmInput = document.getElementById('delete-confirmation-input');
            if (confirmInput) {
              confirmInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                  this.executeDelete();
                }
              });
            }

            // å…³é—­æŒ‰é’®
            const closeBtn = document.getElementById('close-delete-confirm');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.cancelDelete();
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­
            const modal = document.getElementById('worldbook-delete-confirm-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.cancelDelete();
                }
              });
            }
          },

          // --- æ–°å¢ï¼šä¸–ç•Œä¹¦é¢„è®¾ç®¡ç†åŠŸèƒ½ ---
          // æ˜¾ç¤ºé¢„è®¾ç®¡ç†ç•Œé¢
          showWorldbookPresets() {
            console.log('[é¢„è®¾ç®¡ç†] å¼€å§‹æ˜¾ç¤ºé¢„è®¾ç®¡ç†ç•Œé¢');
            this.openModal('worldbook-presets-modal');
            
            // å»¶è¿ŸåŠ è½½é¢„è®¾åˆ—è¡¨ï¼Œç¡®ä¿æ¨¡æ€æ¡†å·²æ˜¾ç¤º
            setTimeout(() => {
              this.loadWorldbookPresets();
              this.bindPresetsManagerEvents();
            }, 100);
          },

          // åŠ è½½é¢„è®¾åˆ—è¡¨
          loadWorldbookPresets() {
            try {
              const saved = localStorage.getItem('guixu_worldbook_presets');
              if (saved) {
                this.worldbookPresets = JSON.parse(saved);
              }
              this.renderPresetsList();
            } catch (error) {
              console.error('[é¢„è®¾ç®¡ç†] åŠ è½½é¢„è®¾å¤±è´¥:', error);
              this.worldbookPresets = {};
            }
          },

          // æ¸²æŸ“é¢„è®¾åˆ—è¡¨
          renderPresetsList() {
            const listContainer = document.getElementById('presets-list');
            if (!listContainer) return;

            const presets = Object.values(this.worldbookPresets);
            if (presets.length === 0) {
              listContainer.innerHTML = `
                <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                  <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‹</div>
                  <div style="font-size: 16px; margin-bottom: 8px;">æš‚æ— é¢„è®¾</div>
                  <div style="font-size: 12px; opacity: 0.8;">ç‚¹å‡»å³ä¸Šè§’"æ–°å»ºé¢„è®¾"æŒ‰é’®åˆ›å»ºç¬¬ä¸€ä¸ªé¢„è®¾</div>
                </div>
              `;
              return;
            }

            const html = presets.map(preset => `
              <div class="preset-item" data-preset-id="${preset.id}" style="
                padding: 12px;
                margin-bottom: 8px;
                background: rgba(26, 26, 46, 0.6);
                border: 1px solid #8b7355;
                border-radius: 6px;
                cursor: pointer;
                transition: all 0.2s ease;
                ${this.presetManagerState.selectedPresetId === preset.id ? 'border-color: #c9aa71; background: rgba(201, 170, 113, 0.1);' : ''}
              ">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 6px;">
                  <div style="color: #c9aa71; font-weight: bold; font-size: 14px;">${preset.name}</div>
                  <div style="display: flex; gap: 4px;">
                    <span style="
                      background: ${preset.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(108, 117, 125, 0.2)'};
                      color: ${preset.enabled ? '#28a745' : '#6c757d'};
                      padding: 2px 6px;
                      border-radius: 3px;
                      font-size: 10px;
                    ">${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span>
                    <span style="color: #8b7355; font-size: 10px; padding: 2px 6px; background: rgba(139, 115, 85, 0.2); border-radius: 3px;">
                      ${preset.entries.length} é¡¹
                    </span>
                  </div>
                </div>
                <div style="color: #8b7355; font-size: 12px; line-height: 1.4; margin-bottom: 8px;">
                  ${preset.description || 'æ— æè¿°'}
                </div>
                <div style="color: #666; font-size: 10px;">
                  åˆ›å»ºæ—¶é—´: ${new Date(preset.createdAt).toLocaleString()}
                </div>
              </div>
            `).join('');

            listContainer.innerHTML = html;
          },

          // æ˜¾ç¤ºé¢„è®¾è¯¦æƒ…
          showPresetDetails(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            this.presetManagerState.selectedPresetId = presetId;
            this.renderPresetsList(); // é‡æ–°æ¸²æŸ“ä»¥æ›´æ–°é€‰ä¸­çŠ¶æ€

            const detailsContainer = document.getElementById('preset-details');
            if (!detailsContainer) return;

            const html = `
              <div style="height: 100%; display: flex; flex-direction: column;">
                <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                  <div>
                    <h3 style="color: #c9aa71; margin: 0 0 8px 0; font-size: 18px;">${preset.name}</h3>
                    <p style="color: #8b7355; margin: 0; font-size: 13px; line-height: 1.4;">
                      ${preset.description || 'æ— æè¿°'}
                    </p>
                  </div>
                  <div style="display: flex; gap: 6px;">
                    <button class="interaction-btn" onclick="GuixuManager.editPreset('${preset.id}')" style="padding: 4px 8px; font-size: 11px;">ç¼–è¾‘</button>
                    <button class="interaction-btn" onclick="GuixuManager.togglePresetStatus('${preset.id}')" style="
                      padding: 4px 8px;
                      font-size: 11px;
                      background: ${preset.enabled ? 'rgba(108, 117, 125, 0.2)' : 'rgba(40, 167, 69, 0.2)'};
                      border-color: ${preset.enabled ? '#6c757d' : '#28a745'};
                      color: ${preset.enabled ? '#6c757d' : '#28a745'};
                    ">${preset.enabled ? 'ç¦ç”¨' : 'å¯ç”¨'}</button>
                    <button class="interaction-btn" onclick="GuixuManager.deletePreset('${preset.id}')" style="
                      padding: 4px 8px;
                      font-size: 11px;
                      background: rgba(255, 107, 107, 0.2);
                      border-color: #ff6b6b;
                      color: #ff6b6b;
                    ">åˆ é™¤</button>
                  </div>
                </div>

                <div style="flex: 1; overflow-y: auto;">
                  <div style="margin-bottom: 15px;">
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      ğŸ“š åŒ…å«æ¡ç›® (${preset.entries.length})
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; padding: 10px; max-height: 200px; overflow-y: auto;">
                      ${preset.entries.length > 0 ?
                        preset.entries.map(entryName => `
                          <div style="
                            padding: 6px 8px;
                            margin-bottom: 4px;
                            background: rgba(26, 26, 46, 0.6);
                            border-radius: 4px;
                            color: #e0dcd1;
                            font-size: 12px;
                            border-left: 3px solid #c9aa71;
                          ">${entryName}</div>
                        `).join('') :
                        '<div style="color: #8b7355; text-align: center; padding: 20px;">æš‚æ— æ¡ç›®</div>'
                      }
                    </div>
                  </div>

                  <div style="margin-bottom: 15px;">
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      âš™ï¸ é¢„è®¾ä¿¡æ¯
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; padding: 10px;">
                      <div style="display: grid; grid-template-columns: 80px 1fr; gap: 8px; font-size: 12px;">
                        <span style="color: #8b7355;">çŠ¶æ€:</span>
                        <span style="color: ${preset.enabled ? '#28a745' : '#6c757d'};">
                          ${preset.enabled ? 'âœ… å¯ç”¨ä¸­' : 'âŒ å·²ç¦ç”¨'}
                        </span>
                        <span style="color: #8b7355;">æ¡ç›®æ•°:</span>
                        <span style="color: #e0dcd1;">${preset.entries.length} ä¸ª</span>
                        <span style="color: #8b7355;">åˆ›å»ºæ—¶é—´:</span>
                        <span style="color: #e0dcd1;">${new Date(preset.createdAt).toLocaleString()}</span>
                        <span style="color: #8b7355;">æœ€åä¿®æ”¹:</span>
                        <span style="color: #e0dcd1;">${preset.updatedAt ? new Date(preset.updatedAt).toLocaleString() : 'æœªä¿®æ”¹'}</span>
                      </div>
                    </div>
                  </div>

                  <div>
                    <div style="color: #c9aa71; font-size: 14px; font-weight: bold; margin-bottom: 8px;">
                      ğŸ¯ å¿«é€Ÿæ“ä½œ
                    </div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="interaction-btn" onclick="GuixuManager.exportPreset('${preset.id}')" style="padding: 8px 12px; font-size: 12px;">å¯¼å‡ºé¢„è®¾</button>
                      <button class="interaction-btn" onclick="GuixuManager.duplicatePreset('${preset.id}')" style="padding: 8px 12px; font-size: 12px;">å¤åˆ¶é¢„è®¾</button>
                    </div>
                  </div>
                </div>
              </div>
            `;

            detailsContainer.innerHTML = html;
          },

          // æ˜¾ç¤ºåˆ›å»º/ç¼–è¾‘é¢„è®¾ç•Œé¢
          showCreatePresetModal(presetId = null) {
            this.currentEditingPreset = presetId;
            this.presetManagerState.isEditing = !!presetId;
            
            const modal = document.getElementById('preset-edit-modal');
            const title = document.getElementById('preset-edit-title');
            
            // å…ˆæ‰“å¼€æ¨¡æ€æ¡†
            this.openModal('preset-edit-modal');
            
            // å»¶è¿Ÿé¢„å¡«å……å†…å®¹ï¼Œç¡®ä¿DOMå·²æ¸²æŸ“
            setTimeout(() => {
              if (presetId) {
                title.textContent = 'ğŸ“ ç¼–è¾‘é¢„è®¾';
                const preset = this.worldbookPresets[presetId];
                if (preset) {
                  document.getElementById('preset-name-input').value = preset.name || '';
                  document.getElementById('preset-description-input').value = preset.description || '';
                }
              } else {
                title.textContent = 'ğŸ“ æ–°å»ºé¢„è®¾';
                document.getElementById('preset-name-input').value = '';
                document.getElementById('preset-description-input').value = '';
              }
              
              // åŠ è½½æ¡ç›®é€‰æ‹©åˆ—è¡¨
              this.loadEntriesForPresetEdit(presetId);
              this.bindPresetEditEvents();
            }, 150);
          },

          // åŠ è½½æ¡ç›®é€‰æ‹©åˆ—è¡¨
          async loadEntriesForPresetEdit(presetId = null) {
            try {
              const bookName = '1å½’å¢Ÿ';
              const entries = await TavernHelper.getLorebookEntries(bookName);
              
              if (!entries || entries.length === 0) {
                document.getElementById('preset-entries-selection').innerHTML =
                  '<div style="text-align: center; color: #8b7355; padding: 20px;">æš‚æ— å¯é€‰æ¡ç›®</div>';
                this.updatePresetFilterStats(0, 0);
                return;
              }

              // è·å–å·²é€‰æ¡ç›®åˆ—è¡¨
              let selectedEntries = [];
              if (presetId && this.worldbookPresets[presetId]) {
                selectedEntries = [...this.worldbookPresets[presetId].entries];
                console.log('[é¢„è®¾ç¼–è¾‘] åŠ è½½å·²é€‰æ¡ç›®:', selectedEntries);
              }

              // å­˜å‚¨æ‰€æœ‰æ¡ç›®ç”¨äºç­›é€‰
              this.presetEditState = {
                allEntries: entries,
                filteredEntries: entries,
                selectedEntries: selectedEntries
              };
              
              // åº”ç”¨å½“å‰ç­›é€‰å¹¶æ¸²æŸ“
              this.applyPresetFilter();
              
              // ç¡®ä¿å¤é€‰æ¡†çŠ¶æ€æ­£ç¡®æ›´æ–°
              setTimeout(() => {
                this.updateCheckboxStates();
              }, 50);
              
            } catch (error) {
              console.error('[é¢„è®¾ç®¡ç†] åŠ è½½æ¡ç›®å¤±è´¥:', error);
              document.getElementById('preset-entries-selection').innerHTML =
                '<div style="text-align: center; color: #ff6b6b; padding: 20px;">åŠ è½½æ¡ç›®å¤±è´¥</div>';
              this.updatePresetFilterStats(0, 0);
            }
          },

          // æ›´æ–°å¤é€‰æ¡†çŠ¶æ€
          updateCheckboxStates() {
            if (!this.presetEditState?.selectedEntries) return;
            
            const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
            checkboxes.forEach(checkbox => {
              const entryName = checkbox.dataset.entryName;
              const isSelected = this.presetEditState.selectedEntries.includes(entryName);
              checkbox.checked = isSelected;
              
              // æ›´æ–°è¾¹æ¡†é¢œè‰²
              const parentDiv = checkbox.closest('div');
              if (parentDiv) {
                parentDiv.style.borderColor = isSelected ? '#c9aa71' : '#8b7355';
              }
            });
            
            console.log('[é¢„è®¾ç¼–è¾‘] å¤é€‰æ¡†çŠ¶æ€å·²æ›´æ–°ï¼Œå·²é€‰æ¡ç›®:', this.presetEditState.selectedEntries.length);
          },

          // åº”ç”¨é¢„è®¾æ¡ç›®ç­›é€‰
          applyPresetFilter() {
            if (!this.presetEditState) return;

            const filterType = document.getElementById('preset-filter-type')?.value || 'all';
            const prefixFilter = document.getElementById('preset-prefix-filter')?.value.trim() || '';
            
            let filtered = [...this.presetEditState.allEntries];
            
            // æŒ‰ç±»å‹ç­›é€‰
            switch (filterType) {
              case 'journey':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('æœ¬ä¸–å†ç¨‹') || entry.comment.includes('å†ç¨‹'))
                );
                break;
              case 'pastlife':
                filtered = filtered.filter(entry =>
                  entry.comment && (entry.comment.includes('å¾€ä¸–æ¶Ÿæ¼ª') || entry.comment.includes('æ¶Ÿæ¼ª'))
                );
                break;
              case 'bracket':
                filtered = filtered.filter(entry =>
                  entry.comment && entry.comment.includes('ã€') && entry.comment.includes('ã€‘')
                );
                break;
              case 'enabled':
                filtered = filtered.filter(entry => entry.enabled);
                break;
              case 'disabled':
                filtered = filtered.filter(entry => !entry.enabled);
                break;
              case 'all':
              default:
                // ä¸ç­›é€‰
                break;
            }
            
            // æŒ‰å…³é”®è¯ç­›é€‰
            if (prefixFilter) {
              filtered = filtered.filter(entry =>
                entry.comment && entry.comment.includes(prefixFilter)
              );
            }
            
            this.presetEditState.filteredEntries = filtered;
            this.renderPresetEntries(filtered);
            this.updatePresetFilterStats(filtered.length, this.presetEditState.allEntries.length);
          },

          // æ¸²æŸ“é¢„è®¾æ¡ç›®åˆ—è¡¨
          renderPresetEntries(entries) {
            const selectedEntries = this.presetEditState.selectedEntries;
            
            const html = entries.map(entry => {
              const isSelected = selectedEntries.includes(entry.comment || entry.uid);
              return `
                <div style="
                  display: flex;
                  align-items: center;
                  padding: 8px;
                  margin-bottom: 4px;
                  background: rgba(26, 26, 46, 0.4);
                  border-radius: 4px;
                  border: 1px solid ${isSelected ? '#c9aa71' : '#8b7355'};
                ">
                  <input type="checkbox"
                         id="entry-${entry.uid}"
                         data-entry-name="${entry.comment || entry.uid}"
                         ${isSelected ? 'checked' : ''}
                         style="margin-right: 10px; cursor: pointer;">
                  <label for="entry-${entry.uid}" style="
                    flex: 1;
                    cursor: pointer;
                    color: #e0dcd1;
                    font-size: 13px;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                  ">
                    <span>${entry.comment || entry.uid}</span>
                    <span style="
                      color: ${entry.enabled ? '#28a745' : '#6c757d'};
                      font-size: 10px;
                      padding: 2px 6px;
                      background: ${entry.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(108, 117, 125, 0.2)'};
                      border-radius: 3px;
                    ">${entry.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span>
                  </label>
                </div>
              `;
            }).join('');

            document.getElementById('preset-entries-selection').innerHTML = html ||
              '<div style="text-align: center; color: #8b7355; padding: 20px;">æ²¡æœ‰ç¬¦åˆæ¡ä»¶çš„æ¡ç›®</div>';
          },

          // æ›´æ–°é¢„è®¾ç­›é€‰ç»Ÿè®¡ä¿¡æ¯
          updatePresetFilterStats(filtered, total) {
            const statsElement = document.getElementById('preset-filter-stats');
            if (statsElement) {
              statsElement.textContent = `æ˜¾ç¤º: ${filtered}/${total}`;
            }
          },

          // ä¿å­˜é¢„è®¾
          savePreset() {
            const name = document.getElementById('preset-name-input').value.trim();
            const description = document.getElementById('preset-description-input').value.trim();
            
            if (!name) {
              this.showTemporaryMessage('è¯·è¾“å…¥é¢„è®¾åç§°', 'error', 3000);
              return;
            }

            // è·å–é€‰ä¸­çš„æ¡ç›®
            const selectedEntries = [];
            const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]:checked');
            checkboxes.forEach(checkbox => {
              selectedEntries.push(checkbox.dataset.entryName);
            });

            if (selectedEntries.length === 0) {
              this.showTemporaryMessage('è¯·è‡³å°‘é€‰æ‹©ä¸€ä¸ªæ¡ç›®', 'error', 3000);
              return;
            }

            const presetId = this.currentEditingPreset || this.generatePresetId();
            const now = new Date().toISOString();
            
            const preset = {
              id: presetId,
              name: name,
              description: description,
              entries: selectedEntries,
              enabled: this.currentEditingPreset ? this.worldbookPresets[this.currentEditingPreset].enabled : true,
              createdAt: this.currentEditingPreset ? this.worldbookPresets[this.currentEditingPreset].createdAt : now,
              updatedAt: now
            };

            this.worldbookPresets[presetId] = preset;
            this.saveWorldbookPresets();
            
            this.closeModal('preset-edit-modal');
            this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage(
              this.currentEditingPreset ? 'é¢„è®¾å·²æ›´æ–°' : 'é¢„è®¾å·²åˆ›å»º',
              'success',
              3000
            );
          },

          // ç”Ÿæˆé¢„è®¾ID
          generatePresetId() {
            return 'preset_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          },

          // ä¿å­˜é¢„è®¾åˆ°æœ¬åœ°å­˜å‚¨
          saveWorldbookPresets() {
            try {
              localStorage.setItem('guixu_worldbook_presets', JSON.stringify(this.worldbookPresets));
            } catch (error) {
              console.error('[é¢„è®¾ç®¡ç†] ä¿å­˜é¢„è®¾å¤±è´¥:', error);
            }
          },

          // åˆ‡æ¢é¢„è®¾çŠ¶æ€
          togglePresetStatus(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            preset.enabled = !preset.enabled;
            preset.updatedAt = new Date().toISOString();
            
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.showPresetDetails(presetId);
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage(
              `é¢„è®¾å·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}`,
              'success'
            );
          },

          // åˆ é™¤é¢„è®¾
          deletePreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            // showCustomConfirmçš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯æ¶ˆæ¯ï¼Œç¬¬äºŒä¸ªæ˜¯ç¡®è®¤å›è°ƒï¼Œç¬¬ä¸‰ä¸ªæ˜¯å–æ¶ˆå›è°ƒï¼Œç¬¬å››ä¸ªæ˜¯ä¿æŒå½“å‰æ¨¡æ€æ¡†
            this.showCustomConfirm(
              `ç¡®å®šè¦åˆ é™¤é¢„è®¾"${preset.name}"å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`,
              () => {
                // åˆ é™¤é¢„è®¾æ•°æ®
                delete this.worldbookPresets[presetId];
                this.saveWorldbookPresets();
                
                // æ›´æ–°ç•Œé¢
                this.renderPresetsList();
                this.updatePresetsInSettings();
                
                // æ¸…ç©ºè¯¦æƒ…é¢æ¿
                const detailsPanel = document.getElementById('preset-details');
                if (detailsPanel) {
                  detailsPanel.innerHTML = `
                    <div style="text-align: center; color: #8b7355; padding: 40px 20px;">
                      <div style="font-size: 48px; margin-bottom: 15px;">ğŸ“‹</div>
                      <div style="font-size: 16px; margin-bottom: 8px;">é€‰æ‹©é¢„è®¾æŸ¥çœ‹è¯¦æƒ…</div>
                      <div style="font-size: 12px; opacity: 0.8;">ç‚¹å‡»å·¦ä¾§é¢„è®¾é¡¹ç›®æŸ¥çœ‹å’Œç¼–è¾‘è¯¦ç»†ä¿¡æ¯</div>
                    </div>
                  `;
                }
                
                // é‡ç½®é€‰ä¸­çŠ¶æ€
                if (this.presetManagerState) {
                  this.presetManagerState.selectedPresetId = null;
                }
                
                this.showTemporaryMessage('é¢„è®¾å·²åˆ é™¤', 'success', 3000);
              },
              null, // å–æ¶ˆå›è°ƒ
              true  // keepCurrentModal - ä¿æŒé¢„è®¾ç®¡ç†æ¨¡æ€æ¡†æ‰“å¼€
            );
          },

          // åº”ç”¨é¢„è®¾ï¼ˆæ‰¹é‡å¼€å¯/å…³é—­æ¡ç›®ï¼‰
          async applyPreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            try {
              const bookName = '1å½’å¢Ÿ';
              
              // è·å–æ‰€æœ‰ä¸–ç•Œä¹¦æ¡ç›®
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              if (!allEntries || allEntries.length === 0) {
                this.showTemporaryMessage('æœªæ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›®', 'error');
                return;
              }

              // æ‰¾åˆ°éœ€è¦æ›´æ–°çš„æ¡ç›®
              const entriesToUpdate = [];
              let successCount = 0;
              let failCount = 0;

              for (const entryName of preset.entries) {
                const entry = allEntries.find(e => (e.comment || e.uid.toString()) === entryName);
                if (entry) {
                  entriesToUpdate.push({
                    uid: entry.uid,
                    enabled: preset.enabled
                  });
                  successCount++;
                } else {
                  console.warn(`[é¢„è®¾åº”ç”¨] æœªæ‰¾åˆ°æ¡ç›®: ${entryName}`);
                  failCount++;
                }
              }

              // æ‰¹é‡æ›´æ–°æ¡ç›®
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }

              const message = failCount > 0 ?
                `é¢„è®¾åº”ç”¨å®Œæˆï¼šæˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª` :
                `é¢„è®¾åº”ç”¨æˆåŠŸï¼šå·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'} ${successCount} ä¸ªæ¡ç›®`;
              
              this.showTemporaryMessage(message, failCount > 0 ? 'warning' : 'success', 3000);
            } catch (error) {
              console.error('[é¢„è®¾åº”ç”¨] åº”ç”¨é¢„è®¾å¤±è´¥:', error);
              this.showTemporaryMessage('åº”ç”¨é¢„è®¾å¤±è´¥', 'error', 3000);
            }
          },

          // ç¼–è¾‘é¢„è®¾
          editPreset(presetId) {
            this.showCreatePresetModal(presetId);
          },

          // å¤åˆ¶é¢„è®¾
          duplicatePreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            const newPresetId = this.generatePresetId();
            const now = new Date().toISOString();
            
            const newPreset = {
              ...preset,
              id: newPresetId,
              name: preset.name + ' (å‰¯æœ¬)',
              createdAt: now,
              updatedAt: now
            };

            this.worldbookPresets[newPresetId] = newPreset;
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.updatePresetsInSettings();
            
            this.showTemporaryMessage('é¢„è®¾å·²å¤åˆ¶', 'success', 3000);
          },

          // å¯¼å‡ºé¢„è®¾
          exportPreset(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            const exportData = {
              version: '1.0',
              preset: preset,
              exportTime: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `å½’å¢Ÿé¢„è®¾_${preset.name}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            this.showTemporaryMessage('é¢„è®¾å·²å¯¼å‡º', 'success', 3000);
          },

          // æ›´æ–°è®¾ç½®ç•Œé¢ä¸­çš„é¢„è®¾åˆ—è¡¨
          updatePresetsInSettings() {
            const container = document.getElementById('worldbook-presets-container');
            if (!container) return;

            const presets = Object.values(this.worldbookPresets);
            if (presets.length === 0) {
              container.innerHTML = `
                <div style="color: #8b7355; font-size: 12px; text-align: center; padding: 10px;">
                  æš‚æ— é¢„è®¾ï¼Œç‚¹å‡»ä¸Šæ–¹æŒ‰é’®åˆ›å»ºé¢„è®¾
                </div>
              `;
              return;
            }

            // åˆå§‹åŒ–æŠ˜å çŠ¶æ€ï¼ˆå¦‚æœä¸å­˜åœ¨ï¼‰
            if (!this.presetCollapseState) {
              this.presetCollapseState = {
                mainCollapsed: true, // ä¸»é¢æ¿é»˜è®¤æŠ˜å 
                presetDetails: {} // å„ä¸ªé¢„è®¾çš„è¯¦æƒ…æŠ˜å çŠ¶æ€
              };
            }

            const mainCollapsed = this.presetCollapseState.mainCollapsed;
            const html = `
              <!-- ä¸»æ ‡é¢˜æ  -->
              <div style="
                display: flex;
                align-items: center;
                justify-content: space-between;
                padding: 8px 10px;
                background: rgba(0, 0, 0, 0.4);
                border-radius: 4px;
                cursor: pointer;
                border: 1px solid #8b7355;
              " onclick="GuixuManager.toggleMainPresetCollapse()">
                <div style="display: flex; align-items: center; gap: 8px;">
                  <span style="
                    color: #c9aa71;
                    font-size: 12px;
                    font-weight: bold;
                    transform: rotate(${mainCollapsed ? '0deg' : '90deg'});
                    transition: transform 0.2s ease;
                  ">â–¶</span>
                  <span style="color: #c9aa71; font-size: 13px; font-weight: bold;">ä¸–ç•Œä¹¦é¢„è®¾</span>
                </div>
                <span style="
                  color: #8b7355;
                  font-size: 10px;
                  padding: 2px 6px;
                  background: rgba(139, 115, 85, 0.2);
                  border-radius: 2px;
                ">${presets.length} ä¸ª</span>
              </div>

              <!-- é¢„è®¾åˆ—è¡¨ -->
              <div id="preset-list-content" style="
                display: ${mainCollapsed ? 'none' : 'block'};
                margin-top: 6px;
                padding-left: 8px;
              ">
                ${presets.map(preset => this.renderPresetItem(preset)).join('')}
              </div>
            `;

            container.innerHTML = html;
          },

          // æ¸²æŸ“å•ä¸ªé¢„è®¾é¡¹
          renderPresetItem(preset) {
            const isExpanded = this.presetCollapseState.presetDetails[preset.id] || false;
            
            return `
              <div style="margin-bottom: 8px;">
                <!-- é¢„è®¾æ ‡é¢˜æ  -->
                <div style="
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  padding: 6px 8px;
                  background: rgba(26, 26, 46, 0.4);
                  border-radius: 4px;
                  border: 1px solid ${preset.enabled ? '#c9aa71' : '#8b7355'};
                ">
                  <div style="display: flex; align-items: center; gap: 8px; flex: 1;">
                    <input type="checkbox"
                           id="preset-toggle-${preset.id}"
                           ${preset.enabled ? 'checked' : ''}
                           onchange="GuixuManager.togglePresetFromSettings('${preset.id}')"
                           style="cursor: pointer;">
                    <span style="
                      color: #e0dcd1;
                      font-size: 11px;
                      cursor: pointer;
                      transform: rotate(${isExpanded ? '90deg' : '0deg'});
                      transition: transform 0.2s ease;
                    " onclick="GuixuManager.togglePresetDetails('${preset.id}')">â–¶</span>
                    <label for="preset-toggle-${preset.id}" style="
                      color: #e0dcd1;
                      font-size: 12px;
                      cursor: pointer;
                      flex: 1;
                    " onclick="GuixuManager.togglePresetDetails('${preset.id}')">${preset.name}</label>
                  </div>
                  <div style="display: flex; align-items: center; gap: 4px;">
                    <span style="
                      color: ${preset.enabled ? '#28a745' : '#8b7355'};
                      font-size: 9px;
                      padding: 1px 4px;
                      background: ${preset.enabled ? 'rgba(40, 167, 69, 0.2)' : 'rgba(139, 115, 85, 0.2)'};
                      border-radius: 2px;
                    ">${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}</span>
                    <span style="
                      color: #8b7355;
                      font-size: 10px;
                      padding: 2px 4px;
                      background: rgba(139, 115, 85, 0.2);
                      border-radius: 2px;
                    ">${preset.entries.length}</span>
                  </div>
                </div>

                <!-- é¢„è®¾è¯¦æƒ… -->
                <div id="preset-details-${preset.id}" style="
                  display: ${isExpanded ? 'block' : 'none'};
                  margin-top: 4px;
                  margin-left: 16px;
                  padding: 8px;
                  background: rgba(0, 0, 0, 0.2);
                  border-radius: 4px;
                  border-left: 2px solid #c9aa71;
                ">
                  ${preset.description ? `
                    <div style="
                      color: #8b7355;
                      font-size: 11px;
                      margin-bottom: 6px;
                      line-height: 1.3;
                    ">${preset.description}</div>
                  ` : ''}
                  
                  <div style="
                    color: #8b7355;
                    font-size: 10px;
                    font-weight: bold;
                    margin-bottom: 4px;
                  ">åŒ…å«æ¡ç›® (${preset.entries.length}):</div>
                  
                  <div style="
                    max-height: 120px;
                    overflow-y: auto;
                    font-size: 10px;
                  ">
                    ${preset.entries.length > 0 ?
                      preset.entries.map(entryName => `
                        <div style="
                          color: #e0dcd1;
                          padding: 2px 4px;
                          margin-bottom: 2px;
                          background: rgba(26, 26, 46, 0.3);
                          border-radius: 2px;
                          border-left: 2px solid #8b7355;
                        ">â€¢ ${entryName}</div>
                      `).join('') :
                      '<div style="color: #8b7355; text-align: center; padding: 8px;">æš‚æ— æ¡ç›®</div>'
                    }
                  </div>
                  
                  <div style="
                    margin-top: 6px;
                    padding-top: 6px;
                    border-top: 1px solid rgba(139, 115, 85, 0.3);
                    font-size: 9px;
                    color: #666;
                  ">
                    åˆ›å»º: ${new Date(preset.createdAt).toLocaleString('zh-CN', {
                      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    })}
                    ${preset.updatedAt ? ` | æ›´æ–°: ${new Date(preset.updatedAt).toLocaleString('zh-CN', {
                      month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit'
                    })}` : ''}
                  </div>
                </div>
              </div>
            `;
          },

          // åˆ‡æ¢ä¸»é¢„è®¾é¢æ¿æŠ˜å çŠ¶æ€
          toggleMainPresetCollapse() {
            if (!this.presetCollapseState) {
              this.presetCollapseState = { mainCollapsed: true, presetDetails: {} };
            }
            
            this.presetCollapseState.mainCollapsed = !this.presetCollapseState.mainCollapsed;
            this.updatePresetsInSettings();
          },

          // åˆ‡æ¢é¢„è®¾è¯¦æƒ…æŠ˜å çŠ¶æ€
          togglePresetDetails(presetId) {
            if (!this.presetCollapseState) {
              this.presetCollapseState = { mainCollapsed: false, presetDetails: {} };
            }
            
            this.presetCollapseState.presetDetails[presetId] = !this.presetCollapseState.presetDetails[presetId];
            this.updatePresetsInSettings();
          },

          // ä»è®¾ç½®ç•Œé¢åˆ‡æ¢é¢„è®¾çŠ¶æ€
          async togglePresetFromSettings(presetId) {
            const preset = this.worldbookPresets[presetId];
            if (!preset) return;

            // åˆ‡æ¢é¢„è®¾çŠ¶æ€
            preset.enabled = !preset.enabled;
            preset.updatedAt = new Date().toISOString();
            
            this.saveWorldbookPresets();
            this.renderPresetsList();
            this.updatePresetsInSettings();
            
            // è‡ªåŠ¨åº”ç”¨é¢„è®¾ï¼ˆæ‰¹é‡å¼€å¯/å…³é—­ç›¸å…³ä¸–ç•Œä¹¦æ¡ç›®ï¼‰
            try {
              const bookName = '1å½’å¢Ÿ';
              
              // è·å–æ‰€æœ‰ä¸–ç•Œä¹¦æ¡ç›®
              const allEntries = await TavernHelper.getLorebookEntries(bookName);
              if (!allEntries || allEntries.length === 0) {
                this.showTemporaryMessage('æœªæ‰¾åˆ°ä¸–ç•Œä¹¦æ¡ç›®', 'error', 3000);
                return;
              }

              // æ‰¾åˆ°éœ€è¦æ›´æ–°çš„æ¡ç›®
              const entriesToUpdate = [];
              let successCount = 0;
              let failCount = 0;

              for (const entryName of preset.entries) {
                const entry = allEntries.find(e => (e.comment || e.uid.toString()) === entryName);
                if (entry) {
                  entriesToUpdate.push({
                    uid: entry.uid,
                    enabled: preset.enabled
                  });
                  successCount++;
                } else {
                  console.warn(`[é¢„è®¾åº”ç”¨] æœªæ‰¾åˆ°æ¡ç›®: ${entryName}`);
                  failCount++;
                }
              }

              // æ‰¹é‡æ›´æ–°æ¡ç›®
              if (entriesToUpdate.length > 0) {
                await TavernHelper.setLorebookEntries(bookName, entriesToUpdate);
              }

              const message = failCount > 0 ?
                `é¢„è®¾"${preset.name}"å·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}ï¼šæˆåŠŸ ${successCount} ä¸ªï¼Œå¤±è´¥ ${failCount} ä¸ª` :
                `é¢„è®¾"${preset.name}"å·²${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}ï¼š${preset.enabled ? 'å¯ç”¨' : 'ç¦ç”¨'}äº† ${successCount} ä¸ªæ¡ç›®`;
              
              this.showTemporaryMessage(message, failCount > 0 ? 'warning' : 'success', 3000);
            } catch (error) {
              console.error('[é¢„è®¾åº”ç”¨] åº”ç”¨é¢„è®¾å¤±è´¥:', error);
              this.showTemporaryMessage('åº”ç”¨é¢„è®¾å¤±è´¥', 'error', 3000);
            }
          },

          // ç»‘å®šé¢„è®¾ç®¡ç†äº‹ä»¶
          bindPresetsManagerEvents() {
            // é¢„è®¾åˆ—è¡¨ç‚¹å‡»äº‹ä»¶
            const listContainer = document.getElementById('presets-list');
            if (listContainer) {
              listContainer.addEventListener('click', (e) => {
                const presetItem = e.target.closest('.preset-item');
                if (presetItem) {
                  const presetId = presetItem.dataset.presetId;
                  this.showPresetDetails(presetId);
                }
              });
            }

            // æ–°å»ºé¢„è®¾æŒ‰é’®
            const createBtn = document.getElementById('create-preset-btn');
            if (createBtn) {
              createBtn.addEventListener('click', () => {
                this.showCreatePresetModal();
              });
            }

            // å…³é—­æŒ‰é’® - ä¼˜åŒ–ï¼šè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
            const closeBtn = document.getElementById('close-presets-modal');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('worldbook-presets-modal');
                // å¦‚æœæ˜¯ä»ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢è¿›å…¥çš„ï¼Œè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
                if (this.isFromWorldbookManager) {
                  this.showWorldbookManager();
                  this.isFromWorldbookManager = false; // é‡ç½®æ ‡å¿—ä½
                }
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­ - ä¼˜åŒ–ï¼šè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
            const modal = document.getElementById('worldbook-presets-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('worldbook-presets-modal');
                  // å¦‚æœæ˜¯ä»ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢è¿›å…¥çš„ï¼Œè¿”å›åˆ°ä¸–ç•Œä¹¦ç®¡ç†ç•Œé¢
                  if (this.isFromWorldbookManager) {
                    this.showWorldbookManager();
                    this.isFromWorldbookManager = false; // é‡ç½®æ ‡å¿—ä½
                  }
                }
              });
            }
          },

          // ç»‘å®šé¢„è®¾ç¼–è¾‘äº‹ä»¶
          bindPresetEditEvents() {
            // å…ˆæ¸…ç†æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼Œé¿å…é‡å¤ç»‘å®š
            this.cleanupPresetEditEvents();

            // ç­›é€‰ç±»å‹å˜åŒ–
            const filterTypeSelect = document.getElementById('preset-filter-type');
            if (filterTypeSelect) {
              filterTypeSelect.addEventListener('change', () => {
                this.applyPresetFilter();
              });
            }

            // å…³é”®è¯ç­›é€‰è¾“å…¥
            const prefixFilterInput = document.getElementById('preset-prefix-filter');
            if (prefixFilterInput) {
              prefixFilterInput.addEventListener('input', () => {
                this.applyPresetFilter();
              });
            }

            // æ¡ç›®å¤é€‰æ¡†å˜åŒ–ç›‘å¬ï¼ˆä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼‰
            const entriesContainer = document.getElementById('preset-entries-selection');
            if (entriesContainer) {
              entriesContainer.addEventListener('change', (e) => {
                if (e.target.type === 'checkbox') {
                  const entryName = e.target.dataset.entryName;
                  if (!this.presetEditState) this.presetEditState = { selectedEntries: [] };
                  
                  if (e.target.checked) {
                    // æ·»åŠ åˆ°å·²é€‰åˆ—è¡¨
                    if (!this.presetEditState.selectedEntries.includes(entryName)) {
                      this.presetEditState.selectedEntries.push(entryName);
                    }
                  } else {
                    // ä»å·²é€‰åˆ—è¡¨ç§»é™¤
                    const index = this.presetEditState.selectedEntries.indexOf(entryName);
                    if (index > -1) {
                      this.presetEditState.selectedEntries.splice(index, 1);
                    }
                  }
                  
                  // æ›´æ–°è¾¹æ¡†é¢œè‰²
                  const parentDiv = e.target.closest('div');
                  if (parentDiv) {
                    parentDiv.style.borderColor = e.target.checked ? '#c9aa71' : '#8b7355';
                  }
                  
                  console.log('[é¢„è®¾ç¼–è¾‘] æ¡ç›®é€‰æ‹©å˜åŒ–:', entryName, e.target.checked);
                }
              });
            }

            // å…¨é€‰æŒ‰é’®
            const selectAllBtn = document.getElementById('select-all-entries');
            if (selectAllBtn) {
              selectAllBtn.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(cb => {
                  cb.checked = true;
                  // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°selectedEntries
                  cb.dispatchEvent(new Event('change', { bubbles: true }));
                });
              });
            }

            // å…¨ä¸é€‰æŒ‰é’®
            const deselectAllBtn = document.getElementById('deselect-all-entries');
            if (deselectAllBtn) {
              deselectAllBtn.addEventListener('click', () => {
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(cb => {
                  cb.checked = false;
                  // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°selectedEntries
                  cb.dispatchEvent(new Event('change', { bubbles: true }));
                });
              });
            }

            // é€‰æ‹©å·²å¯ç”¨æŒ‰é’®
            const selectEnabledBtn = document.getElementById('select-enabled-entries');
            if (selectEnabledBtn) {
              selectEnabledBtn.addEventListener('click', () => {
                if (!this.presetEditState?.filteredEntries) return;
                
                const checkboxes = document.querySelectorAll('#preset-entries-selection input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                  const entryName = checkbox.dataset.entryName;
                  const entry = this.presetEditState.filteredEntries.find(e => (e.comment || e.uid) === entryName);
                  const shouldCheck = entry && entry.enabled;
                  
                  if (checkbox.checked !== shouldCheck) {
                    checkbox.checked = shouldCheck;
                    // è§¦å‘changeäº‹ä»¶ä»¥æ›´æ–°selectedEntries
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                  }
                });
              });
            }

            // ä¿å­˜æŒ‰é’® - ä¼˜åŒ–ï¼šä¿å­˜åè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const saveBtn = document.getElementById('save-preset');
            if (saveBtn) {
              saveBtn.addEventListener('click', () => {
                this.savePreset();
              });
            }

            // å–æ¶ˆæŒ‰é’® - ä¼˜åŒ–ï¼šè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const cancelBtn = document.getElementById('cancel-preset-edit');
            if (cancelBtn) {
              cancelBtn.addEventListener('click', () => {
                this.closeModal('preset-edit-modal');
                this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
              });
            }

            // å…³é—­æŒ‰é’® - ä¼˜åŒ–ï¼šè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const closeBtn = document.getElementById('close-preset-edit');
            if (closeBtn) {
              closeBtn.addEventListener('click', () => {
                this.closeModal('preset-edit-modal');
                this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
              });
            }

            // æ¨¡æ€æ¡†èƒŒæ™¯ç‚¹å‡»å…³é—­ - ä¼˜åŒ–ï¼šè¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
            const modal = document.getElementById('preset-edit-modal');
            if (modal) {
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  this.closeModal('preset-edit-modal');
                  this.showWorldbookPresets(); // è¿”å›é¢„è®¾ç®¡ç†ç•Œé¢
                }
              });
            }
          },

          // æ¸…ç†é¢„è®¾ç¼–è¾‘äº‹ä»¶ç›‘å¬å™¨
          cleanupPresetEditEvents() {
            const elements = [
              'preset-filter-type',
              'preset-prefix-filter',
              'select-all-entries',
              'deselect-all-entries',
              'select-enabled-entries',
              'save-preset',
              'cancel-preset-edit',
              'close-preset-edit',
              'preset-edit-modal'
            ];

            elements.forEach(id => {
              const element = document.getElementById(id);
              if (element) {
                // é€šè¿‡å…‹éš†èŠ‚ç‚¹æ¥ç§»é™¤æ‰€æœ‰äº‹ä»¶ç›‘å¬å™¨
                const newElement = element.cloneNode(true);
                element.parentNode.replaceChild(newElement, element);
              }
            });
          },


          // --- æ–°å¢ï¼šèƒŒæ™¯å›¾è®¾ç½®åŠŸèƒ½ ---
          showBackgroundSettings() {
            this.openModal('background-settings-modal');
            this.renderBackgroundList();
            this.updateBackgroundModeUI();
            
            // ç¡®ä¿åœ¨æ¨¡æ€æ¡†æ‰“å¼€åç»‘å®šäº‹ä»¶
            setTimeout(() => {
              this.bindBackgroundListEvents();
            }, 100);
          },

          updateBackgroundModeUI() {
            const randomRadio = document.getElementById('bg-mode-random');
            const fixedRadio = document.getElementById('bg-mode-fixed');
            if (randomRadio && fixedRadio) {
              randomRadio.checked = this.backgroundMode === 'random';
              fixedRadio.checked = this.backgroundMode === 'fixed';
            }
          },

          renderBackgroundList() {
            const listContainer = document.getElementById('background-list');
            const countSpan = document.getElementById('background-count');
            if (!listContainer || !countSpan) return;

            countSpan.textContent = `(${this.backgroundImages.length}å¼ )`;
            listContainer.innerHTML = '';

            if (this.backgroundImages.length === 0) {
              listContainer.innerHTML = '<div style="grid-column: 1 / -1; text-align: center; color: #8b7355; padding: 20px;">æš‚æ— èƒŒæ™¯å›¾</div>';
              return;
            }

            this.backgroundImages.forEach(bg => {
              const item = document.createElement('div');
              item.className = 'background-item';
              item.dataset.bgId = bg.id;
              
              // å¦‚æœæ˜¯å›ºå®šæ¨¡å¼ä¸‹çš„é€‰ä¸­èƒŒæ™¯ï¼Œæ·»åŠ é€‰ä¸­æ ·å¼
              if (this.backgroundMode === 'fixed' && this.selectedBackgroundId === bg.id) {
                item.classList.add('selected');
              }

              // ä¸ºå¤–é“¾å›¾ç‰‡æ·»åŠ ç‰¹æ®Šæ ‡è¯†
              const linkIcon = bg.isUrlImage ? '<div style="position: absolute; top: 5px; left: 5px; background: rgba(0,0,0,0.7); color: #fff; padding: 2px 6px; border-radius: 3px; font-size: 10px;">ğŸ”—</div>' : '';
              
              item.innerHTML = `
                <img src="${bg.dataUrl}" alt="${bg.name}" style="width: 100%; height: 100%; object-fit: cover;">
                ${linkIcon}
                <div class="background-item-overlay">
                  <div class="background-item-actions">
                    <button class="background-item-btn preview-btn" data-bg-id="${bg.id}">é¢„è§ˆ</button>
                    <button class="background-item-btn select-btn" data-bg-id="${bg.id}">é€‰æ‹©</button>
                    <button class="background-item-btn delete" data-bg-id="${bg.id}">åˆ é™¤</button>
                  </div>
                </div>
              `;

              // å¦‚æœæ˜¯å½“å‰é¢„è§ˆçš„èƒŒæ™¯ï¼Œæ˜¾ç¤ºæŒ‡ç¤ºå™¨
              if (this.backgroundMode === 'fixed' && this.selectedBackgroundId === bg.id) {
                const indicator = document.createElement('div');
                indicator.className = 'background-preview-indicator';
                indicator.textContent = 'å½“å‰';
                item.appendChild(indicator);
              }

              listContainer.appendChild(item);
            });

            // ç»‘å®šäº‹ä»¶
            this.bindBackgroundListEvents();
          },

          bindBackgroundListEvents() {
            const listContainer = document.getElementById('background-list');
            if (!listContainer) return;

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            if (this.backgroundListClickHandler) {
              listContainer.removeEventListener('click', this.backgroundListClickHandler);
            }

            // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å™¨å¹¶ä¿å­˜å¼•ç”¨
            this.backgroundListClickHandler = (e) => {
              const bgId = e.target.dataset.bgId;
              if (!bgId) return;

              if (e.target.classList.contains('preview-btn')) {
                this.previewBackground(bgId);
              } else if (e.target.classList.contains('select-btn')) {
                this.selectBackground(bgId);
              } else if (e.target.classList.contains('delete')) {
                this.deleteBackground(bgId);
              }
            };

            // ç»‘å®šæ–°çš„äº‹ä»¶ç›‘å¬å™¨
            listContainer.addEventListener('click', this.backgroundListClickHandler);
          },

          // æ–°å¢ï¼šå°†èƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†å†…çš„é™æ€äº‹ä»¶ç»‘å®šåˆ†ç¦»å‡ºæ¥
          bindBackgroundSettingsListeners() {
              if (this.backgroundEventsInitialized) return; // ç¡®ä¿åªç»‘å®šä¸€æ¬¡

              // ç»‘å®šä¸Šä¼ åŒºåŸŸäº‹ä»¶
              const uploadArea = document.getElementById('background-upload-area');
              const fileInput = document.getElementById('background-file-input');
              if (uploadArea && fileInput) {
                  uploadArea.addEventListener('click', () => fileInput.click());
                  fileInput.addEventListener('change', (e) => this.handleBackgroundUpload(e));
              }

              // ç»‘å®šæ¨¡å¼åˆ‡æ¢äº‹ä»¶
              const randomRadio = document.getElementById('bg-mode-random');
              const fixedRadio = document.getElementById('bg-mode-fixed');
              if (randomRadio && fixedRadio) {
                  randomRadio.addEventListener('change', () => {
                      if (randomRadio.checked) {
                          this.backgroundMode = 'random';
                          this.saveBackgroundSettings();
                          this.renderBackgroundList();
                      }
                  });
                  fixedRadio.addEventListener('change', () => {
                      if (fixedRadio.checked) {
                          this.backgroundMode = 'fixed';
                          this.saveBackgroundSettings();
                          this.renderBackgroundList();
                      }
                  });
              }

              // ç»‘å®šå¤–é“¾å›¾åºŠæŒ‰é’®äº‹ä»¶
              const addUrlBtn = document.getElementById('add-url-image-btn');
              if (addUrlBtn) {
                  addUrlBtn.addEventListener('click', () => this.handleUrlImageAdd());
              }

              // ç»‘å®šç®¡ç†å¤–é“¾æŒ‰é’®äº‹ä»¶
              const manageUrlBtn = document.getElementById('manage-url-images-btn');
              if (manageUrlBtn) {
                  manageUrlBtn.addEventListener('click', () => this.showUrlImagesManageModal());
              }

              // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
              this.backgroundEventsInitialized = true;
          },

          async handleBackgroundUpload(event) {
            const files = event.target.files;
            if (!files || files.length === 0) {
              console.warn('[å½’å¢ŸèƒŒæ™¯] æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
              return;
            }

            console.log(`[å½’å¢ŸèƒŒæ™¯] å¼€å§‹å¤„ç† ${files.length} ä¸ªæ–‡ä»¶`);
            this.showTemporaryMessage('æ­£åœ¨å¤„ç†å›¾ç‰‡...', 3000);

            for (let i = 0; i < files.length; i++) {
              const file = files[i];
              console.log(`[å½’å¢ŸèƒŒæ™¯] å¤„ç†æ–‡ä»¶: ${file.name}, å¤§å°: ${file.size} bytes, ç±»å‹: ${file.type}`);
              
              // æ£€æŸ¥æ–‡ä»¶ç±»å‹
              if (!file.type.startsWith('image/')) {
                console.error(`[å½’å¢ŸèƒŒæ™¯] æ–‡ä»¶ç±»å‹æ— æ•ˆ: ${file.type}`);
                this.showTemporaryMessage(`æ–‡ä»¶ ${file.name} ä¸æ˜¯æœ‰æ•ˆçš„å›¾ç‰‡æ ¼å¼`);
                continue;
              }

              try {
                let processedDataUrl;
                let compressionApplied = false;

                // æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼Œå¦‚æœè¶…è¿‡2MBåˆ™å°è¯•å‹ç¼©
                if (file.size > 2 * 1024 * 1024) {
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æ–‡ä»¶è¿‡å¤§ (${file.size} bytes)ï¼Œå°è¯•å‹ç¼©...`);
                  try {
                    processedDataUrl = await this.compressImage(file, 0.8, 1920, 1080);
                    compressionApplied = true;
                    console.log(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©æˆåŠŸ`);
                  } catch (compressionError) {
                    console.error(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©å¤±è´¥:`, compressionError);
                    // å¦‚æœå‹ç¼©å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨Object URLæ–¹å¼
                    try {
                      processedDataUrl = await this.createObjectUrlForLargeImage(file);
                      console.log(`[å½’å¢ŸèƒŒæ™¯] ä½¿ç”¨Object URLå¤„ç†å¤§å›¾ç‰‡`);
                    } catch (objectUrlError) {
                      console.error(`[å½’å¢ŸèƒŒæ™¯] Object URLåˆ›å»ºå¤±è´¥:`, objectUrlError);
                      this.showTemporaryMessage(`æ–‡ä»¶ ${file.name} è¿‡å¤§ä¸”å¤„ç†å¤±è´¥ï¼Œè¯·é€‰æ‹©å°äº2MBçš„å›¾ç‰‡`);
                      continue;
                    }
                  }
                } else {
                  // æ–‡ä»¶å¤§å°åˆé€‚ï¼Œç›´æ¥è½¬æ¢
                  processedDataUrl = await this.fileToDataUrl(file);
                  console.log(`[å½’å¢ŸèƒŒæ™¯] ç›´æ¥è½¬æ¢ä¸ºDataURLæˆåŠŸ`);
                }

                const bgId = 'bg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                const newBackground = {
                  id: bgId,
                  name: file.name.replace(/\.[^/.]+$/, ""), // ç§»é™¤æ–‡ä»¶æ‰©å±•å
                  dataUrl: processedDataUrl,
                  uploadTime: new Date().toISOString(),
                  isPreset: false,
                  compressed: compressionApplied,
                  originalSize: file.size
                };

                // ä¸´æ—¶æ·»åŠ åˆ°æ•°ç»„ä¸­æµ‹è¯•å­˜å‚¨
                const tempImages = [...this.backgroundImages, newBackground];
                const testSettings = {
                  images: tempImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };

                // æµ‹è¯•æ˜¯å¦èƒ½å¤ŸæˆåŠŸä¿å­˜åˆ°localStorage
                try {
                  const testData = JSON.stringify(testSettings);
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æµ‹è¯•æ•°æ®å¤§å°: ${testData.length} å­—ç¬¦`);
                  
                  // æ£€æŸ¥æ•°æ®å¤§å°ï¼ˆlocalStorageé€šå¸¸é™åˆ¶ä¸º5-10MBï¼‰
                  if (testData.length > 4 * 1024 * 1024) { // 4MBé™åˆ¶
                    throw new Error('å­˜å‚¨ç©ºé—´ä¸è¶³');
                  }
                  
                  // å°è¯•ä¿å­˜æµ‹è¯•æ•°æ®
                  localStorage.setItem('guixu_background_test', testData);
                  localStorage.removeItem('guixu_background_test');
                  
                  // å¦‚æœæµ‹è¯•æˆåŠŸï¼Œæ­£å¼æ·»åŠ å›¾ç‰‡
                  this.backgroundImages.push(newBackground);
                  this.saveBackgroundSettings();
                  
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æˆåŠŸä¿å­˜å›¾ç‰‡: ${file.name}, å½“å‰å›¾ç‰‡æ•°é‡: ${this.backgroundImages.length}`);
                  
                  // æ˜¾ç¤ºæˆåŠŸæ¶ˆæ¯ï¼ŒåŒ…å«å‹ç¼©ä¿¡æ¯
                  if (compressionApplied) {
                    this.showTemporaryMessage(`å›¾ç‰‡ ${file.name} å·²å‹ç¼©å¹¶ä¿å­˜æˆåŠŸ`);
                  } else {
                    this.showTemporaryMessage(`å›¾ç‰‡ ${file.name} ä¿å­˜æˆåŠŸ`);
                  }
                  
                } catch (storageError) {
                  console.error('[å½’å¢ŸèƒŒæ™¯] localStorageå­˜å‚¨å¤±è´¥:', storageError);
                  this.showTemporaryMessage(`å›¾ç‰‡ ${file.name} ä¿å­˜å¤±è´¥ï¼šå­˜å‚¨ç©ºé—´ä¸è¶³æˆ–å›¾ç‰‡è¿‡å¤§`);
                  continue;
                }
                
                // å¦‚æœèƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†æ˜¯æ‰“å¼€çš„ï¼Œåˆ·æ–°åˆ—è¡¨
                if (document.getElementById('background-settings-modal').style.display === 'flex') {
                  this.renderBackgroundList();
                }
                
              } catch (error) {
                console.error('[å½’å¢ŸèƒŒæ™¯] å¤„ç†å›¾ç‰‡å¤±è´¥:', error);
                this.showTemporaryMessage(`å¤„ç†å›¾ç‰‡ ${file.name} å¤±è´¥: ${error.message}`);
              }
            }

            // æ¸…ç©ºæ–‡ä»¶è¾“å…¥
            event.target.value = '';
            this.showTemporaryMessage('å›¾ç‰‡å¤„ç†å®Œæˆï¼');
          },

          fileToDataUrl(file) {
            return new Promise((resolve, reject) => {
              const reader = new FileReader();
              reader.onload = (e) => {
                console.log(`[å½’å¢ŸèƒŒæ™¯] FileReaderæˆåŠŸè¯»å–æ–‡ä»¶ï¼ŒDataURLé•¿åº¦: ${e.target.result.length}`);
                resolve(e.target.result);
              };
              reader.onerror = (error) => {
                console.error(`[å½’å¢ŸèƒŒæ™¯] FileReaderè¯»å–å¤±è´¥:`, error);
                reject(error);
              };
              reader.readAsDataURL(file);
            });
          },

          // æ–°å¢ï¼šå›¾ç‰‡å‹ç¼©å‡½æ•°
          compressImage(file, quality = 0.8, maxWidth = 1920, maxHeight = 1080) {
            return new Promise((resolve, reject) => {
              const canvas = document.createElement('canvas');
              const ctx = canvas.getContext('2d');
              const img = new Image();

              img.onload = () => {
                try {
                  // è®¡ç®—å‹ç¼©åçš„å°ºå¯¸
                  let { width, height } = img;
                  
                  if (width > maxWidth || height > maxHeight) {
                    const ratio = Math.min(maxWidth / width, maxHeight / height);
                    width *= ratio;
                    height *= ratio;
                  }

                  canvas.width = width;
                  canvas.height = height;

                  // ç»˜åˆ¶å‹ç¼©åçš„å›¾ç‰‡
                  ctx.drawImage(img, 0, 0, width, height);

                  // è½¬æ¢ä¸ºDataURL
                  const compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                  
                  console.log(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©å®Œæˆ: ${img.naturalWidth}x${img.naturalHeight} -> ${width}x${height}, è´¨é‡: ${quality}`);
                  resolve(compressedDataUrl);
                } catch (error) {
                  console.error(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡å‹ç¼©è¿‡ç¨‹ä¸­å‡ºé”™:`, error);
                  reject(error);
                }
              };

              img.onerror = (error) => {
                console.error(`[å½’å¢ŸèƒŒæ™¯] å›¾ç‰‡åŠ è½½å¤±è´¥:`, error);
                reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
              };

              // åˆ›å»ºå›¾ç‰‡URL
              const url = URL.createObjectURL(file);
              img.src = url;
              
              // æ¸…ç†URL - ä¿®æ­£onloadå¤„ç†
              const originalOnload = img.onload;
              img.onload = () => {
                URL.revokeObjectURL(url);
                originalOnload();
              };
            });
          },

          // æ–°å¢ï¼šä¸ºå¤§å›¾ç‰‡åˆ›å»ºObject URLçš„å¤„ç†æ–¹å¼
          createObjectUrlForLargeImage(file) {
            return new Promise((resolve, reject) => {
              try {
                // åˆ›å»ºObject URL
                const objectUrl = URL.createObjectURL(file);
                
                // éªŒè¯URLæ˜¯å¦æœ‰æ•ˆ
                const img = new Image();
                img.onload = () => {
                  console.log(`[å½’å¢ŸèƒŒæ™¯] Object URLåˆ›å»ºæˆåŠŸ: ${objectUrl}`);
                  resolve(objectUrl);
                };
                img.onerror = () => {
                  URL.revokeObjectURL(objectUrl);
                  reject(new Error('Object URLéªŒè¯å¤±è´¥'));
                };
                img.src = objectUrl;
              } catch (error) {
                console.error(`[å½’å¢ŸèƒŒæ™¯] Object URLåˆ›å»ºå¤±è´¥:`, error);
                reject(error);
              }
            });
          },


                     async storeAvatarInDB(record) {
                         try {
                             const db = await this.initDB();
                             const transaction = db.transaction(['character_avatars'], 'readwrite');
                             const store = transaction.objectStore('character_avatars');
          
                             const getRequest = store.get(record.characterName);
          
                             getRequest.onsuccess = () => {
                                 const existingRecord = getRequest.result || {};
                                 
                                 const finalRecord = {
                                     characterName: record.characterName,
                                     avatarImage: record.avatarImage !== undefined ? record.avatarImage : existingRecord.avatarImage,
                                     backgroundImage: record.backgroundImage !== undefined ? record.backgroundImage : existingRecord.backgroundImage,
                                     backgroundOpacity: record.backgroundOpacity !== undefined ? record.backgroundOpacity : existingRecord.backgroundOpacity || 0.5,
                                     timestamp: Date.now()
                                 };
          
                                 const putRequest = store.put(finalRecord);
                                 putRequest.onerror = () => {
                                     console.error('Failed to store avatar in DB:', putRequest.error);
                                 };
                             };
                             getRequest.onerror = () => {
                                  console.error('Failed to get existing avatar record for update:', getRequest.error);
                             };
          
                         } catch (error) {
                             console.error('Failed to open DB for storing avatar:', error);
                         }
                     },
          
                     async getAvatarFromDB(characterName) {
                         try {
                             const db = await this.initDB();
                             const transaction = db.transaction(['character_avatars'], 'readonly');
                             const store = transaction.objectStore('character_avatars');
                             const getRequest = store.get(characterName);
                             return new Promise((resolve, reject) => {
                                 getRequest.onsuccess = () => resolve(getRequest.result);
                                 getRequest.onerror = () => reject(getRequest.error);
                             });
                         } catch (error) {
                             console.error('Failed to get avatar from DB:', error);
                             return null; // å‡ºé”™æ—¶è¿”å›nullä»¥é˜²æ­¢è°ƒç”¨è€…å´©æºƒ
                         }
                     },

          previewBackground(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            // åˆ›å»ºé¢„è§ˆæ¨¡æ€æ¡†
            this.showImagePreviewModal(bg);
          },

          showImagePreviewModal(bg) {
            // åˆ›å»ºé¢„è§ˆæ¨¡æ€æ¡†
            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.style.display = 'flex';
            modal.style.zIndex = '2001'; // ç¡®ä¿åœ¨èƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†ä¹‹ä¸Š
            modal.innerHTML = `
              <div class="modal-content" style="width: 90vw; height: 90vh; max-width: none; max-height: none; padding: 0; background: rgba(0,0,0,0.9); display: flex; flex-direction: column;">
                <div class="modal-header" style="padding: 15px; background: rgba(26, 26, 46, 0.95); flex-shrink: 0;">
                  <h2 class="modal-title">é¢„è§ˆï¼š${bg.name}</h2>
                  <button class="modal-close-btn" id="preview-close-btn">&times;</button>
                </div>
                <div class="modal-body" style="flex: 1; display: flex; align-items: center; justify-content: center; padding: 10px; overflow: hidden; min-height: 0;">
                  <img src="${bg.dataUrl}" alt="${bg.name}" style="max-width: calc(100% - 20px); max-height: calc(100% - 20px); object-fit: contain; border-radius: 4px; box-shadow: 0 4px 20px rgba(0,0,0,0.5);">
                </div>
              </div>
            `;

            const container = document.querySelector('.guixu-root-container');
            if (container) {
              container.appendChild(modal);

              // ç»‘å®šå…³é—­äº‹ä»¶
              const closeBtn = modal.querySelector('#preview-close-btn');
              const closeModal = () => {
                modal.remove();
              };

              if (closeBtn) {
                closeBtn.addEventListener('click', closeModal);
              }

              // ç‚¹å‡»èƒŒæ™¯å…³é—­
              modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                  closeModal();
                }
              });

              // ESCé”®å…³é—­
              const handleKeydown = (e) => {
                if (e.key === 'Escape') {
                  closeModal();
                  document.removeEventListener('keydown', handleKeydown);
                }
              };
              document.addEventListener('keydown', handleKeydown);

              this.showTemporaryMessage(`æ­£åœ¨é¢„è§ˆï¼š${bg.name}`);
            }
          },

          selectBackground(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.selectedBackgroundId = bgId;
            this.backgroundMode = 'fixed'; // é€‰æ‹©èƒŒæ™¯æ—¶è‡ªåŠ¨åˆ‡æ¢åˆ°å›ºå®šæ¨¡å¼
            this.saveBackgroundSettings();
            this.updateBackgroundModeUI();
            this.renderBackgroundList();
            this.applyRandomBackground(); // åº”ç”¨é€‰ä¸­çš„èƒŒæ™¯
            this.showTemporaryMessage(`å·²é€‰æ‹©èƒŒæ™¯ï¼š${bg.name}`);
          },

          deleteBackground(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤èƒŒæ™¯å›¾"${bg.name}"å—ï¼Ÿ`, () => {
              this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId);
              
              // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„èƒŒæ™¯ï¼Œæ¸…é™¤é€‰æ‹©
              if (this.selectedBackgroundId === bgId) {
                this.selectedBackgroundId = null;
              }
              
              this.saveBackgroundSettings();
              this.renderBackgroundList();
              this.applyRandomBackground(); // é‡æ–°åº”ç”¨èƒŒæ™¯
              this.showTemporaryMessage(`å·²åˆ é™¤èƒŒæ™¯å›¾ï¼š${bg.name}`);
            }, null, true); // keepCurrentModal = true
          },

          saveBackgroundSettings() {
            try {
              const settings = {
                images: this.backgroundImages,
                mode: this.backgroundMode,
                selectedId: this.selectedBackgroundId
              };
              localStorage.setItem('guixu_background_settings', JSON.stringify(settings));
            } catch (e) {
              console.error('ä¿å­˜èƒŒæ™¯å›¾è®¾ç½®å¤±è´¥:', e);
            }
          },

          loadBackgroundSettings() {
            try {
              const saved = localStorage.getItem('guixu_background_settings');
              if (saved) {
                const settings = JSON.parse(saved);
                this.backgroundImages = settings.images || [];
                this.backgroundMode = settings.mode || 'random';
                this.selectedBackgroundId = settings.selectedId || null;
              }
            } catch (e) {
              console.error('åŠ è½½èƒŒæ™¯å›¾è®¾ç½®å¤±è´¥:', e);
              this.backgroundImages = [];
              this.backgroundMode = 'random';
              this.selectedBackgroundId = null;
            }
          },

          // --- æ–°å¢ï¼šå¤„ç†å¤–é“¾å›¾åºŠæ·»åŠ  ---
          async handleUrlImageAdd() {
            const urlInput = document.getElementById('image-url-input');
            
            if (!urlInput) {
              this.showTemporaryMessage('æ‰¾ä¸åˆ°URLè¾“å…¥æ¡†');
              return;
            }
            
            const inputText = urlInput.value.trim();
            const baseName = ''; // ä½¿ç”¨ç©ºå­—ç¬¦ä¸²ï¼Œè®©ç³»ç»Ÿè‡ªåŠ¨ç”Ÿæˆåç§°
            
            // éªŒè¯è¾“å…¥
            if (!inputText) {
              this.showTemporaryMessage('è¯·è¾“å…¥å›¾ç‰‡é“¾æ¥');
              return;
            }
            
            // åˆ†å‰²å¤šè¡Œè¾“å…¥ï¼Œæ”¯æŒå¤šä¸ªé“¾æ¥
            const imageUrls = inputText.split('\n')
              .map(url => url.trim())
              .filter(url => url.length > 0);
            
            if (imageUrls.length === 0) {
              this.showTemporaryMessage('è¯·è¾“å…¥æœ‰æ•ˆçš„å›¾ç‰‡é“¾æ¥');
              return;
            }
            
            // éªŒè¯æ‰€æœ‰é“¾æ¥æ ¼å¼
            const invalidUrls = imageUrls.filter(url => !this.isValidImageUrl(url));
            if (invalidUrls.length > 0) {
              this.showTemporaryMessage(`ä»¥ä¸‹é“¾æ¥æ ¼å¼æ— æ•ˆï¼ˆéœ€è¦ä»¥ https:// å¼€å¤´ï¼‰ï¼š\n${invalidUrls.slice(0, 3).join('\n')}${invalidUrls.length > 3 ? '\n...' : ''}`);
              return;
            }
            
            // æ£€æŸ¥é‡å¤é“¾æ¥
            const existingUrls = imageUrls.filter(url =>
              this.backgroundImages.some(bg => bg.dataUrl === url)
            );
            if (existingUrls.length > 0) {
              this.showTemporaryMessage(`ä»¥ä¸‹é“¾æ¥å·²å­˜åœ¨ï¼š\n${existingUrls.slice(0, 3).join('\n')}${existingUrls.length > 3 ? '\n...' : ''}`);
              return;
            }
            
            this.showTemporaryMessage(`æ­£åœ¨éªŒè¯ ${imageUrls.length} ä¸ªå›¾ç‰‡é“¾æ¥...`, 5000);
            
            let successCount = 0;
            let failedUrls = [];
            
            // æ‰¹é‡å¤„ç†å›¾ç‰‡é“¾æ¥
            for (let i = 0; i < imageUrls.length; i++) {
              const imageUrl = imageUrls[i];
              
              try {
                // éªŒè¯å›¾ç‰‡é“¾æ¥æ˜¯å¦æœ‰æ•ˆ
                const isValid = await this.validateImageUrl(imageUrl);
                if (!isValid) {
                  failedUrls.push(imageUrl);
                  continue;
                }
                
                // ç”Ÿæˆå›¾ç‰‡åç§°
                let finalName;
                if (baseName) {
                  finalName = imageUrls.length > 1 ? `${baseName}_${i + 1}` : baseName;
                } else {
                  finalName = this.extractNameFromUrl(imageUrl);
                }
                
                // åˆ›å»ºæ–°çš„èƒŒæ™¯å›¾å¯¹è±¡
                const bgId = 'url_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                const newBackground = {
                  id: bgId,
                  name: finalName,
                  dataUrl: imageUrl,
                  uploadTime: new Date().toISOString(),
                  isPreset: false,
                  isUrlImage: true, // æ ‡è®°ä¸ºå¤–é“¾å›¾ç‰‡
                  originalUrl: imageUrl
                };
                
                // æµ‹è¯•å­˜å‚¨ç©ºé—´
                const tempImages = [...this.backgroundImages, newBackground];
                const testSettings = {
                  images: tempImages,
                  mode: this.backgroundMode,
                  selectedId: this.selectedBackgroundId
                };
                
                try {
                  const testData = JSON.stringify(testSettings);
                  if (testData.length > 4 * 1024 * 1024) {
                    throw new Error('å­˜å‚¨ç©ºé—´ä¸è¶³');
                  }
                  
                  localStorage.setItem('guixu_background_test', testData);
                  localStorage.removeItem('guixu_background_test');
                  
                  // ä¿å­˜æˆåŠŸ
                  this.backgroundImages.push(newBackground);
                  successCount++;
                  
                  console.log(`[å½’å¢ŸèƒŒæ™¯] æˆåŠŸæ·»åŠ å¤–é“¾å›¾ç‰‡: ${finalName}, URL: ${imageUrl}`);
                  
                } catch (storageError) {
                  console.error('[å½’å¢ŸèƒŒæ™¯] å­˜å‚¨å¤–é“¾å›¾ç‰‡å¤±è´¥:', storageError);
                  failedUrls.push(imageUrl);
                }
                
              } catch (error) {
                console.error('[å½’å¢ŸèƒŒæ™¯] éªŒè¯å¤–é“¾å›¾ç‰‡å¤±è´¥:', error);
                failedUrls.push(imageUrl);
              }
            }
            
            // ä¿å­˜è®¾ç½®
            if (successCount > 0) {
              this.saveBackgroundSettings();
              
              // æ¸…ç©ºè¾“å…¥æ¡†
              urlInput.value = '';
              
              // åˆ·æ–°åˆ—è¡¨
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
            }
            
            // æ˜¾ç¤ºç»“æœæ¶ˆæ¯
            if (successCount === imageUrls.length) {
              this.showTemporaryMessage(`æˆåŠŸæ·»åŠ  ${successCount} å¼ å¤–é“¾å›¾ç‰‡ï¼`);
            } else if (successCount > 0) {
              this.showTemporaryMessage(`æˆåŠŸæ·»åŠ  ${successCount} å¼ å›¾ç‰‡ï¼Œ${failedUrls.length} å¼ å¤±è´¥`);
            } else {
              this.showTemporaryMessage('æ‰€æœ‰å›¾ç‰‡é“¾æ¥éƒ½æ·»åŠ å¤±è´¥ï¼Œè¯·æ£€æŸ¥é“¾æ¥æ˜¯å¦æ­£ç¡®');
            }
          },

          // --- æ–°å¢ï¼šéªŒè¯å›¾ç‰‡URLæ ¼å¼ ---
          isValidImageUrl(url) {
            try {
              const urlObj = new URL(url);
              // å¿…é¡»æ˜¯ https åè®®
              if (urlObj.protocol !== 'https:') {
                return false;
              }
              // æ£€æŸ¥æ˜¯å¦æ˜¯å¸¸è§çš„å›¾ç‰‡æ‰©å±•åæˆ–å›¾åºŠåŸŸå
              const pathname = urlObj.pathname.toLowerCase();
              const hostname = urlObj.hostname.toLowerCase();
              
              // å¸¸è§å›¾ç‰‡æ‰©å±•å
              const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp'];
              const hasImageExtension = imageExtensions.some(ext => pathname.endsWith(ext));
              
              // å¸¸è§å›¾åºŠåŸŸå
              const imagehostDomains = [
                'imgur.com', 'i.imgur.com',
                'postimg.cc', 'i.postimg.cc',
                'sm.ms', 'i.loli.net',
                'github.com', 'raw.githubusercontent.com',
                'cdn.jsdelivr.net', 'unpkg.com'
              ];
              const isImagehostDomain = imagehostDomains.some(domain =>
                hostname === domain || hostname.endsWith('.' + domain)
              );
              
              return hasImageExtension || isImagehostDomain;
            } catch (e) {
              return false;
            }
          },

          // --- æ–°å¢ï¼šéªŒè¯å›¾ç‰‡é“¾æ¥æ˜¯å¦å¯è®¿é—® ---
          validateImageUrl(url) {
            return new Promise((resolve) => {
              const img = new Image();
              const timeout = setTimeout(() => {
                resolve(false);
              }, 10000); // 10ç§’è¶…æ—¶
              
              img.onload = () => {
                clearTimeout(timeout);
                resolve(true);
              };
              
              img.onerror = () => {
                clearTimeout(timeout);
                resolve(false);
              };
              
              // è®¾ç½®è·¨åŸŸå±æ€§ä»¥é¿å…CORSé—®é¢˜
              img.crossOrigin = 'anonymous';
              img.src = url;
            });
          },

          // --- æ–°å¢ï¼šä»URLæå–æ–‡ä»¶å ---
          extractNameFromUrl(url) {
            try {
              const urlObj = new URL(url);
              const pathname = urlObj.pathname;
              const filename = pathname.split('/').pop();
              
              if (filename && filename.includes('.')) {
                // ç§»é™¤æ‰©å±•å
                return filename.replace(/\.[^/.]+$/, '') || 'å¤–é“¾å›¾ç‰‡';
              }
              
              // å¦‚æœæ— æ³•æå–æ–‡ä»¶åï¼Œä½¿ç”¨åŸŸå
              return urlObj.hostname.replace('www.', '') || 'å¤–é“¾å›¾ç‰‡';
            } catch (e) {
              return 'å¤–é“¾å›¾ç‰‡';
            }
          },

          // --- æ–°å¢ï¼šæ˜¾ç¤ºå›¾åºŠé“¾æ¥ç®¡ç†æ¨¡æ€æ¡† ---
          showUrlImagesManageModal() {
            this.openModal('url-images-manage-modal');
            this.renderUrlImagesList();
          },

          // --- æ–°å¢ï¼šæ¸²æŸ“å¤–é“¾å›¾ç‰‡åˆ—è¡¨ ---
          renderUrlImagesList() {
            const listContainer = document.getElementById('url-images-list');
            const countSpan = document.getElementById('url-images-count');
            if (!listContainer || !countSpan) return;

            // ç­›é€‰å‡ºå¤–é“¾å›¾ç‰‡
            const urlImages = this.backgroundImages.filter(bg => bg.isUrlImage);
            countSpan.textContent = `(${urlImages.length}å¼ )`;

            if (urlImages.length === 0) {
              listContainer.innerHTML = '<div style="text-align: center; color: #8b7355; padding: 40px 20px;">æš‚æ— å¤–é“¾å›¾ç‰‡</div>';
              return;
            }

            listContainer.innerHTML = '';

            urlImages.forEach(bg => {
              const item = document.createElement('div');
              item.className = 'url-image-item';
              item.style.cssText = `
                display: flex; align-items: center; padding: 12px; margin-bottom: 8px;
                background: rgba(26, 26, 46, 0.6); border: 1px solid rgba(201, 170, 113, 0.2);
                border-radius: 6px; transition: all 0.2s ease;
              `;

              item.innerHTML = `
                <div style="flex-shrink: 0; width: 60px; height: 60px; margin-right: 12px; border-radius: 4px; overflow: hidden; background: rgba(0,0,0,0.3);">
                  <img src="${bg.dataUrl}" alt="${bg.name}" style="width: 100%; height: 100%; object-fit: cover;">
                </div>
                <div style="flex: 1; min-width: 0;">
                  <div style="color: #e0dcd1; font-size: 14px; font-weight: 500; margin-bottom: 4px; word-break: break-all;">
                    ${bg.name}
                  </div>
                  <div style="color: #8b7355; font-size: 11px; word-break: break-all; line-height: 1.3;">
                    ${bg.originalUrl}
                  </div>
                  <div style="color: #8b7355; font-size: 10px; margin-top: 2px;">
                    æ·»åŠ æ—¶é—´: ${new Date(bg.uploadTime).toLocaleString('zh-CN')}
                  </div>
                </div>
                <div style="flex-shrink: 0; display: flex; gap: 6px; margin-left: 12px;">
                  <button class="url-image-btn edit-name-btn" data-bg-id="${bg.id}" 
                          style="padding: 4px 8px; font-size: 11px; background: rgba(201, 170, 113, 0.2); 
                                 border: 1px solid rgba(201, 170, 113, 0.3); border-radius: 3px; 
                                 color: #c9aa71; cursor: pointer; transition: all 0.2s ease;">
                    é‡å‘½å
                  </button>
                  <button class="url-image-btn preview-btn" data-bg-id="${bg.id}"
                          style="padding: 4px 8px; font-size: 11px; background: rgba(76, 175, 80, 0.2); 
                                 border: 1px solid rgba(76, 175, 80, 0.3); border-radius: 3px; 
                                 color: #4caf50; cursor: pointer; transition: all 0.2s ease;">
                    é¢„è§ˆ
                  </button>
                  <button class="url-image-btn delete-btn" data-bg-id="${bg.id}"
                          style="padding: 4px 8px; font-size: 11px; background: rgba(244, 67, 54, 0.2); 
                                 border: 1px solid rgba(244, 67, 54, 0.3); border-radius: 3px; 
                                 color: #f44336; cursor: pointer; transition: all 0.2s ease;">
                    åˆ é™¤
                  </button>
                </div>
              `;

              // æ·»åŠ æ‚¬åœæ•ˆæœ
              item.addEventListener('mouseenter', () => {
                item.style.background = 'rgba(26, 26, 46, 0.8)';
                item.style.borderColor = 'rgba(201, 170, 113, 0.4)';
              });

              item.addEventListener('mouseleave', () => {
                item.style.background = 'rgba(26, 26, 46, 0.6)';
                item.style.borderColor = 'rgba(201, 170, 113, 0.2)';
              });

              listContainer.appendChild(item);
            });

            // ç»‘å®šæŒ‰é’®äº‹ä»¶
            this.bindUrlImageListEvents();
          },

          // --- æ–°å¢ï¼šç»‘å®šå¤–é“¾å›¾ç‰‡åˆ—è¡¨äº‹ä»¶ ---
          bindUrlImageListEvents() {
            const listContainer = document.getElementById('url-images-list');
            if (!listContainer) return;

            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            if (this.urlImageListClickHandler) {
              listContainer.removeEventListener('click', this.urlImageListClickHandler);
            }

            // åˆ›å»ºæ–°çš„äº‹ä»¶å¤„ç†å™¨
            this.urlImageListClickHandler = (e) => {
              const bgId = e.target.dataset.bgId;
              if (!bgId) return;

              if (e.target.classList.contains('edit-name-btn')) {
                this.showEditImageNameModal(bgId);
              } else if (e.target.classList.contains('preview-btn')) {
                this.previewBackground(bgId);
              } else if (e.target.classList.contains('delete-btn')) {
                this.deleteUrlImage(bgId);
              }
            };

            // ç»‘å®šæ–°çš„äº‹ä»¶ç›‘å¬å™¨
            listContainer.addEventListener('click', this.urlImageListClickHandler);
          },

          // --- æ–°å¢ï¼šæ˜¾ç¤ºç¼–è¾‘å›¾ç‰‡åç§°æ¨¡æ€æ¡† ---
          showEditImageNameModal(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            const input = document.getElementById('edit-image-name-input');
            const saveBtn = document.getElementById('save-image-name-btn');
            
            if (!input || !saveBtn) return;

            // è®¾ç½®å½“å‰åç§°
            input.value = bg.name;
            
            // ç§»é™¤æ—§çš„äº‹ä»¶ç›‘å¬å™¨
            if (this.saveImageNameHandler) {
              saveBtn.removeEventListener('click', this.saveImageNameHandler);
            }

            // åˆ›å»ºæ–°çš„ä¿å­˜äº‹ä»¶å¤„ç†å™¨
            this.saveImageNameHandler = () => {
              const newName = input.value.trim();
              if (!newName) {
                this.showTemporaryMessage('å›¾ç‰‡åç§°ä¸èƒ½ä¸ºç©º');
                return;
              }

              // æ›´æ–°å›¾ç‰‡åç§°
              bg.name = newName;
              this.saveBackgroundSettings();
              
              // åˆ·æ–°åˆ—è¡¨
              this.renderUrlImagesList();
              
              // å¦‚æœèƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†ä¹Ÿæ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°é‚£ä¸ªåˆ—è¡¨
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
              
              // åˆ·æ–°UIç•Œé¢çš„èƒŒæ™¯å›¾åˆ—è¡¨
              this.renderBackgroundList();

              this.closeModal('edit-image-name-modal');
              this.showTemporaryMessage(`å›¾ç‰‡åç§°å·²æ›´æ–°ä¸ºï¼š${newName}`);
            };

            // ç»‘å®šä¿å­˜äº‹ä»¶
            saveBtn.addEventListener('click', this.saveImageNameHandler);

            // ç»‘å®šå›è½¦é”®ä¿å­˜
            const handleEnterKey = (e) => {
              if (e.key === 'Enter') {
                this.saveImageNameHandler();
                input.removeEventListener('keypress', handleEnterKey);
              }
            };
            input.addEventListener('keypress', handleEnterKey);

            // æ‰“å¼€æ¨¡æ€æ¡†å¹¶èšç„¦è¾“å…¥æ¡†
            this.openModal('edit-image-name-modal');
            setTimeout(() => {
              input.focus();
              input.select();
            }, 100);
          },

          // --- æ–°å¢ï¼šåˆ é™¤å¤–é“¾å›¾ç‰‡ ---
          deleteUrlImage(bgId) {
            const bg = this.backgroundImages.find(b => b.id === bgId);
            if (!bg) return;

            this.showCustomConfirm(`ç¡®å®šè¦åˆ é™¤å¤–é“¾å›¾ç‰‡"${bg.name}"å—ï¼Ÿ`, () => {
              this.backgroundImages = this.backgroundImages.filter(b => b.id !== bgId);
              
              // å¦‚æœåˆ é™¤çš„æ˜¯å½“å‰é€‰ä¸­çš„èƒŒæ™¯ï¼Œæ¸…é™¤é€‰æ‹©
              if (this.selectedBackgroundId === bgId) {
                this.selectedBackgroundId = null;
              }
              
              this.saveBackgroundSettings();
              this.renderUrlImagesList();
              
              // å¦‚æœèƒŒæ™¯è®¾ç½®æ¨¡æ€æ¡†ä¹Ÿæ˜¯æ‰“å¼€çš„ï¼Œä¹Ÿåˆ·æ–°é‚£ä¸ªåˆ—è¡¨
              if (document.getElementById('background-settings-modal').style.display === 'flex') {
                this.renderBackgroundList();
              }
              
              this.applyRandomBackground(); // é‡æ–°åº”ç”¨èƒŒæ™¯
              this.showTemporaryMessage(`å·²åˆ é™¤å¤–é“¾å›¾ç‰‡ï¼š${bg.name}`);
            }, null, true); // keepCurrentModal = true
          },

          // æ–°å¢ï¼šç»‘å®šé”®ç›˜å¿«æ·é”®
          bindKeyboardShortcuts() {
            // å°†äº‹ä»¶å¤„ç†å‡½æ•°ç»‘å®šåˆ° this å¹¶ä¿å­˜å¼•ç”¨
            this.boundHandleKeydown = (e) => {
              // æ£€æŸ¥å¿«æ·é”®æ˜¯å¦å·²å¯ç”¨
              if (!this.isKeyboardShortcutsEnabled) {
                return; // å¿«æ·é”®å·²ç¦ç”¨
              }

              // æ£€æŸ¥æ˜¯å¦åœ¨è¾“å…¥æ¡†ä¸­ï¼Œå¦‚æœæ˜¯åˆ™ä¸å¤„ç†å¿«æ·é”®
              const activeElement = document.activeElement;
              const isInputField = activeElement && (
                activeElement.tagName === 'INPUT' ||
                activeElement.tagName === 'TEXTAREA' ||
                activeElement.contentEditable === 'true' ||
                activeElement.isContentEditable
              );

              if (isInputField) {
                return; // åœ¨è¾“å…¥æ¡†ä¸­æ—¶ä¸å¤„ç†å¿«æ·é”®
              }

              // å¤„ç†å¸¦ä¿®é¥°é”®çš„å¿«æ·é”®
              if (e.ctrlKey && !e.altKey && !e.metaKey) {
                switch (e.key.toLowerCase()) {
                  case 'a':
                    e.preventDefault();
                    this.toggleLeftPanel();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Ctrl+A - åˆ‡æ¢å·¦ä¾§é¢æ¿');
                    break;
                  case 'd':
                    e.preventDefault();
                    this.toggleRightPanel();
                    console.log('[å½’å¢Ÿå¿«æ·é”®] Ctrl+D - åˆ‡æ¢å³ä¾§é¢æ¿');
                    break;
                }
                return; // å¤„ç†å®Œä¿®é¥°é”®å¿«æ·é”®åè¿”å›
              }

              // é˜²æ­¢å…¶ä»–ä¿®é¥°é”®ç»„åˆå¹²æ‰°
              const isModifierPressed = e.ctrlKey || e.altKey || e.metaKey;
              if (isModifierPressed) {
                return; // æœ‰å…¶ä»–ä¿®é¥°é”®æ—¶ä¸å¤„ç†
              }

              switch (e.key.toLowerCase()) {
                case 'e':
                  e.preventDefault();
                  this.toggleModal('inventory-modal', () => this.showInventory());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Eé”® - åˆ‡æ¢ç‰©å“æ ');
                  break;
                case 'r':
                  e.preventDefault();
                  this.toggleModal('relationships-modal', () => this.showRelationships());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Ré”® - åˆ‡æ¢äººç‰©å…³ç³»');
                  break;
                case 'd':
                  e.preventDefault();
                  this.toggleModal('save-load-modal', () => this.showSaveLoadManager());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Dé”® - åˆ‡æ¢å­˜æ¡£ç®¡ç†å™¨');
                  break;
                case 't':
                  e.preventDefault();
                  this.toggleModal('settings-modal', () => this.showSettings());
                  console.log('[å½’å¢Ÿå¿«æ·é”®] Té”® - åˆ‡æ¢è®¾ç½®ç•Œé¢');
                  break;
              }
            };
            document.addEventListener('keydown', this.boundHandleKeydown);

            console.log('[å½’å¢Ÿå¿«æ·é”®] é”®ç›˜å¿«æ·é”®ç»‘å®šå®Œæˆ');
            console.log('[å½’å¢Ÿå¿«æ·é”®] E-èƒŒåŒ…, R-äººç‰©å…³ç³», D-å­˜æ¡£è¯»æ¡£, T-è®¾ç½®, Ctrl+A/D-é¢æ¿æŠ˜å ');
          },

          // æ–°å¢ï¼šæ¨¡æ€æ¡†åˆ‡æ¢å‡½æ•°
          toggleModal(modalId, showFunction) {
            const modal = document.getElementById(modalId);
            if (modal && modal.style.display === 'flex') {
              // å¦‚æœæ¨¡æ€æ¡†å·²ç»æ‰“å¼€ï¼Œåˆ™å…³é—­å®ƒ
              this.closeModal(modalId);
            } else {
              // å¦‚æœæ¨¡æ€æ¡†æœªæ‰“å¼€ï¼Œåˆ™æ‰“å¼€å®ƒ
              showFunction();
            }
          },

          // æ–°å¢ï¼šé”®ç›˜å¿«æ·é”®è¯¦æƒ…æŠ˜å /å±•å¼€å‡½æ•°
          toggleKeyboardShortcutsDetails() {
            const details = document.getElementById('keyboard-shortcuts-details');
            const toggleButton = document.getElementById('keyboard-shortcuts-toggle');
            
            if (details && toggleButton) {
              if (details.style.display === 'none' || details.style.display === '') {
                details.style.display = 'block';
                toggleButton.textContent = 'â–²';
                toggleButton.style.transform = 'rotate(180deg)';
              } else {
                details.style.display = 'none';
                toggleButton.textContent = 'â–¼';
                toggleButton.style.transform = 'rotate(0deg)';
              }
            }
          },

          // --- æ–°å¢ï¼šå¤„ç†å°å±å¹•ä¸‹è¾“å…¥æ¡†è¢«è¾“å…¥æ³•é®æŒ¡çš„é—®é¢˜ ---
          setupInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) {
              console.error('[å½’å¢Ÿè¾“å…¥æ³•] æœªæ‰¾åˆ°è¾“å…¥æ¡†å…ƒç´ ');
              return;
            }

            // æ ¹æ®è®¾ç½®é€‰æ‹©ä¸åŒçš„å¤„ç†æ–¹å¼
            if (this.isMobileInputAdaptEnabled) {
              // æ–°çš„è¾“å…¥æ¡†ä¸Šç§»æ–¹æ¡ˆ
              this.setupFloatingInput();
            } else {
              // åŸæœ‰çš„è§†å£è°ƒæ•´æ–¹æ¡ˆ
              this.setupViewportAdjustment();
            }
          },

          // é‡æ–°åˆå§‹åŒ–é”®ç›˜å¤„ç†é€»è¾‘ï¼ˆç”¨äºå¼€å…³åˆ‡æ¢æ—¶ï¼‰
          reinitializeInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) {
              console.error('[å½’å¢Ÿè¾“å…¥æ³•] æœªæ‰¾åˆ°è¾“å…¥æ¡†å…ƒç´ ');
              return;
            }

            console.log('[å½’å¢Ÿè¾“å…¥æ³•] é‡æ–°åˆå§‹åŒ–é”®ç›˜å¤„ç†ï¼Œå½“å‰çŠ¶æ€:', this.isMobileInputAdaptEnabled);

            // æ¸…ç†ç°æœ‰çš„äº‹ä»¶ç›‘å¬å™¨
            this.cleanupInputKeyboardHandling();

            // é‡æ–°è®¾ç½®é”®ç›˜å¤„ç†
            this.setupInputKeyboardHandling();
          },

          // æ¸…ç†é”®ç›˜å¤„ç†ç›¸å…³çš„äº‹ä»¶ç›‘å¬å™¨
          cleanupInputKeyboardHandling() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) return;

            // ç§»é™¤ç°æœ‰çš„äº‹ä»¶ç›‘å¬å™¨ï¼ˆé€šè¿‡å…‹éš†èŠ‚ç‚¹çš„æ–¹å¼ï¼‰
            const newInputField = inputField.cloneNode(true);
            inputField.parentNode.replaceChild(newInputField, inputField);

            console.log('[å½’å¢Ÿè¾“å…¥æ³•] å·²æ¸…ç†ç°æœ‰çš„äº‹ä»¶ç›‘å¬å™¨');
          },

          // æ–°æ–¹æ¡ˆï¼šè¾“å…¥æ¡†ä¸Šç§»åˆ°é¡¶éƒ¨
          setupFloatingInput() {
            const inputField = document.getElementById('quick-send-input');
            const sendButton = document.getElementById('btn-quick-send');
            const bottomBar = document.querySelector('.bottom-status-bar');
            
            if (!inputField) {
              console.error('[å½’å¢Ÿè¾“å…¥æ³•] æœªæ‰¾åˆ°è¾“å…¥æ¡†å…ƒç´ ');
              return;
            }
            
            console.log('[å½’å¢Ÿè¾“å…¥æ³•] åˆå§‹åŒ–è¾“å…¥æ¡†ä¸Šç§»åŠŸèƒ½');
            
            // ä¿å­˜åŸå§‹çˆ¶å…ƒç´ å’Œä½ç½®ä¿¡æ¯åˆ°å®ä¾‹å˜é‡
            this.originalParent = inputField.parentElement;
            this.originalNextSibling = inputField.nextSibling;
            
            // å°† moveInputToTop ä½œä¸ºå®ä¾‹æ–¹æ³•
            this.moveInputToTop = () => {
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] å¼€å§‹ç§»åŠ¨è¾“å…¥æ¡†åˆ°é¡¶éƒ¨');
              
              const container = this.createFloatingContainer();
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] æµ®åŠ¨å®¹å™¨å·²è·å–:', container);
              
              // æš‚æ—¶ä¿å­˜è¾“å…¥æ¡†çš„å€¼
              const inputValue = inputField.value;
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] ä¿å­˜è¾“å…¥æ¡†å€¼:', inputValue);
              
              // ç§»åŠ¨è¾“å…¥æ¡†åˆ°æµ®åŠ¨å®¹å™¨
              container.appendChild(inputField);
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†å·²æ·»åŠ åˆ°æµ®åŠ¨å®¹å™¨');
              
              // åº”ç”¨æ–°æ ·å¼ - ä¿æŒä¸åŸè¾“å…¥æ¡†ç›¸åŒçš„æ ·å¼
              inputField.style.cssText = `
                background: rgba(0, 0, 0, 0.5) !important;
                border: 1px solid #8b7355 !important;
                border-radius: 4px !important;
                color: #e0dcd1 !important;
                padding: 5px 10px !important;
                font-size: 12px !important;
                width: 100% !important;
                flex-grow: 1 !important;
                max-width: 500px !important;
                height: 32px !important;
                resize: none !important;
                line-height: 1.5 !important;
                font-family: inherit !important;
                margin: 0 !important;
              `;
              
              // ç§»é™¤ç„¦ç‚¹æ ·å¼äº‹ä»¶ï¼Œä¿æŒåŸå§‹æ ·å¼
              inputField.onfocus = null;
              inputField.onblur = null;
              
              // æ¢å¤è¾“å…¥æ¡†çš„å€¼
              inputField.value = inputValue;
              
              // åªæ·»åŠ å‘é€æŒ‰é’®ï¼Œä¸æ·»åŠ å†å²è®°å½•æŒ‰é’®
              if (sendButton && sendButton.parentElement !== container) {
                const sendBtnClone = document.createElement('button');
                sendBtnClone.textContent = 'å‘é€';
                sendBtnClone.style.cssText = `
                  padding: 6px 4px !important;
                  background: linear-gradient(45deg, #1a1a2e, #2d1b3d) !important;
                  border: 1px solid #c9aa71 !important;
                  border-radius: 5px !important;
                  color: #c9aa71 !important;
                  font-size: 10px !important;
                  cursor: pointer !important;
                  text-align: center !important;
                  transition: all 0.3s ease !important;
                  white-space: nowrap !important;
                `;
                sendBtnClone.onmouseover = () => {
                  sendBtnClone.style.background = 'linear-gradient(45deg, #2d1b3d, #3d2b4d)';
                };
                sendBtnClone.onmouseout = () => {
                  sendBtnClone.style.background = 'linear-gradient(45deg, #1a1a2e, #2d1b3d)';
                };
                sendBtnClone.onclick = () => {
                  // è§¦å‘åŸæŒ‰é’®çš„ç‚¹å‡»äº‹ä»¶
                  sendButton.click();
                };
                container.appendChild(sendBtnClone);
                console.log('[å½’å¢Ÿè¾“å…¥æ³•] å‘é€æŒ‰é’®å·²æ·»åŠ ï¼ˆä¸åŒ…å«å†å²è®°å½•æŒ‰é’®ï¼‰');
              }
              
              // æ˜¾ç¤ºå®¹å™¨åŠ¨ç”»
              setTimeout(() => {
                container.style.top = '0px';
                container.style.opacity = '1';
              }, 10);
              
              // èšç„¦è¾“å…¥æ¡†
              setTimeout(() => {
                inputField.focus();
                console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†å·²èšç„¦');
              }, 100);
              
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†å·²ç§»åŠ¨åˆ°é¡¶éƒ¨');
            };

            // ç›‘å¬ç„¦ç‚¹äº‹ä»¶
            inputField.addEventListener('focus', (e) => {
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†è·å¾—ç„¦ç‚¹ï¼Œé€‚é…å¼€å…³çŠ¶æ€:', this.isMobileInputAdaptEnabled);
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] å½“å‰æµ®åŠ¨å®¹å™¨çŠ¶æ€:', this.floatingInputContainer);
              if (this.isMobileInputAdaptEnabled) {
                // é˜²æ­¢é‡å¤è§¦å‘
                if (!this.floatingInputContainer || !this.floatingInputContainer.parentElement) {
                  console.log('[å½’å¢Ÿè¾“å…¥æ³•] å‡†å¤‡ç§»åŠ¨è¾“å…¥æ¡†åˆ°é¡¶éƒ¨');
                  this.moveInputToTop();
                } else {
                  console.log('[å½’å¢Ÿè¾“å…¥æ³•] æµ®åŠ¨å®¹å™¨å·²å­˜åœ¨ï¼Œè·³è¿‡åˆ›å»º');
                }
              } else {
                console.log('[å½’å¢Ÿè¾“å…¥æ³•] æ‰‹æœºè¾“å…¥æ¡†é€‚é…æœªå¼€å¯');
              }
            });

            inputField.addEventListener('blur', (e) => {
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†å¤±å»ç„¦ç‚¹');
              if (this.isMobileInputAdaptEnabled && this.floatingInputContainer) {
                // å»¶è¿Ÿæ£€æŸ¥ï¼Œé¿å…ç‚¹å‡»å…¶ä»–å…ƒç´ æ—¶ç«‹å³æ”¶èµ·
                setTimeout(() => {
                  // æ£€æŸ¥ç„¦ç‚¹æ˜¯å¦è¿˜åœ¨æµ®åŠ¨å®¹å™¨å†…
                  const activeElement = document.activeElement;
                  const isInFloatingContainer = this.floatingInputContainer &&
                    (this.floatingInputContainer.contains(activeElement) || activeElement === inputField);
                  
                  if (!isInFloatingContainer) {
                    this.resetInputPosition();
                  }
                }, 200);
              }
            });

            console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†ä¸Šç§»æ–¹æ¡ˆå·²åˆå§‹åŒ–');
          },

          // åˆ›å»ºæµ®åŠ¨è¾“å…¥æ¡†å®¹å™¨ï¼ˆä½œä¸ºå®ä¾‹æ–¹æ³•ï¼‰
          createFloatingContainer() {
            if (this.floatingInputContainer && this.floatingInputContainer.parentElement) {
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] ä½¿ç”¨ç°æœ‰æµ®åŠ¨å®¹å™¨');
              return this.floatingInputContainer;
            }
            
            this.floatingInputContainer = document.createElement('div');
            this.floatingInputContainer.className = 'floating-input-container';
            this.floatingInputContainer.style.cssText = `
              position: fixed !important;
              top: -60px !important;
              left: 0 !important;
              right: 0 !important;
              width: 100% !important;
              z-index: 999999 !important;
              background: transparent !important;
              padding: 10px 15px !important;
              display: flex !important;
              gap: 8px !important;
              align-items: center !important;
              opacity: 0 !important;
              visibility: visible !important;
              pointer-events: auto !important;
              transform: translateY(0) !important;
              transition: all 0.3s ease !important;
            `;
            
            // æ£€æŸ¥æ˜¯å¦åœ¨å…¨å±æ¨¡å¼ä¸‹
            const isFullscreen = document.fullscreenElement !== null;
            const rootContainer = document.querySelector('.guixu-root-container');
            
            if (isFullscreen && rootContainer) {
              // å…¨å±æ¨¡å¼ä¸‹ï¼Œæ·»åŠ åˆ°ä¸»ç•Œé¢å®¹å™¨å†…
              rootContainer.appendChild(this.floatingInputContainer);
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] å…¨å±æ¨¡å¼ï¼šæµ®åŠ¨å®¹å™¨å·²æ·»åŠ åˆ°ä¸»ç•Œé¢å®¹å™¨å†…');
            } else {
              // éå…¨å±æ¨¡å¼ä¸‹ï¼Œæ·»åŠ åˆ°body
              document.body.appendChild(this.floatingInputContainer);
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] éå…¨å±æ¨¡å¼ï¼šæµ®åŠ¨å®¹å™¨å·²æ·»åŠ åˆ°body');
            }
            
            // å¼ºåˆ¶é‡ç»˜
            this.floatingInputContainer.offsetHeight;
            
            console.log('[å½’å¢Ÿè¾“å…¥æ³•] æµ®åŠ¨å®¹å™¨å·²åˆ›å»ºï¼Œå…¨å±çŠ¶æ€:', isFullscreen);
            
            return this.floatingInputContainer;
          },

          // æ¢å¤è¾“å…¥æ¡†ä½ç½®ï¼ˆä½œä¸ºå®ä¾‹æ–¹æ³•ï¼‰
          resetInputPosition() {
            console.log('[å½’å¢Ÿè¾“å…¥æ³•] å¼€å§‹æ¢å¤è¾“å…¥æ¡†ä½ç½®');
            
            const inputField = document.getElementById('quick-send-input');
            if (!this.floatingInputContainer || !inputField) return;
            
            // éšè—å®¹å™¨
            this.floatingInputContainer.style.opacity = '0';
            this.floatingInputContainer.style.visibility = 'hidden';
            
            // å»¶è¿Ÿæ¢å¤ä½ç½®
            setTimeout(() => {
              // ä¿å­˜è¾“å…¥æ¡†çš„å€¼
              const inputValue = inputField.value;
              
              // æ¢å¤è¾“å…¥æ¡†åˆ°åŸå§‹ä½ç½®
              if (this.originalNextSibling) {
                this.originalParent.insertBefore(inputField, this.originalNextSibling);
              } else {
                this.originalParent.appendChild(inputField);
              }
              
              // æ¢å¤åŸå§‹æ ·å¼
              inputField.style.cssText = '';
              inputField.className = 'quick-send-input';
              
              // æ¢å¤è¾“å…¥æ¡†çš„å€¼
              inputField.value = inputValue;
              
              // ç§»é™¤æµ®åŠ¨å®¹å™¨ä¸­çš„å…‹éš†æŒ‰é’®
              const clonedButton = this.floatingInputContainer.querySelector('button:not(.close-floating-input)');
              if (clonedButton) {
                clonedButton.remove();
              }
              
              // ç§»é™¤æµ®åŠ¨å®¹å™¨
              if (this.floatingInputContainer && this.floatingInputContainer.parentElement) {
                this.floatingInputContainer.remove();
              }
              this.floatingInputContainer = null;
              
              console.log('[å½’å¢Ÿè¾“å…¥æ³•] è¾“å…¥æ¡†å·²æ¢å¤åˆ°åŸä½');
            }, 300);
          },

          // åŸæ–¹æ¡ˆï¼šè§†å£è°ƒæ•´
          setupViewportAdjustment() {
            const inputField = document.getElementById('quick-send-input');
            if (!inputField) {
              console.error('[å½’å¢Ÿè¾“å…¥æ³•] æœªæ‰¾åˆ°è¾“å…¥æ¡†å…ƒç´ ');
              return;
            }

            let isKeyboardOpen = false;
            let originalHeight = window.innerHeight;
            let lastScrollPosition = 0;

            // ä½¿ç”¨ Visual Viewport APIï¼ˆå¦‚æœå¯ç”¨ï¼‰
            const getViewportHeight = () => {
              if (window.visualViewport) {
                return window.visualViewport.height;
              }
              return window.innerHeight;
            };

            // å¤„ç†é”®ç›˜æ˜¾ç¤º/éšè—
            const handleKeyboardToggle = () => {
              const currentHeight = getViewportHeight();
              const heightDiff = originalHeight - currentHeight;
              
              // é”®ç›˜å¼¹å‡ºï¼ˆé«˜åº¦å‡å°‘è¶…è¿‡100pxï¼‰
              if (heightDiff > 100 && !isKeyboardOpen) {
                isKeyboardOpen = true;
                this.adjustForKeyboard(true, heightDiff);
              }
              // é”®ç›˜æ”¶èµ·ï¼ˆé«˜åº¦æ¢å¤ï¼‰
              else if (heightDiff < 50 && isKeyboardOpen) {
                isKeyboardOpen = false;
                this.adjustForKeyboard(false, 0);
              }
            };

            // ç›‘å¬è¾“å…¥æ¡†ç„¦ç‚¹äº‹ä»¶
            inputField.addEventListener('focus', () => {
              // ä¿å­˜å½“å‰æ»šåŠ¨ä½ç½®
              lastScrollPosition = window.scrollY;
              
              // å¯¹äºç§»åŠ¨è®¾å¤‡ï¼Œå»¶è¿Ÿå¤„ç†ä»¥ç­‰å¾…é”®ç›˜å®Œå…¨å¼¹å‡º
              setTimeout(() => {
                handleKeyboardToggle();
                this.ensureInputVisible();
              }, 300);
            });

            inputField.addEventListener('blur', () => {
              // å»¶è¿Ÿå¤„ç†é”®ç›˜æ”¶èµ·
              setTimeout(() => {
                if (document.activeElement !== inputField) {
                  isKeyboardOpen = false;
                  this.adjustForKeyboard(false, 0);
                  // æ¢å¤æ»šåŠ¨ä½ç½®
                  window.scrollTo(0, lastScrollPosition);
                }
              }, 300);
            });

            // ç›‘å¬è§†å£å˜åŒ–
            if (window.visualViewport) {
              window.visualViewport.addEventListener('resize', handleKeyboardToggle);
              window.visualViewport.addEventListener('scroll', () => {
                if (isKeyboardOpen) {
                  this.ensureInputVisible();
                }
              });
            } else {
              // é™çº§æ–¹æ¡ˆï¼šç›‘å¬window resize
              window.addEventListener('resize', handleKeyboardToggle);
            }

            // ç›‘å¬æ–¹å‘å˜åŒ–
            window.addEventListener('orientationchange', () => {
              setTimeout(() => {
                originalHeight = window.innerHeight;
                handleKeyboardToggle();
              }, 500);
            });

            console.log('[å½’å¢Ÿè¾“å…¥æ³•] è§†å£è°ƒæ•´æ–¹æ¡ˆå·²åˆå§‹åŒ–');
          },

          // è°ƒæ•´é¡µé¢ä»¥é€‚åº”è™šæ‹Ÿé”®ç›˜
          adjustForKeyboard(keyboardOpen, keyboardHeight) {
            const bottomBar = document.querySelector('.bottom-status-bar');
            const chatContainer = document.querySelector('.chat-container');
            const rootContainer = document.querySelector('.guixu-root-container');
            
            if (keyboardOpen && keyboardHeight > 0) {
              // é”®ç›˜å¼¹å‡ºæ—¶çš„è°ƒæ•´
              
              // ç§»åŠ¨ç«¯ç‰¹æ®Šå¤„ç†
              if (rootContainer && rootContainer.classList.contains('mobile-view')) {
                // åº•éƒ¨çŠ¶æ€æ ä¸Šç§»åˆ°é”®ç›˜ä¸Šæ–¹
                if (bottomBar) {
                  bottomBar.style.position = 'fixed';
                  bottomBar.style.bottom = `${keyboardHeight}px`;
                  bottomBar.style.left = '0';
                  bottomBar.style.right = '0';
                  bottomBar.style.zIndex = '10000';
                  bottomBar.style.transition = 'bottom 0.3s ease';
                }
                
                // è°ƒæ•´èŠå¤©å®¹å™¨åº•éƒ¨é—´è·
                if (chatContainer) {
                  const bottomBarHeight = bottomBar ? bottomBar.offsetHeight : 0;
                  chatContainer.style.paddingBottom = `${keyboardHeight + bottomBarHeight + 10}px`;
                  chatContainer.style.transition = 'padding-bottom 0.3s ease';
                }
              } else {
                // æ¡Œé¢ç«¯ç®€å•å¤„ç†
                if (bottomBar) {
                  bottomBar.style.position = 'fixed';
                  bottomBar.style.bottom = '0';
                  bottomBar.style.zIndex = '10000';
                }
                if (chatContainer) {
                  chatContainer.style.paddingBottom = '150px';
                }
              }
            } else {
              // é”®ç›˜æ”¶èµ·æ—¶æ¢å¤
              if (bottomBar) {
                bottomBar.style.position = '';
                bottomBar.style.bottom = '';
                bottomBar.style.left = '';
                bottomBar.style.right = '';
                bottomBar.style.zIndex = '';
                bottomBar.style.transition = '';
              }
              if (chatContainer) {
                chatContainer.style.paddingBottom = '';
                chatContainer.style.transition = '';
              }
            }
          },

          // ç¡®ä¿è¾“å…¥æ¡†å¯è§
          ensureInputVisible() {
            const inputField = document.getElementById('quick-send-input');
            const bottomBar = document.querySelector('.bottom-status-bar');
            
            if (inputField && bottomBar) {
              // è·å–å…ƒç´ ä½ç½®
              const inputRect = inputField.getBoundingClientRect();
              const viewportHeight = this.getViewportHeight();
              
              // å¦‚æœè¾“å…¥æ¡†ä¸åœ¨å¯è§†åŒºåŸŸå†…
              if (inputRect.bottom > viewportHeight || inputRect.top < 0) {
                // è®¡ç®—éœ€è¦æ»šåŠ¨çš„è·ç¦»
                const scrollTarget = window.scrollY + inputRect.top - (viewportHeight / 2);
                
                // å¹³æ»‘æ»šåŠ¨åˆ°åˆé€‚ä½ç½®
                window.scrollTo({
                  top: scrollTarget,
                  behavior: 'smooth'
                });
              }
            }
          },

          // è·å–è§†å£é«˜åº¦çš„è¾…åŠ©å‡½æ•°
          getViewportHeight() {
            if (window.visualViewport) {
              return window.visualViewport.height;
            }
            return window.innerHeight;
          },
      

          // --- æ–°å¢ï¼šè¡æ¢¦å°˜ Gachaç³»ç»Ÿ å…¨å¥—æ ¸å¿ƒå‡½æ•° ---

          showGachaSystem() {
              this.isFromGuixuSystem = true;
              this.openModal('gacha-modal', true); // ç›´æ¥æ‰“å¼€æ¨¡æ€æ¡†
              this.renderSummonTab(); // ç›´æ¥æ¸²æŸ“æ–°çš„å¬å”¤UIï¼Œä¸å†éœ€è¦æ ‡ç­¾é¡µé€»è¾‘
          },

          loadGachaState() {
              const defaultState = {
                  // ç§»é™¤ mengChen å±æ€§
                  pitySSR_char: 0, pitySR_char: 0,
                  pitySSR_item: 0, pitySR_item: 0, pitySSR_talent: 0, pitySR_talent: 0,
                  redeemedCodes: [],
                  activeCompanions: [],
                  activatedItems: [],
              };
              const savedState = AppStorage.loadData('gacha_state', defaultState);
              this.gachaState = Object.assign({}, defaultState, savedState);
              // ç¡®ä¿æ—§çš„ mengChen å±æ€§è¢«åˆ é™¤ï¼Œä»¥é˜²æ—§å­˜æ¡£å¹²æ‰°
              if (this.gachaState.mengChen) {
                  delete this.gachaState.mengChen;
              }
              this.gachaCollection = AppStorage.loadData('gacha_collection', {});
              this.gachaHistory = AppStorage.loadData('gacha_history', []);
          },

          saveGachaState() {
              AppStorage.saveData('gacha_state', this.gachaState);
              AppStorage.saveData('gacha_collection', this.gachaCollection);
              AppStorage.saveData('gacha_history', this.gachaHistory);
          },

          

          // æ–°å¢è¾…åŠ©å‡½æ•°(1)ï¼šæ›´æ–°æ•´ä¸ªGachaæ¨¡æ€æ¡†çš„èƒŒæ™¯
          _updateGachaBackground(bgUrl) {
              const modalContent = document.getElementById('gacha-modal-content');
              if (modalContent && bgUrl) {
                  const img = new Image();
                  img.onload = () => {
                      modalContent.style.backgroundImage = `url('${bgUrl}')`;
                  };
                  img.src = bgUrl;
              }
          },

          // æ¸²æŸ“å•ä¸ªå¡æ± è¯¦æƒ…çš„è¾…åŠ©å‡½æ•° (ç¬¬äºŒæ­¥)
          _renderGachaPool(poolType) {
              this.currentGachaPoolType = poolType;
              const displayContainer = document.getElementById('gacha-pool-display');
              if (!displayContainer) return;

              const poolData = {
                  character: { title: 'é•œèŠ±æ°´æœˆ (è§’è‰²æ± )', cost: 320, pitySSR: this.gachaState.pitySSR_char, pitySR: this.gachaState.pitySR_char, bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: 'ä¸‡è±¡å¥‡ç (é“å…·æ± )', cost: 160, pitySSR: this.gachaState.pitySSR_item, pitySR: this.gachaState.pitySR_item, bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: 'å¤©å‘½çµæ ¹ (å¤©èµ‹æ± )', cost: 160, pitySSR: this.gachaState.pitySSR_talent, pitySR: this.gachaState.pitySR_talent, bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };
              const currentPool = poolData[poolType];

              this._updateGachaBackground(currentPool.bg);

              displayContainer.innerHTML = `
                  <div class="summon-container">
                      <div class="summon-header-info"></div> 
                      <div class="summon-main-controls">
                          <h3 class="pool-title">${currentPool.title}</h3>
                          <p style="font-size:12px; color:#a09c91;">SSRä¿åº•: ${currentPool.pitySSR}/90 | SRä¿åº•: ${currentPool.pitySR}/10</p>
                          <div class="summon-buttons">
                              <button id="gacha-pull-1" class="interaction-btn">å¬å”¤1æ¬¡ (${currentPool.cost} æ¢¦å°˜)</button>
                              <button id="gacha-pull-10" class="interaction-btn primary-btn">å¬å”¤10æ¬¡ (${currentPool.cost * 10} æ¢¦å°˜)</button>
                          </div>
                      </div>
                  </div>
              `;

              document.getElementById('gacha-pull-1').addEventListener('click', () => this.handlePull(1, poolType));
              document.getElementById('gacha-pull-10').addEventListener('click', () => this.handlePull(10, poolType));

              document.querySelectorAll('.pool-switch-btn').forEach(btn => {
                  btn.classList.toggle('active', btn.dataset.pool === poolType);
              });

              // æ ¸å¿ƒä¿®å¤ï¼šæ¯æ¬¡åˆ‡æ¢å¡æ± æ—¶ï¼Œéƒ½ä¸ºå›¾é‰´æŒ‰é’®é‡æ–°ç»‘å®šå¸¦æœ‰æ­£ç¡®ä¸Šä¸‹æ–‡çš„äº‹ä»¶
              const galleryBtn = document.getElementById('btn-gacha-gallery-new');
              if (galleryBtn) {
                  const newBtn = galleryBtn.cloneNode(true); // å…‹éš†æŒ‰é’®ä»¥ç§»é™¤æ—§ç›‘å¬å™¨
                  galleryBtn.parentNode.replaceChild(newBtn, galleryBtn);
                  newBtn.addEventListener('click', () => this.showGachaGalleryPopup(poolType));
              }
          },

     // æ˜¾ç¤ºå›¾é‰´å¼¹çª— (v4 - ä¿®å¤é‡å¤åŠ å…¥ & ä¼˜åŒ–æŒ‰é’®çŠ¶æ€)
          showGachaGalleryPopup(poolType) { // æ ¸å¿ƒä¿®å¤ï¼šç›´æ¥æ¥æ”¶ poolType å‚æ•°
              if (!poolType) {
                  console.error('showGachaGalleryPopup è°ƒç”¨æ—¶ç¼ºå°‘ poolType');
                  poolType = this.currentGachaPoolType; // æä¾›ä¸€ä¸ªå›é€€
              }
              this.openModal('gacha-gallery-popup', true);
               // const poolType = this.currentGachaPoolType; // ä¸å†ä»å…¨å±€çŠ¶æ€è¯»å–
              const poolData = {
                  character: { title: 'é•œèŠ±æ°´æœˆ', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: 'ä¸‡è±¡å¥‡ç', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: 'å¤©å‘½çµæ ¹', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };
              const currentPool = poolData[poolType];

              document.getElementById('gacha-gallery-title').textContent = `${currentPool.title} å›¾é‰´`;

              const previewContainer = document.getElementById('gallery-pool-preview');
              previewContainer.innerHTML = `<div class="summon-container" style="background-image: url('${currentPool.bg}');"><h3 class="pool-title">${currentPool.title}</h3></div>`;

              const gridContainer = document.getElementById('gallery-obtained-grid');
              const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];

              const renderContent = (isObtainedOnly) => {
                  const itemsToRender = isObtainedOnly ? allItems.filter(item => this.gachaCollection[item.id]) : allItems;

                  if (itemsToRender.length === 0) {
                      gridContainer.innerHTML = `<p style='text-align:center; color:#8b7355; padding-top: 40px;'>${isObtainedOnly ? 'æ­¤å¡æ± æš‚æ— å·²è·å¾—çš„é¡¹ç›®' : 'æ­¤å¡æ± å†…å®¹ä¸ºç©º'}</p>`;
                      return;
                  }

                  let gridHtml = '';
                  if (poolType === 'character') {
                      itemsToRender.forEach(item => {
                          const isUnlocked = this.gachaCollection[item.id];
                          const isActive = this.gachaState.activeCompanions.some(c => c.id === item.id);
                          const isQueued = this.pendingActions.some(a => a.itemName === item.åç§°);
                          let buttonHtml = '';
                          if (isUnlocked) {
                              if (isActive) buttonHtml = `<button class="gallery-join-world-btn" disabled>å·²åŠ å…¥</button>`;
                              else if (isQueued) buttonHtml = `<button class="gallery-join-world-btn" disabled>æŒ‡ä»¤é˜Ÿåˆ—ä¸­</button>`;
                              else buttonHtml = `<button class="gallery-join-world-btn" data-item-id="${item.id}">åŠ å…¥ä¸–ç•Œ</button>`;
                          }
                          const bgImageStyle = item.å›¾ç‰‡ ? `background-image: url('${item.å›¾ç‰‡}');` : '';
                          gridHtml += `
                              <div class="gallery-card rarity-${item.ç¨€æœ‰åº¦} ${isUnlocked ? 'unlocked' : 'gallery-card-locked'}" data-item-id="${item.id}">
                                  <div class="gallery-card-name">${item.åç§°}</div>
                                  ${buttonHtml}
                              </div>
                          `;
                      });
                      gridContainer.innerHTML = `<div class="gallery-grid">${gridHtml}</div>`;
                  } else {
                      itemsToRender.forEach(item => {
                          const isUnlocked = this.gachaCollection[item.id];
                          const isActive = this.gachaState.activatedItems.includes(item.id);
                          const isQueued = this.pendingActions.some(a => a.itemName === item.åç§°);
                          let buttonHtml = '';
                          if (isUnlocked) {
                              if (isActive) buttonHtml = `<button class="gallery-join-world-btn" disabled>å·²æ¿€æ´»</button>`;
                              else if (isQueued) buttonHtml = `<button class="gallery-join-world-btn" disabled>æŒ‡ä»¤é˜Ÿåˆ—ä¸­</button>`;
                              else buttonHtml = `<button class="gallery-join-world-btn" data-item-id="${item.id}" style="position: static; transform: none; opacity: 1; background: rgba(139,115,85,0.4);">åŠ å…¥æŒ‡ä»¤</button>`;
                          }

                          gridHtml += `
                              <div class="gallery-text-item ${isUnlocked ? '' : 'gallery-text-item-locked'}" data-item-id="${item.id}">
                                  <div class="gallery-text-item-header">
                                      <span class="gallery-text-item-name rarity-${item.ç¨€æœ‰åº¦}">${item.åç§°} ${item.ç±»å‹ ? `(${item.ç±»å‹})` : ''}</span>
                                      <span class="gallery-text-item-rarity rarity-${item.ç¨€æœ‰åº¦}">${item.ç¨€æœ‰åº¦}</span>
                                  </div>
                                  <p class="gallery-text-item-desc">${item.æè¿°}</p>
                                  ${isUnlocked ? `<div style="text-align: right; margin-top: 8px;">${buttonHtml}</div>` : ''}
                              </div>
                          `;
                      });
                      gridContainer.innerHTML = `<div class="gallery-text-grid">${gridHtml}</div>`;
                  }

                  gridContainer.querySelectorAll('.gallery-join-world-btn[data-item-id]').forEach(btn => {
                      btn.addEventListener('click', (e) => {
                          e.stopPropagation();
                          const itemId = e.target.dataset.itemId;
                          const itemData = allItems.find(i => i.id === itemId);
                          if(itemData) this.handleJoinWorld(itemData, poolType);
                      });
                  });
              };

              const container = document.querySelector('.gallery-obtained-container');
              const oldTabs = container.querySelector('.gallery-tab-nav');
              if (oldTabs) oldTabs.remove();
              const tabsHtml = `
                  <div class="gallery-tab-nav">
                      <button class="gallery-tab-btn" data-view="overview">å¡æ± æ€»è§ˆ</button>
                      <button class="gallery-tab-btn" data-view="collection">æˆ‘çš„æ”¶è—</button>
                  </div>
              `;
              container.insertAdjacentHTML('afterbegin', tabsHtml);

              const tabButtons = container.querySelectorAll('.gallery-tab-btn');
              tabButtons.forEach(btn => {
                  btn.addEventListener('click', () => {
                      tabButtons.forEach(b => b.classList.remove('active'));
                      btn.classList.add('active');
                      renderContent(btn.dataset.view === 'collection');
                  });
              });

              container.querySelector('.gallery-tab-btn[data-view="overview"]').click();
          },

   // --- æ–°å¢ï¼šè¡æ¢¦å°˜è®¾ç½®é¢æ¿å…¨å¥—å‡½æ•° ---
          showGachaSettingsPopup() {
              this.openModal('gacha-settings-popup', true);
              const container = document.querySelector('#gacha-settings-popup .modal-body');
              if (!container) return;

              // æ ¸å¿ƒä¿®æ”¹ï¼šå°†â€œè§’è‰²æ¡£æ¡ˆâ€æ ‡ç­¾çš„æ–‡æœ¬æ”¹ä¸ºâ€œå¡æ± æ¡£æ¡ˆâ€
              const archiveTab = container.querySelector('.gacha-settings-tab[data-tab="archives"]');
              if (archiveTab) archiveTab.textContent = 'å¡æ± æ¡£æ¡ˆ';

              // ç»‘å®šæ ‡ç­¾é¡µç‚¹å‡»äº‹ä»¶
              container.querySelectorAll('.gacha-settings-tab').forEach(tab => {
                  tab.addEventListener('click', () => {
                      container.querySelectorAll('.gacha-settings-tab').forEach(t => t.classList.remove('active'));
                      tab.classList.add('active');
                      this._renderGachaSettingsTab(tab.dataset.tab);
                  });
              });

              // é»˜è®¤æ¸²æŸ“ç¬¬ä¸€ä¸ªæ ‡ç­¾é¡µ
              this._renderGachaSettingsTab('command_center');
          },

          _renderGachaSettingsTab(tabName) {
              const contentContainer = document.getElementById('gacha-settings-content-container');
              if (!contentContainer) return;
              
              // ä¿®å¤ï¼šåœ¨æ¸²æŸ“æ–°å†…å®¹å‰ï¼Œå…ˆæ¸…ç©ºå¹¶æ˜¾ç¤ºåŠ è½½çŠ¶æ€
              contentContainer.innerHTML = '<p style="color: #a09c91; padding: 20px;">æ­£åœ¨åŠ è½½...</p>';

              switch (tabName) {
                  case 'command_center':
                      this._renderSettingsCommandCenter(contentContainer);
                      break;
                  case 'archives':
                      this._renderSettingsArchives(contentContainer);
                      break;
                  case 'redeem':
                      this._renderSettingsRedeem(contentContainer);
                      break;
                  case 'pool_editor':
                      this._renderSettingsPoolEditor(contentContainer);
                      break;
              }
          },

          _renderSettingsCommandCenter(container) {
              let contentHtml = '<h3 class="settings-section-title">å¾…å¤„ç†æŒ‡ä»¤</h3>';
              if (this.pendingActions.length === 0) {
                  contentHtml += '<p style="color: #a09c91; font-size: 13px;">å½“å‰æ²¡æœ‰å¾…å¤„ç†çš„æŒ‡ä»¤ã€‚</p>';
              } else {
                  contentHtml += '<ul class="command-center-list">';
                  this.pendingActions.forEach(cmd => {
                      const actionText = this._formatActionText(cmd); // æ ¸å¿ƒä¿®å¤ï¼šè°ƒç”¨ç»Ÿä¸€çš„æ ¼å¼åŒ–å‡½æ•°
                      if(actionText) contentHtml += `<li>${actionText}</li>`;
                  });
                  contentHtml += '</ul>';
                  contentHtml += '<button id="gacha-clear-pending" class="interaction-btn btn-danger" style="margin-top: 15px;">æ¸…ç©ºæŒ‡ä»¤</button>';
              }
              container.innerHTML = contentHtml;

              const clearBtn = document.getElementById('gacha-clear-pending');
              if(clearBtn) {
                  clearBtn.addEventListener('click', () => {
                      this.pendingActions = [];
                      this.savePendingActions();
                      this._renderGachaSettingsTab('command_center'); // åˆ·æ–°å½“å‰æ ‡ç­¾é¡µ
                      this.showTemporaryMessage('æŒ‡ä»¤ä¸­å¿ƒå·²æ¸…ç©º');
                  });
              }
          },

          // â€œå¡æ± æ¡£æ¡ˆâ€åŠŸèƒ½é‡æ„ (v5 - ç®€åŒ–å¹¶ä¿®å¤)
          _renderSettingsArchives(container) {
              container.innerHTML = '<p style="color: #a09c91;">æ­£åœ¨åŠ è½½å¡æ± é¡¹ç›®...</p>';
              
              const allPoolItems = [
                  ...Object.values(this.gachaPools.character || {}).flat(),
                  ...Object.values(this.gachaPools.item || {}).flat(),
                  ...Object.values(this.gachaPools.talent || {}).flat()
              ].filter(Boolean);

              if (allPoolItems.length === 0) {
                  container.innerHTML = '<p style="color: #a09c91; font-size: 13px;">â€œã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± â€ä¸ºç©ºæˆ–æœªåŠ è½½ï¼Œè¯·å…ˆåœ¨ä¸–ç•Œä¹¦ä¸­å®šä¹‰å¡æ± å†…å®¹ã€‚</p>';
                  return;
              }
              
              let contentHtml = '<h3 class="settings-section-title">å¡æ± é¡¹ç›®é¢„è§ˆ</h3>';
              contentHtml += '<p style="font-size: 12px; color: #a09c91; margin-top: -5px; margin-bottom: 15px;">æ­¤å¤„åˆ—å‡ºæ‰€æœ‰åœ¨â€œã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± â€ä¸–ç•Œä¹¦ä¸­å®šä¹‰çš„é¡¹ç›®ã€‚</p>';

              for (const item of allPoolItems) {
                  contentHtml += `
                      <div class="character-archive-item">
                          <div class="archive-header">
                              <span class="archive-char-name" style="color: ${item.ç¨€æœ‰åº¦ === 'SSR' ? '#FFD700' : item.ç¨€æœ‰åº¦ === 'SR' ? '#C0C0C0' : '#CD7F32'};">${item.åç§°}</span>
                              <span style="font-size: 12px; color: #a09c91;">${item.ç±»å‹} - ${item.ç¨€æœ‰åº¦}</span>
                          </div>
                          <div style="padding: 10px 15px; font-size: 13px; color: #d4d2c8;">${item.æè¿°}</div>
                      </div>
                  `;
              }
              container.innerHTML = contentHtml;
          },

          // æ–°å¢ï¼šå¡æ± ç¼–è¾‘å™¨UIæ¸²æŸ“å‡½æ•°
          _renderSettingsPoolEditor(container) {
              let contentHtml = `
                  <div class="pool-editor-container">
                      <h3 class="settings-section-title">å¡æ± ç¼–è¾‘å™¨</h3>
                      <p style="font-size: 12px; color: #a09c91; margin-top: -5px; margin-bottom: 15px;">åœ¨æ­¤ç®¡ç†â€œã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± â€ä¸–ç•Œä¹¦çš„å†…å®¹ã€‚</p>
                      <div class="pool-editor-controls">
                          <select id="pool-editor-select" class="quick-send-input">
                              <option value="character">[è§’è‰²æ± ]</option>
                              <option value="item">[é“å…·æ± ]</option>
                              <option value="talent">[å¤©èµ‹æ± ]</option>
                          </select>
                          <button id="pool-editor-add-btn" class="interaction-btn primary-btn">æ·»åŠ æ–°é¡¹ç›®</button>
                      </div>
                      <div id="pool-editor-list-container" class="pool-editor-list">
                          <!-- é¡¹ç›®åˆ—è¡¨å°†åœ¨è¿™é‡ŒåŠ¨æ€ç”Ÿæˆ -->
                      </div>
                  </div>
              `;
              container.innerHTML = contentHtml;

              // --- äº‹ä»¶ç»‘å®šå’Œåˆå§‹åŒ– ---
              const selectEl = document.getElementById('pool-editor-select');
              const addBtn = document.getElementById('pool-editor-add-btn');

              if (selectEl) {
                  selectEl.addEventListener('change', () => {
                      this._loadPoolEditorList(selectEl.value);
                  });
              }

              if (addBtn) {
                  addBtn.addEventListener('click', () => {
                      const poolType = selectEl ? selectEl.value : 'character';
                      this._addNewItemToEditor(poolType);
                  });
              }

              // åˆå§‹åŠ è½½é»˜è®¤å¡æ± 
              this._loadPoolEditorList(selectEl ? selectEl.value : 'character');
          },

          // æ–°å¢ï¼šåŠ è½½å¹¶æ¸²æŸ“æŒ‡å®šå¡æ± çš„ç¼–è¾‘å™¨åˆ—è¡¨
          async _loadPoolEditorList(poolType) {
              const listContainer = document.getElementById('pool-editor-list-container');
              if (!listContainer) return;

              listContainer.innerHTML = '<p style="color: #a09c91;">æ­£åœ¨ä»ä¸–ç•Œä¹¦åŠ è½½é¡¹ç›®...</p>';
              
              const poolCommentMapping = {
                  character: '[è§’è‰²æ± ]',
                  item: '[é“å…·æ± ]',
                  talent: '[å¤©èµ‹æ± ]'
              };
              const targetComment = poolCommentMapping[poolType];
              
              try {
                  const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);

                  if (!targetEntry || !targetEntry.content) {
                      listContainer.innerHTML = '<p style-style="color: #8b7355;">æœªæ‰¾åˆ°æˆ–å¡æ± ä¸ºç©ºã€‚æ‚¨å¯ä»¥ç‚¹å‡»â€œæ·»åŠ æ–°é¡¹ç›®â€æ¥åˆ›å»ºç¬¬ä¸€ä¸ªæ¡ç›®ã€‚</p>';
                      return;
                  }

                  const itemBlocks = targetEntry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                  if (itemBlocks.length === 0) {
                       listContainer.innerHTML = '<p style-style="color: #8b7355;">å¡æ± ä¸ºç©ºã€‚æ‚¨å¯ä»¥ç‚¹å‡»â€œæ·»åŠ æ–°é¡¹ç›®â€æ¥åˆ›å»ºç¬¬ä¸€ä¸ªæ¡ç›®ã€‚</p>';
                      return;
                  }

                  listContainer.innerHTML = ''; // æ¸…ç©º
                  itemBlocks.forEach(block => {
                      const item = this._parseGachaPoolEntry('åç§°:' + block);
                      if (item) {
                          const itemElement = this._createEditorItemElement(item, poolType);
                          listContainer.appendChild(itemElement);
                      }
                  });

              } catch (e) {
                  console.error(`åŠ è½½å¡æ±  [${targetComment}] å¤±è´¥:`, e);
                  listContainer.innerHTML = `<p style="color: #ff6b6b;">åŠ è½½å¤±è´¥: ${e.message}</p>`;
              }
          },

          // æ–°å¢ï¼šä»ä¸–ç•Œä¹¦ä¸­åˆ é™¤å¡æ± é¡¹ç›®
          async _deletePoolItem(itemName, poolType) {
              this.showTemporaryMessage(`æ­£åœ¨åˆ é™¤â€œ${itemName}â€...`, 'info');
              const poolCommentMapping = {
                  character: '[è§’è‰²æ± ]',
                  item: '[é“å…·æ± ]',
                  talent: '[å¤©èµ‹æ± ]'
              };
              const targetComment = poolCommentMapping[poolType];

              try {
                  const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  const targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);

                  if (!targetEntry) {
                      throw new Error('æœªæ‰¾åˆ°å¯¹åº”çš„å¡æ± æ¡ç›®ã€‚');
                  }

                  const itemBlocks = targetEntry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                  const newBlocks = itemBlocks.filter(block => !('åç§°:' + block).trim().startsWith(`åç§°: ${itemName}`));
                  
                  if (newBlocks.length === itemBlocks.length) {
                      throw new Error('åœ¨å¡æ± å†…å®¹ä¸­æœªæ‰¾åˆ°è¦åˆ é™¤çš„é¡¹ç›®ã€‚');
                  }

                  const newContent = newBlocks.map(b => 'åç§°: ' + b.trim()).join('\n\n');
                  
                  await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: newContent }]);
                  
                  this.showTemporaryMessage('åˆ é™¤æˆåŠŸï¼', 'success');
                  this._loadPoolEditorList(poolType);
                  this.loadCharacterPoolFromLorebook();

              } catch (e) {
                  console.error('åˆ é™¤å¡æ± é¡¹ç›®å¤±è´¥:', e);
                  this.showTemporaryMessage(`åˆ é™¤å¤±è´¥: ${e.message}`, 'error');
              }
          },

          _addNewItemToEditor(poolType) {
              const listContainer = document.getElementById('pool-editor-list-container');
              if (!listContainer) return;
              
              // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ–°é¡¹ç›®æ¨¡æ¿
              if (document.getElementById('new-item-editor')) {
                  this.showTemporaryMessage('è¯·å…ˆä¿å­˜æˆ–å–æ¶ˆå½“å‰æ­£åœ¨åˆ›å»ºçš„é¡¹ç›®ã€‚', 'warning');
                  return;
              }

              const newItemElement = this._createEditorItemElement(null, poolType);
              newItemElement.id = 'new-item-editor';
              listContainer.prepend(newItemElement);
              newItemElement.querySelector('details').open = true; // é»˜è®¤å±•å¼€
          },
          
          _createEditorItemElement(item, poolType) {
              const isNew = !item;
              const originalName = isNew ? '' : item.åç§°;
              const element = document.createElement('div');
              element.className = 'pool-editor-item';

              const rarityColor = `var(--tier-${(isNew ? 'R' : item.ç¨€æœ‰åº¦).toLowerCase()}, '#CD7F32')`;

              element.innerHTML = `
                  <details class="pool-editor-card" ${isNew ? 'open' : ''}>
                      <summary class="card-summary-header">
                          <div class="summary-info">
                            <span class="item-name-display">${isNew ? 'ã€æ–°é¡¹ç›®ã€‘' : _.escape(item.åç§°)}</span>
                            <p class="item-description-display-summary">${isNew ? 'ç‚¹å‡»æ­¤å¤„æŠ˜å ' : _.escape(item.æè¿°)}</p>
                          </div>
                          <span class="item-rarity-display" style="color: ${rarityColor};">${isNew ? 'R' : _.escape(item.ç¨€æœ‰åº¦)}</span>
                      </summary>
                      <div class="card-editor-form">
                          <form class="pool-editor-form-inline">
                              <input type="hidden" name="originalName" value="${_.escape(originalName)}">
                              <input type="hidden" name="poolType" value="${poolType}">
                              <label><span>åç§°:</span> <input type="text" name="åç§°" class="stylish-input" value="${isNew ? '' : _.escape(item.åç§°)}" required></label>
                              <label><span>ç¨€æœ‰åº¦:</span>
                                  <div class="stylish-select-wrapper">
                                      <select name="ç¨€æœ‰åº¦" class="stylish-select" required>
                                          <option value="SSR" ${!isNew && item.ç¨€æœ‰åº¦ === 'SSR' ? 'selected' : ''}>SSR</option>
                                          <option value="SR" ${!isNew && item.ç¨€æœ‰åº¦ === 'SR' ? 'selected' : ''}>SR</option>
                                          <option value="R" ${!isNew && item.ç¨€æœ‰åº¦ === 'R' ? 'selected' : ''}>R</option>
                                      </select>
                                      <i class="arrow down"></i>
                                  </div>
                              </label>
                              <label><span>ç±»å‹:</span> <input type="text" name="ç±»å‹" class="stylish-input" value="${isNew ? '' : _.escape(item.ç±»å‹)}" required></label>
                              <label><span>æè¿°:</span> <textarea name="æè¿°" class="stylish-input" rows="2" required>${isNew ? '' : _.escape(item.æè¿°)}</textarea></label>
                              <label><span>è¯¦ç»†ä¿¡æ¯ (ä¸–ç•Œä¹¦å†…å®¹):</span> <textarea name="worldbookContent" class="stylish-input" rows="4">${isNew ? '' : _.escape(item.worldbookContent || '')}</textarea></label>
                              <div class="pool-editor-item-actions">
                                  ${!isNew ? `<button type="button" class="stylish-btn danger-btn btn-delete-item" data-name="${_.escape(item.åç§°)}">åˆ é™¤</button>` : ''}
                                  <button type="submit" class="stylish-btn primary-btn btn-save-item">ä¿å­˜</button>
                              </div>
                          </form>
                      </div>
                  </details>
              `;

              const details = element.querySelector('details');
              const form = element.querySelector('form');

              details.addEventListener('toggle', (event) => {
                  if (isNew && !details.open) {
                      element.remove();
                  }
              });

              form.addEventListener('submit', async (e) => {
                  e.preventDefault();
                  const formData = new FormData(form);
                  const saveData = Object.fromEntries(formData.entries());
                  const success = await this._savePoolItem(saveData);
                  if (success && !isNew) {
                      // æ›´æ–°æˆåŠŸåï¼ŒåŒæ­¥UIå’Œè¡¨å•å†…çš„åŸå§‹åç§°
                      const summaryView = element.querySelector('.card-summary-header');
                      summaryView.querySelector('.item-name-display').textContent = saveData.åç§°;
                      summaryView.querySelector('.item-description-display-summary').textContent = saveData.æè¿°;
                      summaryView.querySelector('.item-rarity-display').textContent = saveData.ç¨€æœ‰åº¦;
                      
                      const newRarityColor = `var(--tier-${saveData.ç¨€æœ‰åº¦.toLowerCase()}, '#CD7F32')`;
                      summaryView.querySelector('.item-rarity-display').style.color = newRarityColor;

                      // æ ¸å¿ƒä¿®å¤ï¼šæ›´æ–°éšè—çš„originalNameå­—æ®µï¼Œä»¥ä¾¿ä¸‹æ¬¡ç¼–è¾‘
                      form.querySelector('input[name="originalName"]').value = saveData.åç§°;
                      
                      details.open = false;
                  } else if (success && isNew) {
                      // å¦‚æœæ˜¯æ–°å»ºé¡¹ç›®ä¸”æˆåŠŸï¼Œåˆ—è¡¨ä¼šè¢«åˆ·æ–°ï¼Œè¿™é‡Œä¸éœ€è¦é¢å¤–æ“ä½œ
                  }
              });

              const deleteBtn = element.querySelector('.btn-delete-item');
              if (deleteBtn) {
                  deleteBtn.addEventListener('click', (e) => {
                      e.preventDefault();
                      const itemName = deleteBtn.dataset.name;
                      if (confirm(`æ‚¨ç¡®å®šè¦ä» [${poolType}] æ± ä¸­åˆ é™¤â€œ${itemName}â€å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚`)) {
                          this._deletePoolItem(itemName, poolType);
                      }
                  });
              }
              return element;
          },

          // æ–°å¢ï¼šä¿å­˜å¡æ± é¡¹ç›®åˆ°ä¸–ç•Œä¹¦
          async _savePoolItem(saveData) {
              this.showTemporaryMessage('æ­£åœ¨ä¿å­˜åˆ°ä¸–ç•Œä¹¦...', 'info');
              const poolCommentMapping = {
                  character: '[è§’è‰²æ± ]',
                  item: '[é“å…·æ± ]',
                  talent: '[å¤©èµ‹æ± ]'
              };
              const targetComment = poolCommentMapping[saveData.poolType];
              if (!targetComment) {
                  this.showTemporaryMessage('é”™è¯¯ï¼šæ— æ•ˆçš„å¡æ± ç±»å‹ï¼', 'error');
                  return false;
              }

              try {
                  const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
                  const allEntries = await TavernHelper.getLorebookEntries(bookName);
                  let targetEntry = allEntries.find(e => e.comment === targetComment && e.enabled === false);
                  
                  // --- æ–°å¢ï¼šé‡åæ£€æŸ¥é€»è¾‘ ---
                  if (targetEntry && saveData.åç§° !== saveData.originalName) {
                      const existingNames = (targetEntry.content.match(/åç§°:\s*(.*)/g) || []).map(line => line.substring(line.indexOf(':') + 1).trim());
                      if (existingNames.includes(saveData.åç§°)) {
                          const overwrite = await this.showCustomConfirm(`å·²å­˜åœ¨åä¸ºâ€œ${saveData.åç§°}â€çš„é¡¹ç›®ã€‚æ‚¨æƒ³è¦è¦†ç›–å®ƒå—ï¼Ÿ`);
                          if (!overwrite) {
                              this.showTemporaryMessage('æ“ä½œå·²å–æ¶ˆ', 'info');
                              return false;
                          }
                      }
                  }

                  let newContent = '';
                  const newItemBlock = `åç§°: ${saveData.åç§°}\nç¨€æœ‰åº¦: ${saveData.ç¨€æœ‰åº¦}\nç±»å‹: ${saveData.ç±»å‹}\næè¿°: ${saveData.æè¿°}\n<è¯¦ç»†ä¿¡æ¯>\n${saveData.worldbookContent}\n</è¯¦ç»†ä¿¡æ¯>`;

                  if (targetEntry) {
                      const itemBlocks = targetEntry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                      let itemFound = false;
                      
                      // ç§»é™¤é‡åé¡¹ï¼ˆå¦‚æœå­˜åœ¨ï¼‰å’Œæ—§åé¡¹
                      const filteredBlocks = itemBlocks.filter(block => {
                          const currentName = ('åç§°:' + block).trim().match(/åç§°:\s*(.*?)\n/)[1];
                          return currentName !== saveData.åç§° && currentName !== saveData.originalName;
                      });

                      const finalBlocks = filteredBlocks.map(b => 'åç§°: ' + b.trim());
                      finalBlocks.push(newItemBlock);
                      newContent = finalBlocks.join('\n\n');
                      
                      await TavernHelper.setLorebookEntries(bookName, [{ uid: targetEntry.uid, content: newContent }]);
                  } else {
                      newContent = newItemBlock;
                      await TavernHelper.createLorebookEntries(bookName, [{ comment: targetComment, content: newContent, enabled: false }]);
                  }
                  
                  this.showTemporaryMessage('ä¿å­˜æˆåŠŸï¼', 'success');
                  this._loadPoolEditorList(saveData.poolType);
                  this.loadCharacterPoolFromLorebook();
                  return true;

              } catch (e) {
                  console.error('ä¿å­˜å¡æ± é¡¹ç›®å¤±è´¥:', e);
                  this.showTemporaryMessage(`ä¿å­˜å¤±è´¥: ${e.message}`, 'error');
                  return false;
              }
          },

          _renderSettingsRedeem(container) {
              container.innerHTML = `
                  <div class="redeem-container">
                      <h3 class="settings-section-title" style="text-align:center;">å¤©é“é¦ˆèµ </h3>
                      <p style="color: #a09c91; font-size: 13px; max-width: 400px; margin: 15px auto;">åœ¨æ­¤è¾“å…¥ç¥ç§˜çš„çœŸè¨€ä»¥æ¢å–å¤©é“çš„é¦ˆèµ ã€‚</p>
                      <div style="display: flex; gap: 10px; align-items: center; justify-content: center;">
                          <input type="text" id="redeem-code-input-settings" placeholder="è¾“å…¥å…‘æ¢ç " class="quick-send-input" style="width: 300px; height: 40px; text-align: center; font-size: 14px;">
                          <button id="btn-redeem-code-settings" class="interaction-btn primary-btn" style="padding: 10px 20px;">å…‘æ¢</button>
                      </div>

                      
                      <div style="margin-top: 40px; padding-top: 20px; border-top: 1px dashed rgba(201, 170, 113, 0.3);">
                          <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; color: #ff6b6b;">
                              <input type="checkbox" id="gacha-cheat-mode-toggle" ${this.isGachaCheatMode ? 'checked' : ''}>
                              <strong>å¼€å¯å†…æµ‹ä½œå¼Šæ¨¡å¼ (æ— é™æ¢¦å°˜)</strong>
                          </label>
                      </div>
                  </div>
              `;
              
              const redeemBtn = document.getElementById('btn-redeem-code-settings');
              const redeemInput = document.getElementById('redeem-code-input-settings');
              const cheatToggle = document.getElementById('gacha-cheat-mode-toggle'); // è·å–æ–°çš„å¼€å…³å…ƒç´ 

              redeemBtn.addEventListener('click', () => {
                  this.handleRedeemCode(redeemInput.value, () => {
                      redeemInput.value = ''; // æˆåŠŸåæ¸…ç©º
                      // æˆåŠŸå…‘æ¢åï¼Œåˆ·æ–°æ•´ä¸ªå¬å”¤ç•Œé¢çš„UIä»¥æ˜¾ç¤ºæœ€æ–°çš„å½’å¢Ÿç‚¹
                      this.renderSummonTab(this.currentGachaPoolType);
                  });
              });
              redeemInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') redeemBtn.click(); });

              // æ–°å¢ï¼šä¸ºä½œå¼Šæ¨¡å¼å¼€å…³ç»‘å®šäº‹ä»¶
              if (cheatToggle) {
                  cheatToggle.addEventListener('change', (e) => {
                      this.isGachaCheatMode = e.target.checked;
                      this.saveGachaCheatState(); // ä¿å­˜çŠ¶æ€åˆ°æœ¬åœ°å­˜å‚¨
                      this.showTemporaryMessage(`ä½œå¼Šæ¨¡å¼å·²${this.isGachaCheatMode ? 'å¼€å¯' : 'å…³é—­'}`);
                  });
              }
          },
  // é‡æ„åçš„ä¸»å‡½æ•° (ç¬¬ä¸‰æ­¥ v2)
          renderSummonTab(activePool = 'character') {
              // --- æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ å®‰å…¨æ£€æŸ¥ ---
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  console.error('[è¡æ¢¦å°˜] æ— æ³•æ¸²æŸ“å¬å”¤ç•Œé¢ï¼šä¸»æ¸¸æˆçŠ¶æ€ (MVU) æœªåŠ è½½ã€‚');
                  const container = document.getElementById('gacha-main-container');
                  if (container) {
                      container.innerHTML = '<p style="text-align:center; color:#8b7355; padding: 50px;">æ— æ³•åŠ è½½è§’è‰²æ•°æ®ï¼Œè¯·å…ˆå¼€å§‹æ¸¸æˆæˆ–å‘é€ä¸€æ¡æ¶ˆæ¯ä»¥åˆå§‹åŒ–çŠ¶æ€ã€‚</p>';
                  }
                  // éšè—æ— å…³å…ƒç´ 
                  const switcher = document.getElementById('gacha-pool-switcher-header');
                  const currency = document.getElementById('gacha-currency-header');
                  if(switcher) switcher.style.display = 'none';
                  if(currency) currency.style.display = 'none';
                  return; // æå‰é€€å‡ºï¼Œé˜²æ­¢å´©æºƒ
              }

              // æ¢å¤è¢«éšè—çš„å…ƒç´ 
              const switcher = document.getElementById('gacha-pool-switcher-header');
              const currency = document.getElementById('gacha-currency-header');
              if(switcher) switcher.style.display = 'flex';
              if(currency) currency.style.display = 'block';

              const mainContainer = document.getElementById('gacha-main-container');
              const switcherContainer = document.getElementById('gacha-pool-switcher-header');
              const currencyContainer = document.getElementById('gacha-currency-header');
              if (!mainContainer || !switcherContainer || !currencyContainer) return;

              const poolInfo = {
                  character: { title: 'é•œèŠ±æ°´æœˆ', bg: 'https://i.postimg.cc/nL2MHDb9/5-1092332438545527-00001.webp' },
                  item: { title: 'ä¸‡è±¡å¥‡ç', bg: 'https://i.postimg.cc/1zsfhKTZ/5-240419165630629-00001.webp' },
                  talent: { title: 'å¤©å‘½çµæ ¹', bg: 'https://i.postimg.cc/GhTBktY6/5-683047889198109-00001.webp' }
              };

              let switcherHtml = '';
              for (const [poolType, data] of Object.entries(poolInfo)) {
                  switcherHtml += `<button class="pool-switch-btn" data-pool="${poolType}" data-title="${data.title}" style="background-image: url('${data.bg}');"></button>`;
              }
              switcherContainer.innerHTML = switcherHtml;

              const guixuPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);
              currencyContainer.innerHTML = `å½’å¢Ÿç‚¹: <strong>${guixuPoints}</strong>`;

              mainContainer.innerHTML = `
                  <div id="gacha-pool-display" style="flex-grow: 1; display: flex;"></div>
                  <button id="btn-gacha-settings-new" class="gacha-corner-btn" title="è®¾ç½®">âš™ï¸</button>
                  <button id="btn-gacha-gallery-new" class="gacha-corner-btn" title="å›¾é‰´">ğŸ–¼ï¸</button>
              `;

              switcherContainer.querySelectorAll('.pool-switch-btn').forEach(btn => {
                  btn.addEventListener('click', () => {
                      this._renderGachaPool(btn.dataset.pool);
                  });
              });

              document.getElementById('btn-gacha-settings-new').addEventListener('click', () => this.showGachaSettingsPopup());
              document.getElementById('btn-gacha-gallery-new').addEventListener('click', () => this.showGachaGalleryPopup(this.currentGachaPoolType));
              
              this._renderGachaPool(activePool);
          },

          // æ–°å¢ï¼šç”¨äºæ¸²æŸ“æ–‡æœ¬ç±»å›¾é‰´çš„è¾…åŠ©å‡½æ•°
          _renderTextBasedGrid(poolType) {
              const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];
              if(allItems.length === 0) return '<p style="color: #a09c91; text-align: center; margin-top: 20px;">æ­¤å›¾é‰´æš‚æ— å†…å®¹</p>';
              
              allItems.sort((a,b) => (b.ç¨€æœ‰åº¦ === 'SSR' ? 3 : b.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1) - (a.ç¨€æœ‰åº¦ === 'SSR' ? 3 : a.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1));
              
              let gridHtml = '';
              allItems.forEach(item => {
                  const isUnlocked = this.gachaCollection[item.id];
                  const rarity = item.ç¨€æœ‰åº¦ || 'R';
                  const name = item.åç§° || 'æœªçŸ¥';
                  const desc = item.æè¿° || 'æš‚æ— æè¿°';
                  const type = item.ç±»å‹ || '';

                  if (isUnlocked) {
                      gridHtml += `
                          <div class="gallery-text-item" data-item-id="${item.id}" data-pool-type="${poolType}">
                              <div class="gallery-text-item-header">
                                  <span class="gallery-text-item-name rarity-${rarity}">${name} ${type ? `(${type})` : ''}</span>
                                  <span class="gallery-text-item-rarity rarity-${rarity}">${rarity}</span>
                              </div>
                              <p class="gallery-text-item-desc">${desc}</p>
                          </div>
                      `;
                  } else {
                      gridHtml += `
                          <div class="gallery-text-item gallery-text-item-locked">
                              <div class="gallery-text-item-header">
                                  <span class="gallery-text-item-name">ï¼Ÿï¼Ÿï¼Ÿ</span>
                                  <span class="gallery-text-item-rarity rarity-${rarity}">${rarity}</span>
                              </div>
                              <p class="gallery-text-item-desc">å°šæœªè·å¾—</p>
                          </div>
                      `;
                  }
              });
              return `<div class="gallery-text-grid">${gridHtml}</div>`;
          },

          renderGalleryTab() {
              const container = document.getElementById('gacha-tab-gallery');
              if(!container) return;
              const renderGrid = (poolType) => {
                  const allItems = [...(this.gachaPools[poolType]?.ssr || []), ...(this.gachaPools[poolType]?.sr || []), ...(this.gachaPools[poolType]?.r || [])];
                  if(allItems.length === 0) return '<p style="color: #a09c91; text-align: center; margin-top: 20px;">æ­¤å›¾é‰´æš‚æ— å†…å®¹</p>';
                  allItems.sort((a,b) => (a.ç¨€æœ‰åº¦ === 'SSR' ? 3 : a.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1) - (b.ç¨€æœ‰åº¦ === 'SSR' ? 3 : b.ç¨€æœ‰åº¦ === 'SR' ? 2 : 1));
                  let gridHtml = '';
                  allItems.forEach(item => {
                      const isUnlocked = this.gachaCollection[item.id];
                      const cardClass = `gallery-card rarity-${item.ç¨€æœ‰åº¦} ${isUnlocked ? 'unlocked' : 'gallery-card-locked'}`;
                      const bgImageStyle = isUnlocked && item.å›¾ç‰‡ ? `background-image: url('${item.å›¾ç‰‡}');` : '';
                      gridHtml += `<div class="${cardClass}" title="${item.åç§°}" data-item-id="${item.id}" data-pool-type="${poolType}" style="${bgImageStyle}">${isUnlocked ? `<div class="gallery-card-name">${item.åç§°}</div>` : ''}</div>`;
                  });
                  return `<div class="gallery-grid">${gridHtml}</div>`;
              }
              container.innerHTML = `
                  <details class="gallery-section" open><summary class="section-title">è§’è‰²å›¾é‰´</summary>${renderGrid('character')}</details>
                  <details class="gallery-section" open><summary class=\"section-title\">é“å…·å›¾é‰´</summary>${this._renderTextBasedGrid('item')}</details>
                  <details class=\"gallery-section\" open><summary class=\"section-title\">å¤©èµ‹å›¾é‰´</summary>${this._renderTextBasedGrid('talent')}</details>
              `;
             
              container.querySelectorAll('.gallery-grid, .gallery-text-grid').forEach(grid => {
                  grid.addEventListener('click', e => {
                      const card = e.target.closest('.gallery-card.unlocked, .gallery-text-item:not(.gallery-text-item-locked)');
                      if (!card) return;
                      const itemId = card.dataset.itemId;
                      const poolType = card.dataset.poolType;
                      const allItems = [...this.gachaPools[poolType].ssr, ...this.gachaPools[poolType].sr, ...this.gachaPools[poolType].r];
                      const itemData = allItems.find(i => i.id === itemId);
                      if (itemData) this.showGachaItemDetails(itemData, poolType);
                  });
              });
          },

          renderShopTab() {
              const container = document.getElementById('gacha-tab-shop');
              if (!container) return;
              container.innerHTML = `
                  <div class="shop-container" style="display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100%; gap: 25px; padding: 20px; text-align: center;">
                      <h3 class="pool-title">å¤©é“é¦ˆèµ </h3>
                      <p style="color: #a09c91; font-size: 13px; max-width: 400px;">åœ¨æ­¤è¾“å…¥ç¥ç§˜çš„çœŸè¨€ä»¥æ¢å–å¤©é“çš„é¦ˆèµ ã€‚æŸäº›çœŸè¨€æˆ–è®¸ä½è¯­ç€å¤§èƒ½çš„åè®³ï¼Œè•´å«ç€è«å¤§çš„æœºç¼˜ã€‚</p>
                      <div style="display: flex; gap: 10px; align-items: center;">
                          <input type="text" id="redeem-code-input" placeholder="è¾“å…¥å…‘æ¢ç " class="quick-send-input" style="width: 300px; height: 40px; text-align: center; font-size: 14px;">
                          <button id="btn-redeem-code" class="interaction-btn primary-btn" style="padding: 10px 20px;">å…‘æ¢</button>
                      </div>
                      
                  <div class="gacha-currency">å½“å‰æ¢¦å°˜: <strong>${this.gachaState.mengChen}</strong></div>
                  <div style="margin-top: 20px; padding-top: 20px; border-top: 1px dashed rgba(201, 170, 113, 0.3);">
                      <label style="display: flex; align-items: center; justify-content: center; gap: 8px; cursor: pointer; color: #ff6b6b;">
                          <input type="checkbox" id="gacha-cheat-mode-toggle" ${this.isGachaCheatMode ? 'checked' : ''}>
                          <strong>å¼€å¯å†…æµ‹ä½œå¼Šæ¨¡å¼ (æ— é™æ¢¦å°˜)</strong>
                      </label>
                  </div>
              </div>
              `;
              document.getElementById('btn-redeem-code').addEventListener('click', () => this.handleRedeemCode());
              document.getElementById('redeem-code-input').addEventListener('keypress', (e) => { if (e.key === 'Enter') { document.getElementById('btn-redeem-code').click(); } });
 
              document.getElementById('gacha-cheat-mode-toggle').addEventListener('change', (e) => {
                  this.isGachaCheatMode = e.target.checked;
                  this.saveGachaCheatState();
                  this.showTemporaryMessage(`ä½œå¼Šæ¨¡å¼å·²${this.isGachaCheatMode ? 'å¼€å¯' : 'å…³é—­'}`);
              });
         },

          handlePull(count, poolType) {
      // --- æ ¸å¿ƒä¿®å¤ï¼šå¢åŠ å®‰å…¨æ£€æŸ¥ ---
              if (!this.currentMvuState || !this.currentMvuState.stat_data) {
                  this.showTemporaryMessage('é”™è¯¯ï¼šè§’è‰²æ•°æ®æœªåŠ è½½ï¼Œæ— æ³•è¿›è¡Œå¬å”¤ã€‚');
                  return;
              }

        const costs = { character: 320, item: 160, talent: 160 };
              const cost = count * costs[poolType];
              const currentPoints = this.SafeGetValue(this.currentMvuState.stat_data, 'å½’å¢Ÿç‚¹', 0);

              if (!this.isGachaCheatMode) {
                  if (currentPoints < cost) {
                      this.showTemporaryMessage('å½’å¢Ÿç‚¹ä¸è¶³ï¼');
                      return;
                  }
                  // ä¸å†ç›´æ¥æ‰£é™¤ï¼Œè€Œæ˜¯ç”ŸæˆæŒ‡ä»¤
                  const command = `_.add('å½’å¢Ÿç‚¹[0]', -${cost}); // è¡æ¢¦å°˜æ¶ˆè€—`;
                  this.pendingActions.push({ action: 'variable_update', command: command, text: `[æ¶ˆè€—] å½’å¢Ÿç‚¹ x ${cost}` });
                  this.savePendingActions();
                  this.showTemporaryMessage(`å·²å°† [æ¶ˆè€— ${cost} å½’å¢Ÿç‚¹] åŠ å…¥æŒ‡ä»¤ä¸­å¿ƒ`);
              }
              
              // ä¹è§‚æ›´æ–°UIï¼Œè®©ç”¨æˆ·æ„Ÿè§‰ç‚¹æ•°å·²æ‰£é™¤
              const currencyContainer = document.getElementById('gacha-currency-header');
              if (currencyContainer) {
                  currencyContainer.innerHTML = `å½’å¢Ÿç‚¹: <strong>${currentPoints - cost}</strong>`;
              }

              const results = [];
             let gotSR_or_above = false;
              for (let i = 0; i < count; i++) {
                  const result = this.getGachaRoll(poolType);
                  results.push(result);
                  if (result.rarity === 'SR' || result.rarity === 'SSR') gotSR_or_above = true;
              }
              if (count === 10 && !gotSR_or_above) {
                  results[Math.floor(Math.random() * 10)] = this.getRandomItemFromPool(poolType, ['sr']);
              }
              this.processPullResults(results, poolType);
              this.saveGachaState();
              // Bugä¿®å¤ï¼šå…³é—­ç»“æœçª—å£åï¼Œä¸å†éœ€è¦åœ¨è¿™é‡Œåˆ·æ–°ï¼Œå› ä¸ºå…³é—­æ—¶ä¼šåˆ·æ–°
              // this.renderSummonTab(poolType);
          },

          getGachaRoll(poolType) {
              const pitySRKey = `pitySR_${poolType}`;
              const pitySSRKey = `pitySSR_${poolType}`;
              this.gachaState[pitySRKey]++;
              this.gachaState[pitySSRKey]++;
              if (this.gachaState[pitySSRKey] >= 90) return this.getSSRItem(poolType);
              if (this.gachaState[pitySRKey] >= 10) return this.getSRItem(poolType);
              const rand = Math.random();
              let softPityRate = this.gachaState[pitySSRKey] >= 74 ? (this.gachaState[pitySSRKey] - 73) * 0.06 : 0;
              if (rand < 0.006 + softPityRate) return this.getSSRItem(poolType);
              if (rand < 0.006 + softPityRate + 0.051) return this.getSRItem(poolType);
              return this.getRandomItemFromPool(poolType, ['r']);
          },

          getSSRItem(poolType) {
              this.gachaState[`pitySSR_${poolType}`] = 0;
              this.gachaState[`pitySR_${poolType}`] = 0;
              return this.getRandomItemFromPool(poolType, ['ssr']);
          },

          getSRItem(poolType) {
              this.gachaState[`pitySR_${poolType}`] = 0;
              return this.getRandomItemFromPool(poolType, ['sr']);
          },

          getRandomItemFromPool(poolType, rarities) {
              const pool = rarities.flatMap(r => this.gachaPools[poolType][r.toLowerCase()] || []);
              if (pool.length === 0) {
                  console.error(`[è¡æ¢¦å°˜] è­¦å‘Š: å¡æ±  (${poolType} - ${rarities.join(', ')}) ä¸ºç©ºã€‚`);
                  return { id: 'fallback', åç§°: 'è™šæ— ä¹‹å½±', ç¨€æœ‰åº¦: 'R', ç±»å‹: 'é”™è¯¯' }; 
              }
              return pool[Math.floor(Math.random() * pool.length)];
          },

          processPullResults(results, poolType) {
              this.openModal('gacha-results-modal', true);
              const gridContainer = document.getElementById('gacha-results-grid');
              if (!gridContainer) return;
              gridContainer.innerHTML = '';
              gridContainer.className = results.length === 1 ? 'gacha-results-grid single-pull' : 'gacha-results-grid';
              results.forEach((res) => {
                  const isDuplicate = !!this.gachaCollection[res.id];
                  if (!isDuplicate) {
                      this.gachaCollection[res.id] = { acquired: new Date().toISOString() };
                  }
                  const dustReward = res.ç¨€æœ‰åº¦ === 'SSR' ? 80 : res.ç¨€æœ‰åº¦ === 'SR' ? 20 : 5;
                  if (isDuplicate) {
                      if (!this.isGachaCheatMode) {
                          // ä¸å†ç›´æ¥å¢åŠ ï¼Œè€Œæ˜¯ç”ŸæˆæŒ‡ä»¤
                          const command = `_.add('å½’å¢Ÿç‚¹[0]', ${dustReward}); // é‡å¤è·å¾—è¡¥å¿`;
                          this.pendingActions.push({ action: 'variable_update', command: command, text: `[è·å¾—] å½’å¢Ÿç‚¹ x ${dustReward}` });
                          this.savePendingActions();
                          this.showTemporaryMessage(`${res.åç§°} (é‡å¤)ï¼Œè¡¥å¿æŒ‡ä»¤å·²å…¥é˜Ÿ`);
                      } else {
                          this.showTemporaryMessage(`${res.åç§°} (é‡å¤)`);
                      }
                  }
                                  const card = document.createElement('div');
                  
                  if (poolType === 'character') {
                      card.className = `gacha-results-card rarity-${res.ç¨€æœ‰åº¦.toUpperCase()}`;
                      if (res.å›¾ç‰‡) card.style.backgroundImage = `url('${res.å›¾ç‰‡}')`;
                      
                      const infoContainer = document.createElement('div');
                      infoContainer.className = 'gacha-results-card-info';
                      infoContainer.innerHTML = `<div class="item-name">${res.åç§°}</div><div class="item-rarity">${res.ç¨€æœ‰åº¦}</div>`;
                      if (isDuplicate) {
                          infoContainer.innerHTML += `<div class="gacha-results-duplicate-tag">é‡å¤</div>`;
                      }
                      card.appendChild(infoContainer);

                      if (!isDuplicate) {
                          const newTag = document.createElement('div');
                          newTag.className = 'gacha-results-new-tag';
                          newTag.textContent = 'NEW';
                          card.appendChild(newTag);
                      }
                  } else {
                      card.className = `gacha-results-card-text rarity-${res.ç¨€æœ‰åº¦.toUpperCase()}`;
                      let cardContentHtml = `<div class="item-name">${res.åç§°}</div>`;
                      cardContentHtml += `<div class="item-rarity">${res.ç¨€æœ‰åº¦}</div>`;
                      if (res.ç±»å‹) {
                          cardContentHtml += `<div class="item-type">${res.ç±»å‹}</div>`;
                      }
                      if (isDuplicate) {
                          cardContentHtml += `<div class="gacha-results-duplicate-tag" style="margin-top: 10px;">é‡å¤</div>`;
                      }
                      card.innerHTML = cardContentHtml;

                      if (!isDuplicate) {
                          const newTag = document.createElement('div');
                          newTag.className = 'gacha-results-new-tag';
                          newTag.textContent = 'NEW';
                          card.appendChild(newTag);
                      }
                  }
                  gridContainer.appendChild(card);
              });
              this.gachaHistory.unshift({ timestamp: new Date().toISOString(), results: results, poolType: poolType });
              if (this.gachaHistory.length > 200) this.gachaHistory.pop();
              this.saveGachaState();
          },

          showGachaHistory(page = 1) {
              this.openModal('gacha-history-modal', true);
              const listContainer = document.getElementById('gacha-history-list');
              const indicatorEl = document.getElementById('gacha-history-page-indicator');
              const prevBtn = document.getElementById('gacha-history-prev-btn');
              const nextBtn = document.getElementById('gacha-history-next-btn');

              if (!listContainer || !indicatorEl || !prevBtn || !nextBtn) {
                  console.error('è¡æ¢¦å°˜å†å²è®°å½•ç•Œé¢UIå…ƒç´ ç¼ºå¤±!');
                  return;
              }

              const itemsPerPage = 5;
              const totalPages = Math.ceil(this.gachaHistory.length / itemsPerPage);
              const currentPage = Math.max(1, Math.min(page, totalPages || 1));
              const pageItems = this.gachaHistory.slice((currentPage - 1) * itemsPerPage, currentPage * itemsPerPage);

              // æ ¸å¿ƒä¿®æ”¹ï¼šå€Ÿé‰´â€œè¯¡ç§˜â€UIçš„ç®€å•å¾ªç¯é€»è¾‘ï¼Œå¹¶å¢åŠ å®‰å…¨æ£€æŸ¥
              let html = pageItems.length > 0 ? '' : '<p style=\"color:#a09c91; text-align:center; padding: 40px 0;\">æš‚æ— å¬å”¤è®°å½•</p>';
              pageItems.forEach(entry => {
                  // å®‰å…¨æ£€æŸ¥ (1): å¦‚æœè®°å½•æ¡ç›®æˆ–å…¶ç»“æœæ•°ç»„ä¸å­˜åœ¨ï¼Œåˆ™è·³è¿‡æ­¤æ¡è®°å½•ï¼Œé¿å…ç¨‹åºå´©æºƒ
                  if (!entry || !entry.results) { 
                      console.warn('å‘ç°å¹¶è·³è¿‡ä¸€æ¡æŸåçš„å¬å”¤å†å²è®°å½•:', entry);
                      return; 
                  }
                  const poolType = entry.poolType || 'character';
                  const poolNames = { character: 'é•œèŠ±æ°´æœˆ', item: 'ä¸‡è±¡å¥‡ç', talent: 'å¤©å‘½çµæ ¹' };
                  const poolName = poolNames[poolType] || 'æœªçŸ¥å¡æ± ';

                  const resultsHtml = entry.results.map(res => {
                      // å®‰å…¨æ£€æŸ¥ (2): å¦‚æœç»“æœæ•°ç»„ä¸­çš„æŸä¸ªç‰©å“ä¸å­˜åœ¨ï¼Œä¹Ÿè·³è¿‡å®ƒ
                      if (!res) return '';
                      const rarity = res.ç¨€æœ‰åº¦ || 'R';
                      const name = res.åç§° || 'æœªçŸ¥ç‰©å“';
                      return `<div class=\"gacha-history-item-card rarity-${rarity.toUpperCase()}\" title=\"${name}\">${name}</div>`;
                  }).join('');

                  // ä½¿ç”¨ += æ‹¼æ¥å­—ç¬¦ä¸²ï¼Œè¿™æ˜¯æœ€ç®€å•ä¸”å®¹é”™æ€§é«˜çš„å¾ªç¯æ¸²æŸ“æ–¹å¼
                  html += `
                      <div class=\"gacha-history-entry\">
                          <div class=\"gacha-history-header\">
                              <span class=\"gacha-history-timestamp\">${new Date(entry.timestamp).toLocaleString('zh-CN')}</span>
                              <span class=\"gacha-history-pool\">${poolName}</span>
                          </div>
                          <div class=\"gacha-history-results-grid\">
                              ${resultsHtml}
                          </div>
                      </div>
                  `;
              });

              listContainer.className = 'gacha-history-list';
              listContainer.innerHTML = html;

              indicatorEl.textContent = `ç¬¬ ${currentPage} / ${totalPages || 1} é¡µ`;

              const newPrevBtn = prevBtn.cloneNode(true);
              prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
              const newNextBtn = nextBtn.cloneNode(true);
              nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
              
              newPrevBtn.disabled = currentPage <= 1;
              newNextBtn.disabled = currentPage >= totalPages;

              if (!newPrevBtn.disabled) newPrevBtn.onclick = () => this.showGachaHistory(currentPage - 1);
              if (!newNextBtn.disabled) newNextBtn.onclick = () => this.showGachaHistory(currentPage + 1);
          },

          
          showGachaItemDetails(itemData, poolType) {
              const titleEl = document.getElementById('gacha-details-title');
              const bodyEl = document.getElementById('gacha-details-body');
              const footerEl = document.getElementById('gacha-details-footer');
              if (!titleEl || !bodyEl || !footerEl) return;

              titleEl.textContent = itemData.åç§°;
              let imageHtml = poolType === 'character' ? `<div class="gacha-details-image-large" style="background-image: url('${itemData.å›¾ç‰‡ || ''}');"></div>` : '';
              let infoHtml = `<div class="gacha-details-info">
                  <p><strong>ç¨€æœ‰åº¦:</strong> ${itemData.ç¨€æœ‰åº¦ || 'æœªçŸ¥'}</p>
                  <p><strong>ç±»å‹:</strong> ${itemData.ç±»å‹ || itemData.ç³»åˆ— || 'æœªçŸ¥'}</p>
                  <p><strong>æè¿°:</strong> ${itemData.æè¿° || 'æš‚æ— è¯¦ç»†æè¿°'}</p>
              </div>`;
              bodyEl.innerHTML = imageHtml + infoHtml;

              const companions = this.gachaState.activeCompanions || [];
              const isAlreadyActive = companions.some(c => c.id === itemData.id);
              const isAlreadyQueued = this.pendingActions.some(action => action.action === 'join_world' && action.itemName === itemData.åç§°);

              let joinButtonHtml = '';
              if (isAlreadyActive) {
                  joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>å·²åœ¨ä¸–ç•Œä¸­</button>`;
              } else if (isAlreadyQueued) {
                  joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>å·²åœ¨æŒ‡ä»¤é˜Ÿåˆ—</button>`;
              } else {
                  let isDisabled = false;
                  let disabledReason = '';
                  if (poolType === 'character') {
                      const totalLimitReached = companions.length >= 3;
                      const ssrLimitReached = companions.filter(c => c.rarity === 'SSR').length >= 1;
                      const isCharSSR = itemData.ç¨€æœ‰åº¦ === 'SSR';

                      if (totalLimitReached) { isDisabled = true; disabledReason = `ä¼™ä¼´å·²æ»¡ (${companions.length}/3)`; }
                      else if (isCharSSR && ssrLimitReached) { isDisabled = true; disabledReason = `SSRä¼™ä¼´å·²æ»¡ (1/1)`; }
                  }
                  
                  if (isDisabled) {
                      joinButtonHtml = `<button class="interaction-btn primary-btn" disabled>${disabledReason}</button>`;
                  } else {
                      joinButtonHtml = `<button id="btn-gacha-join-world" class="interaction-btn primary-btn">åŠ å…¥å½“å‰ä¸–ç•Œ</button>`;
                  }
              }

              footerEl.innerHTML = `
                  <button onclick="GuixuManager.closeModal('gacha-details-modal')" class="interaction-btn">å…³é—­</button>
                  ${joinButtonHtml}
              `;

              const joinButton = document.getElementById('btn-gacha-join-world');
              if (joinButton) {
                  joinButton.onclick = () => this.handleJoinWorld(itemData, poolType);
              }

              this.openModal('gacha-details-modal', true);
          },

          _parseLorebookCharacter(contentBlock, poolType) {
              const item = {};
              const lines = contentBlock.split('\n');
              lines.forEach(line => {
                  const parts = line.split(':');
                  if (parts.length < 2) return;
                  const key = parts[0].trim();
                  const value = parts.slice(1).join(':').trim();
                  switch (key) {
                      case 'åç§°': item.åç§° = value; break;
                      case 'ç³»åˆ—': item.ç³»åˆ— = value; break;
                      case 'å›¾ç‰‡': item.å›¾ç‰‡ = value; break;
                      case 'ç¨€æœ‰åº¦': item.ç¨€æœ‰åº¦ = value.toUpperCase(); break;
                      case 'ç±»å‹': item.ç±»å‹ = value; break;
                      case 'æè¿°': item.æè¿° = value; break;
                  }
              });
              if (item.åç§° && item.ç¨€æœ‰åº¦) return item;
              return null;
          },

          async loadCharacterPoolFromLorebook() {
              this.showTemporaryMessage('æ­£åœ¨ä»ä¸–ç•Œä¹¦åŒæ­¥è¡æ¢¦å°˜å¡æ± ...', 1500);
              const bookName = 'ã€å½’å¢Ÿæ‰©å±•ã€‘è¡æ¢¦å°˜å¡æ± ';
              const newPools = { character: { ssr: [], sr: [], r: [] }, item: { ssr: [], sr: [], r: [] }, talent: { ssr: [], sr: [], r: [] } };
              try {
                  const entries = await TavernHelper.getLorebookEntries(bookName);
                  if (!entries || entries.length === 0) { this.showTemporaryMessage(`è­¦å‘Šï¼šæœªæ‰¾åˆ°æˆ–â€œ${bookName}â€ä¸–ç•Œä¹¦ä¸ºç©ºã€‚`, 3000); return; }
                  let count = 0;
                  const poolMapping = { '[è§’è‰²æ± ]': 'character', '[é“å…·æ± ]': 'item', '[å¤©èµ‹æ± ]': 'talent' };
                  for (const entry of entries) {
                      const poolType = poolMapping[entry.comment];
                      if (poolType && entry.enabled === false) {
                          const itemBlocks = entry.content.split(/\n*\s*åç§°:/).filter(block => block.trim() !== '');
                          for (const block of itemBlocks) {
                              const fullBlock = 'åç§°:' + block;
                              const item = this._parseGachaPoolEntry(fullBlock);
                              if (item) {
                                  item.id = `${poolType}_${item.åç§°}`.replace(/\s/g, '_');
                                  const rarityKey = item.ç¨€æœ‰åº¦.toLowerCase();
                                  if (newPools[poolType][rarityKey]) {
                                      newPools[poolType][rarityKey].push(item);
                                      count++;
                                  }
                              }
                          }
                      }
                  }
                  this.gachaPools = newPools;
                  console.log(`[è¡æ¢¦å°˜] æˆåŠŸä»ä¸–ç•Œä¹¦åŠ è½½ ${count} ä¸ªé¡¹ç›®ã€‚`);
                  if (count === 0) this.showTemporaryMessage('æœªåœ¨ç¦ç”¨çš„æ¡ç›®ä¸­æ‰¾åˆ°ä»»ä½•æ ¼å¼æ­£ç¡®çš„å¡æ± é¡¹ç›®ã€‚', 4000);
              } catch (e) {
                  console.error('åŠ è½½è¡æ¢¦å°˜å¡æ± å¤±è´¥:', e);
                  this.showTemporaryMessage('é”™è¯¯ï¼šåŠ è½½å¡æ± å¤±è´¥ï¼Œè¯·æ£€æŸ¥ä¸–ç•Œä¹¦ã€‚', 3000);
              }
          },

          _parseGachaPoolEntry(blockText) {
              const item = {};
              const lines = blockText.trim().split('\n');
              let worldbookContent = '';
              let isDetailSection = false;

              for (const line of lines) {
                  if (line.trim() === '<è¯¦ç»†ä¿¡æ¯>') {
                      isDetailSection = true;
                      continue;
                  }
                  if (line.trim() === '</è¯¦ç»†ä¿¡æ¯>') {
                      isDetailSection = false;
                      continue;
                  }

                  if (isDetailSection) {
                      worldbookContent += line + '\n';
                  } else {
                      const match = line.match(/^([^:]+):\s*(.*)$/);
                      if (match) {
                          const key = match[1].trim();
                          const value = match[2].trim();
                          item[key] = value;
                      }
                  }
              }

              item.worldbookContent = worldbookContent.trim();

              if (item.åç§° && item.ç¨€æœ‰åº¦ && item.ç±»å‹ && item.æè¿°) {
                  return item;
              }
              return null;
          },

          async handleRedeemCode(code, onSuccessCallback) {
              if (!code || !code.trim()) {
                  this.showTemporaryMessage('è¯·è¾“å…¥å…‘æ¢ç ã€‚');
                  return;
              }
              const upperCaseCode = code.trim().toUpperCase();
              
              const manualCodeDB = {
                  'GUIXU666': { reward: 1600, type: 'mengChen' },
                  'MENGXING888': { reward: 3200, type: 'mengChen' }
              };
              const manualEntry = manualCodeDB[upperCaseCode];
              
              if (manualEntry) {
                  if (this.gachaState.redeemedCodes.includes(upperCaseCode)) {
                      this.showTemporaryMessage('æ‚¨å·²ç»å…‘æ¢è¿‡è¿™ä¸ªç¤¼åŒ…äº†ã€‚');
                      if (onSuccessCallback) onSuccessCallback();
                      return;
                  }
                  // ç›´æ¥æ‰§è¡ŒMVUæŒ‡ä»¤ï¼Œç«‹å³å¢åŠ å½’å¢Ÿç‚¹
                  const command = `_.add('å½’å¢Ÿç‚¹[0]', ${manualEntry.reward}); // å…‘æ¢ç å¥–åŠ±`;
                  await this.executeMvuCommandDirect(command);

                  this.gachaState.redeemedCodes.push(upperCaseCode);
                  this.saveGachaState(); // åªä¿å­˜å…‘æ¢ç ä½¿ç”¨è®°å½•
                  this.showTemporaryMessage(`å…‘æ¢æˆåŠŸï¼è·å¾— ${manualEntry.reward} å½’å¢Ÿç‚¹ï¼`, 3000);
                  if (onSuccessCallback) onSuccessCallback();
                  return;
              }
               this.showTemporaryMessage('æ— æ•ˆçš„å…‘æ¢ç ã€‚');
          },
     

          saveGachaCheatState() {
              AppStorage.saveData('gacha_cheat_mode', this.isGachaCheatMode);
          },

          loadGachaCheatState() {
              this.isGachaCheatMode = AppStorage.loadData('gacha_cheat_mode', false);
          },

          _loadGachaDataFromSave(saveData) {
              if (saveData && saveData.gacha_data) {
                  this.gachaState = saveData.gacha_data.state;
                  this.gachaCollection = saveData.gacha_data.collection;
                  this.gachaHistory = saveData.gacha_data.history;
                  console.log('[è¡æ¢¦å°˜] å·²æˆåŠŸä»å­˜æ¡£æ–‡ä»¶åŠ è½½Gachaæ•°æ®ã€‚');
              } else {
                  // å¦‚æœæ˜¯æ—§å­˜æ¡£æˆ–æ–°æ¸¸æˆï¼Œåˆ™é‡ç½®ä¸ºåˆå§‹çŠ¶æ€
                  this.gachaState = { mengChen: 1600, pitySSR_char: 0, pitySR_char: 0, pitySSR_item: 0, pitySR_item: 0, pitySSR_talent: 0, pitySR_talent: 0, redeemedCodes: [] };
                  this.gachaCollection = {};
                  this.gachaHistory = [];
                  console.log('[è¡æ¢¦å°˜] æœªåœ¨å­˜æ¡£ä¸­æ‰¾åˆ°Gachaæ•°æ®ï¼Œå·²é‡ç½®ä¸ºåˆå§‹çŠ¶æ€ã€‚');
              }
              // å°†ä»å­˜æ¡£åŠ è½½çš„çŠ¶æ€ï¼Œç«‹åˆ»ä¿å­˜ä¸ºå½“å‰çš„å®æ—¶çŠ¶æ€ï¼Œä»¥ä¾¿åˆ·æ–°åèƒ½æ­£ç¡®ä¿ç•™
              this.saveGachaState();
          },
     
          // â€œåŠ å…¥ä¸–ç•Œâ€æ ¸å¿ƒé€»è¾‘é‡æ„ (v4 - åˆ›å»º/è¦†ç›–ä¸–ç•Œä¹¦)
          async handleJoinWorld(itemData, poolType) {
              // æ£€æŸ¥æ˜¯å¦å·²æœ‰æ¿€æ´»æˆ–å¾…å¤„ç†
              const isAlreadyQueued = this.pendingActions.some(action => action.itemName === itemData.åç§°);
              if (isAlreadyQueued) {
                  this.showTemporaryMessage(`[${itemData.åç§°}] å·²åœ¨æŒ‡ä»¤é˜Ÿåˆ—ä¸­ã€‚`, 'info');
                  return;
              }
              const isAlreadyActive = poolType === 'character' ?
                  this.gachaState.activeCompanions.some(c => c.id === itemData.id) :
                  this.gachaState.activatedItems.includes(itemData.id);
              if (isAlreadyActive) {
                  this.showTemporaryMessage(`[${itemData.åç§°}] å·²åŠ å…¥æˆ–å·²æ¿€æ´»ã€‚`, 'info');
                  return;
              }

              // æ ¸å¿ƒé€»è¾‘ï¼šåˆ›å»ºæˆ–è¦†ç›–ä¸–ç•Œä¹¦
              if (!itemData.worldbookContent || itemData.worldbookContent.trim() === '') {
                  this.showTemporaryMessage(`â€œ${itemData.åç§°}â€æ²¡æœ‰è¯¦ç»†ä¿¡æ¯ï¼Œæ— æ³•å†™å…¥ä¸–ç•Œä¹¦ã€‚`, 'warning');
              } else {
                  this.showTemporaryMessage(`æ­£åœ¨ä¸ºâ€œ${itemData.åç§°}â€å†™å…¥ä¸–ç•Œä¹¦...`, 'info');
                  try {
                      const bookName = '1å½’å¢Ÿ';
                      const allEntries = await TavernHelper.getLorebookEntries(bookName);
                      const existingEntry = allEntries.find(entry => entry.comment === itemData.åç§°);

                      if (existingEntry) {
                          await TavernHelper.setLorebookEntries(bookName, [{
                              uid: existingEntry.uid,
                              content: itemData.worldbookContent,
                              enabled: true
                          }]);
                          this.showTemporaryMessage(`å·²æˆåŠŸè¦†ç›–â€œ${itemData.åç§°}â€çš„ä¸–ç•Œä¹¦æ¡ç›®ï¼`, 'success');
                      } else {
                          await TavernHelper.createLorebookEntries(bookName, [{
                              comment: itemData.åç§°,
                              content: itemData.worldbookContent,
                              enabled: true
                          }]);
                          this.showTemporaryMessage(`å·²ä¸ºâ€œ${itemData.åç§°}â€åˆ›å»ºæ–°çš„ä¸–ç•Œä¹¦æ¡ç›®ï¼`, 'success');
                      }
                  } catch (e) {
                      console.error('å†™å…¥ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥:', e);
                      this.showTemporaryMessage('å†™å…¥ä¸–ç•Œä¹¦æ¡ç›®å¤±è´¥', 'error');
                      return; // å†™å…¥å¤±è´¥åˆ™ä¸­æ­¢
                  }
              }

              // æ›´æ–°UIå’ŒçŠ¶æ€
              if (poolType === 'character') {
                  this.gachaState.activeCompanions.push({ id: itemData.id, name: itemData.åç§°, rarity: itemData.ç¨€æœ‰åº¦ });
              } else {
                  this.gachaState.activatedItems.push(itemData.id);
              }
              this.saveGachaState();

              // æ·»åŠ åˆ°å¾…å¤„ç†æŒ‡ä»¤é˜Ÿåˆ—
              const simpleAction = {
                  action: 'acquire_item_talent',
                  itemName: itemData.åç§°,
                  itemData: { ç±»å‹: itemData.ç±»å‹ || 'è§’è‰²', æè¿°: itemData.æè¿° || 'æ— ç®€ä»‹' }
              };
              this.pendingActions.push(simpleAction);
              this.savePendingActions();

              // å…³é—­å’Œåˆ·æ–°UI
              if (document.getElementById('gacha-gallery-popup').style.display === 'flex') {
                  this.showGachaGalleryPopup(poolType);
              }
              this.closeModal('gacha-details-modal');
          }, };

       // å°†GuixuManageræš´éœ²åˆ°å…¨å±€ä½œç”¨åŸŸï¼Œä»¥ä¾¿onclickäº‹ä»¶å¯ä»¥è®¿é—®
       if (window.GuixuManager && typeof window.GuixuManager.destroy === 'function') {
         window.GuixuManager.destroy();
       }
       window.GuixuManager = GuixuManager;
 
         // --- Entry Point ---
          // ç±»è„‘/æ—…ç¨‹æ¢¦æ˜Ÿä½œå“ï¼Œç¦æ­¢äºŒä¼ ï¼Œç¦æ­¢å•†ä¸šåŒ–ï¼Œå‡æ— å¿å…è´¹å¼€æºåˆ†äº«
          eventOn(tavern_events.APP_READY, () => {
            GuixuManager.init();
            
            // è¿‡æ»¤æ— å…³çš„æ§åˆ¶å°é”™è¯¯ï¼Œé¿å…å¹²æ‰°è°ƒè¯•
            const originalConsoleError = console.error;
            console.error = function(...args) {
              const message = args.join(' ');
              // è¿‡æ»¤æ‰ä¸å½’å¢ŸPlusæ— å…³çš„èµ„æºåŠ è½½é”™è¯¯
              if (message.includes('ui-icons') ||
                  message.includes('MIME type') ||
                  message.includes('stylesheet MIME type') ||
                  message.includes('404 (Not Found)')) {
                return; // é™é»˜å¤„ç†è¿™äº›é”™è¯¯
              }
              // å…¶ä»–é”™è¯¯æ­£å¸¸è¾“å‡º
              originalConsoleError.apply(console, args);
            };
          });
  
          // äº‹ä»¶ç›‘å¬å·²åœ¨ GuixuManager.init() ä¸­å¤„ç†ï¼Œæ­¤å¤„ä¸å†éœ€è¦
      })();
